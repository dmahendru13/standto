!function r(e, n, t) {
    function o(i, f) {
        if (!n[i]) {
            if (!e[i]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i, !0);
                if (u) return u(i, !0);
                var a = new Error("Cannot find module '" + i + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i] = {
                exports: {}
            };
            e[i][0].call(p.exports, function(r) {
                return o(e[i][1][r] || r);
            }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
    }
    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
    return o;
}({
    1: [ function(require, module, exports) {
        "use strict";
        var navbar, Header = require("./modules/Header"), ScrollNav = require("./modules/ScrollNav");
        navbar = document.getElementsByClassName("navbar")[0].parentNode, new Header("menu"), 
        new Header("search"), new ScrollNav(navbar, 150);
    }, {
        "./modules/Header": 2,
        "./modules/ScrollNav": 4
    } ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = require("./Helper"), Header = function() {
            function Header(section) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, Header), this.section = section, this.sectionBtn = document.getElementsByClassName(section + "-button")[0], 
                this.sectionWin = document.getElementsByClassName(section + "-window")[0], this.headerElem = document.getElementsByTagName("header")[0], 
                this.navbtns = document.getElementsByClassName("nav-button"), this.navwins = document.getElementsByClassName("nav-window"), 
                this.sectionBtn.addEventListener("click", this.toggleNavOption.bind(this), !1);
                var len, checkboxes = this.headerElem.querySelectorAll("input[type=checkbox]:checked"), i = 0;
                for (len = checkboxes.length; i < len; i++) checkboxes[i].checked = !1;
            }
            return _createClass(Header, [ {
                key: "toggleNavOption",
                value: function() {
                    var body = document.getElementsByTagName("body")[0], html = document.getElementsByTagName("html")[0], i = 0, sectionOpen = -1 === this.sectionBtn.className.indexOf("close-button");
                    for (i = 0; i < this.navbtns.length; i++) Helper.removeClass(this.navbtns[i], "close-button"), 
                    Helper.removeClass(this.navwins[i], "open-window"), this.navbtns[i].setAttribute("aria-expanded", "false"), 
                    Helper.removeClass(html, "menu-open"), Helper.removeClass(body, "menu-open");
                    sectionOpen && (Helper.addClass(this.sectionBtn, "close-button"), Helper.addClass(this.sectionWin, "open-window"), 
                    this.sectionBtn.setAttribute("aria-expanded", "true"), "search" === this.section ? document.getElementById("usagov-search-query").focus() : (Helper.addClass(html, "menu-open"), 
                    Helper.addClass(body, "menu-open")));
                }
            } ]), Header;
        }();
        exports.default = Header, module.exports = exports.default;
    }, {
        "./Helper": 3
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = function() {
            function Helper() {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, Helper);
            }
            return _createClass(Helper, null, [ {
                key: "hasClass",
                value: function(el, className) {
                    return el.classList ? el.classList.contains(className) : !!el.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
                }
            }, {
                key: "addClass",
                value: function(el, className) {
                    el.classList ? el.classList.add(className) : this.hasClass(el, className) || (el.className += " " + className);
                }
            }, {
                key: "removeClass",
                value: function(el, className) {
                    if (el.classList) el.classList.remove(className); else if (this.hasClass(el, className)) {
                        var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
                        el.className = el.className.replace(reg, " ");
                    }
                }
            }, {
                key: "toggleClass",
                value: function(el, className) {
                    this.hasClass(el, className) ? this.removeClass(el, className) : this.addClass(el, className);
                }
            }, {
                key: "randomNumberToken",
                value: function() {
                    return new Date().valueOf();
                }
            } ]), Helper;
        }();
        exports.default = Helper, module.exports = exports.default;
    }, {} ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = require("./Helper"), ScrollNav = function() {
            function ScrollNav(elem, minTop) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, ScrollNav), this.navElem = elem, this.scrollPos = void 0 !== window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop, 
                this.minTop = minTop || 0, this.minScroll = 25, window.addEventListener("scroll", this.runOnScroll.bind(this)), 
                this.runOnScroll(this);
            }
            return _createClass(ScrollNav, [ {
                key: "runOnScroll",
                value: function(e) {
                    var newPos = void 0 !== window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop;
                    document.getElementsByClassName("open-window").length || (this.scrollPos + this.minScroll <= newPos && newPos > this.minTop ? (Helper.addClass(this.navElem, "scrolled-down"), 
                    this.scrollPos = newPos) : this.scrollPos - this.minScroll >= newPos && (Helper.removeClass(this.navElem, "scrolled-down"), 
                    this.scrollPos = newPos));
                }
            } ]), ScrollNav;
        }();
        exports.default = ScrollNav, module.exports = exports.default;
    }, {
        "./Helper": 3
    } ]
}, {}, [ 1 ]), require = function r(e, n, t) {
    function o(i, f) {
        if (!n[i]) {
            if (!e[i]) {
                var c = "function" == typeof require && require;
                if (!f && c) return c(i, !0);
                if (u) return u(i, !0);
                var a = new Error("Cannot find module '" + i + "'");
                throw a.code = "MODULE_NOT_FOUND", a;
            }
            var p = n[i] = {
                exports: {}
            };
            e[i][0].call(p.exports, function(r) {
                return o(e[i][1][r] || r);
            }, p, p.exports, r, e, n, t);
        }
        return n[i].exports;
    }
    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) o(t[i]);
    return o;
}({
    1: [ function(require, module, exports) {
        module.exports = [ {
            email: "tjenicek0@va.gov"
        }, {
            email: "mbleasdille1@twitter.com"
        }, {
            email: "ccomford2@icq.com"
        }, {
            email: "froby3@so-net.ne.jp"
        }, {
            email: "ahatt4@feedburner.com"
        }, {
            email: "abohje5@boston.com"
        }, {
            email: "jwilden6@homestead.com"
        }, {
            email: "hseamons7@ow.ly"
        }, {
            email: "ktregea8@ibm.com"
        }, {
            email: "tkewley9@wired.com"
        }, {
            email: "splumsteada@dot.gov"
        }, {
            email: "rwydb@cyberchimps.com"
        }, {
            email: "cmutlowc@biblegateway.com"
        }, {
            email: "wwoodroofed@constantcontact.com"
        }, {
            email: "lmohamede@unc.edu"
        }, {
            email: "scrightonf@livejournal.com"
        }, {
            email: "akintzelg@is.gd"
        }, {
            email: "jnesterovh@cam.ac.uk"
        }, {
            email: "kbarbaryi@hhs.gov"
        }, {
            email: "tdaintithj@weather.com"
        }, {
            email: "mhambrightk@tumblr.com"
        }, {
            email: "aacresl@jugem.jp"
        }, {
            email: "meatem@java.com"
        }, {
            email: "gcleverleyn@addtoany.com"
        }, {
            email: "cdettmaro@hatena.ne.jp"
        }, {
            email: "gmcgeep@census.gov"
        }, {
            email: "jtourneq@geocities.com"
        }, {
            email: "wnevisonr@de.vu"
        }, {
            email: "cduchateaus@noaa.gov"
        }, {
            email: "abirtwistlet@uol.com.br"
        }, {
            email: "samossu@google.com.hk"
        }, {
            email: "rtemperleyv@ning.com"
        }, {
            email: "breyw@statcounter.com"
        }, {
            email: "edibnerx@intel.com"
        }, {
            email: "dpethricky@hexun.com"
        }, {
            email: "mbruckmannz@vistaprint.com"
        }, {
            email: "rraggett10@istockphoto.com"
        }, {
            email: "jburnall11@bbb.org"
        }, {
            email: "nren12@geocities.com"
        }, {
            email: "gstiller13@simplemachines.org"
        }, {
            email: "ccowburn14@twitter.com"
        }, {
            email: "bwavell15@sakura.ne.jp"
        }, {
            email: "jmelonby16@va.gov"
        }, {
            email: "llabitt17@soup.io"
        }, {
            email: "aorable18@whitehouse.gov"
        }, {
            email: "vfeldberger19@hp.com"
        }, {
            email: "eprobat1a@about.com"
        }, {
            email: "bjentgens1b@list-manage.com"
        }, {
            email: "bblaydon1c@lycos.com"
        }, {
            email: "rmcnab1d@google.com.au"
        }, {
            email: "ybrahan1e@columbia.edu"
        }, {
            email: "hbolles1f@lulu.com"
        }, {
            email: "eborborough1g@myspace.com"
        }, {
            email: "dbignall1h@feedburner.com"
        }, {
            email: "vogborne1i@webmd.com"
        }, {
            email: "kdudenie1j@cnet.com"
        }, {
            email: "ainglefield1k@mtv.com"
        }, {
            email: "wbaudet1l@sfgate.com"
        }, {
            email: "alucy1m@studiopress.com"
        }, {
            email: "cklimontovich1n@xinhuanet.com"
        }, {
            email: "balen1o@hud.gov"
        }, {
            email: "sdruhan1p@pbs.org"
        }, {
            email: "fmckelloch1q@newyorker.com"
        }, {
            email: "agadson1r@photobucket.com"
        }, {
            email: "wastley1s@msn.com"
        }, {
            email: "dchristie1t@bloomberg.com"
        }, {
            email: "igostyke1u@europa.eu"
        }, {
            email: "achevalier1v@howstuffworks.com"
        }, {
            email: "uveltman1w@google.com.hk"
        }, {
            email: "keynald1x@zimbio.com"
        }, {
            email: "cgiottini1y@gov.uk"
        }, {
            email: "skeysel1z@trellian.com"
        }, {
            email: "bbasset20@angelfire.com"
        }, {
            email: "dlong21@prlog.org"
        }, {
            email: "mmoynihan22@sitemeter.com"
        }, {
            email: "jholligan23@gravatar.com"
        }, {
            email: "lmacphee24@wisc.edu"
        }, {
            email: "ealred25@hc360.com"
        }, {
            email: "lchaffer26@newyorker.com"
        }, {
            email: "crealy27@ox.ac.uk"
        }, {
            email: "jderrico28@fc2.com"
        }, {
            email: "vdavitt29@woothemes.com"
        }, {
            email: "jcubuzzi2a@yahoo.co.jp"
        }, {
            email: "lgroundwater2b@addthis.com"
        }, {
            email: "jtirrell2c@unblog.fr"
        }, {
            email: "nprantoni2d@geocities.com"
        }, {
            email: "mferraretto2e@dropbox.com"
        }, {
            email: "rscyone2f@themeforest.net"
        }, {
            email: "bwalford2g@comcast.net"
        }, {
            email: "lvedstra2h@techcrunch.com"
        }, {
            email: "snorthen2i@nbcnews.com"
        }, {
            email: "hpozer2j@arizona.edu"
        }, {
            email: "egalway2k@wikispaces.com"
        }, {
            email: "istapells2l@lycos.com"
        }, {
            email: "aeaslea2m@alexa.com"
        }, {
            email: "fellgood2n@youku.com"
        }, {
            email: "fdepka2o@omniture.com"
        }, {
            email: "rharbin2p@reddit.com"
        }, {
            email: "mvedyaev2q@virginia.edu"
        }, {
            email: "rgodfroy2r@fastcompany.com"
        } ];
    }, {} ],
    2: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = require("./Helper"), CustomSelect = function() {
            function CustomSelect(el) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, CustomSelect), this.cselect = el, this.opened = !1, this.createOverlayElement(), 
                this.createOptionsElement(), document.body.addEventListener("click", this.hideOptions.bind(this));
            }
            return _createClass(CustomSelect, [ {
                key: "toggleOptions",
                value: function() {
                    this.opened ? this.opened = !1 : this.opened = !0, Helper.toggleClass(this.cselect, "show-options");
                }
            }, {
                key: "hideOptions",
                value: function(e) {
                    this.opened && "custom-overlay" !== e.target.className && (Helper.removeClass(this.cselect, "show-options"), 
                    this.opened = !1);
                }
            }, {
                key: "createOverlayElement",
                value: function() {
                    var overlay = document.createElement("div");
                    overlay.setAttribute("class", "custom-overlay"), overlay.addEventListener("click", this.toggleOptions.bind(this)), 
                    this.cselect.appendChild(overlay);
                }
            }, {
                key: "createOptionsElement",
                value: function() {
                    var optionLi, i, evt = document.createEvent("HTMLEvents"), select = this.cselect.getElementsByTagName("select")[0], options = this.cselect.getElementsByTagName("option"), optionBox = document.createElement("div"), optionUl = document.createElement("ul");
                    for (optionBox.setAttribute("class", "custom-options"), optionBox.appendChild(optionUl), 
                    i = 0; i < options.length; i++) (optionLi = document.createElement("li")).setAttribute("data-value", options[i].value), 
                    optionLi.setAttribute("class", "custom-select-option"), optionLi.innerHTML = options[i].textContent, 
                    optionLi.addEventListener("click", function() {
                        evt.initEvent("change", !1, !0), select.value = this.getAttribute("data-value"), 
                        select.dispatchEvent(evt);
                    }), optionUl.appendChild(optionLi);
                    this.cselect.appendChild(optionBox);
                }
            } ]), CustomSelect;
        }();
        exports.default = CustomSelect, module.exports = exports.default;
    }, {
        "./Helper": "Helper"
    } ],
    3: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
        }
        var Helper = require("./Helper"), FullWidthParallax = function() {
            function FullWidthParallax(elem, topMargin) {
                _classCallCheck(this, FullWidthParallax);
                var fwi, context = this;
                fwi = (this.imgCont = elem).getElementsByClassName("full-width-image"), this.img = fwi.length ? fwi[0].getElementsByTagName("img") : [], 
                this.topVal = 0, this.longPage = !1, this.isBanner = Helper.hasClass(elem, "page-banner"), 
                this.toTop = Helper.hasClass(elem, "image-to-top"), this.centered = 0, this.img.length && (this.img = this.img[0], 
                this.scrollPos = -1, this.topMargin = topMargin || 0, window.addEventListener("scroll", function() {
                    context.runOnScroll();
                }), window.addEventListener("resize", function() {
                    context.runOnResize();
                }), this.img.addEventListener("load", function() {
                    context.runOnResize();
                }), this.runOnResize());
            }
            return _createClass(FullWidthParallax, [ {
                key: "runOnResize",
                value: function() {
                    var maxPos, absTop, minTop, de = document.documentElement;
                    this.imgH = this.img.clientHeight, this.contH = this.imgCont.clientHeight, this.centered = Math.round(this.imgH - this.contH) / -2, 
                    this.winW = Math.max(de.clientWidth, window.innerWidth || 0), this.winH = Math.max(de.clientHeight, window.innerHeight || 0), 
                    (this.toTop || !this.isBanner || 0 <= this.centered) && (this.centered = 0), 769 < this.winW && 0 < this.contH ? (maxPos = this.winH - this.contH, 
                    absTop = Math.round((this.topMargin - maxPos) / 2), minTop = this.contH - this.imgH, 
                    this.longPage = absTop < minTop, this.runOnScroll()) : this.topVal !== this.centered && 0 < this.contH && (this.img.style.top = this.centered + "px", 
                    this.topVal = this.centered);
                }
            }, {
                key: "runOnScroll",
                value: function() {
                    var pPos, minPos, percent, viewPos = this.imgCont.getBoundingClientRect(), imgContPos = this.topMargin - viewPos.top, imgTop = Math.round(imgContPos / 2), minView = this.winH - viewPos.top;
                    this.contH, this.imgH;
                    769 < this.winW && 0 < minView && imgContPos <= this.contH ? (this.longPage && !this.isBanner ? (percent = 100 * (viewPos.top - this.topMargin), 
                    imgTop = (percent /= this.winH - this.contH - this.topMargin) * (this.contH - this.imgH) / 100) : this.isBanner && (pPos = window.pageYOffset || document.documentElement.scrollTop, 
                    minPos = this.topMargin - (pPos + viewPos.top), imgTop -= Math.round(minPos / 2)), 
                    imgTop = (imgTop += this.centered) < this.centered && this.isBanner ? this.centered : imgTop, 
                    this.img.style.top = imgTop + "px", this.topVal = imgTop) : this.topVal !== this.centered && (this.img.style.top = this.centered + "px", 
                    this.topVal = this.centered);
                }
            }, {
                key: "updateParallax",
                value: function() {
                    this.runOnResize();
                }
            } ]), FullWidthParallax;
        }(), ParallaxImage = function() {
            function ParallaxImage(topMargin) {
                _classCallCheck(this, ParallaxImage);
                var i, banners = document.getElementsByClassName("parallax-image");
                for (this.parallaxes = [], i = 0; i < banners.length; i++) this.parallaxes.push(new FullWidthParallax(banners[i], topMargin));
            }
            return _createClass(ParallaxImage, [ {
                key: "runUpdate",
                value: function() {
                    var i;
                    for (i = 0; i < this.parallaxes.length; i++) this.parallaxes[i].updateParallax();
                }
            } ]), ParallaxImage;
        }();
        exports.default = ParallaxImage, module.exports = exports.default;
    }, {
        "./Helper": "Helper"
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Waypoint = require("./commonjs.waypoints.js"), Helper = require("./Helper");
        console.log("test 1 of 6 SocialBar");
        var SocialBar = function() {
            function SocialBar() {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, SocialBar);
            }
            return _createClass(SocialBar, null, [ {
                key: "initWaypoint",
                value: function(waypointElement) {
                    var socialBar = document.getElementsByClassName("social-bar")[0];
                    console.log("test 2 of 6 SocialBar"), "object" === (void 0 === waypointElement ? "undefined" : _typeof(waypointElement)) && (console.log("test 3 of 6 SocialBar"), 
                    new Waypoint({
                        element: waypointElement,
                        handler: function(direction) {
                            "up" === direction ? (Helper.removeClass(socialBar, "scrolled-down"), console.log("test 4 of 6 SocialBar")) : "down" === direction && (Helper.addClass(socialBar, "scrolled-down"), 
                            console.log("test 5 of 6 SocialBar"));
                        },
                        offset: "100%"
                    }));
                }
            } ]), SocialBar;
        }();
        console.log("test 6 of 6 SocialBar"), exports.default = SocialBar, module.exports = exports.default;
    }, {
        "./Helper": "Helper",
        "./commonjs.waypoints.js": 7
    } ],
    5: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = require("./Helper"), SubNav = function() {
            function SubNav(el, callbackFn, options) {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, SubNav);
                var i, j, mDiv, hashItem, subnavCheck, menuLink, mItems, _this = this, url = document.URL.split("#")[0], hash = window.location.hash.toLowerCase(), docElem = document.documentElement, winW = Math.max(docElem.clientWidth, window.innerWidth || 0);
                for (this.defaults = this.initDefaults(options), this.callback = callbackFn, this.subnav = el, 
                subnavCheck = this.subnav.getElementsByTagName("input"), mItems = this.subnav.querySelectorAll("ul a"), 
                this.menuItems = {}, this.menuDivs = {}, this.firstHash = "", this.currentSelect = "", 
                this.toggleLabel = this.subnav.getElementsByTagName("label"), 0 < this.toggleLabel.length ? this.toggleLabel = this.toggleLabel[0] : this.toggleLabel = document.createElement("div"), 
                this.toggleLabelDefault = this.toggleLabel.innerHTML, 0 < subnavCheck.length && "checkbox" === subnavCheck[0].type && (subnavCheck = subnavCheck[0], 
                winW <= 992 && (this.defaults.initializeOpen = !1), subnavCheck.checked = this.defaults.initializeOpen), 
                i = 0; i < mItems.length; i++) {
                    for (0 === (mDiv = "" === (menuLink = mItems[i].getAttribute("href").toLowerCase()) ? [] : document.getElementsByClassName(menuLink.substr(1))).length && mItems[i].getAttribute("data-id") ? (mDiv = document.getElementsByClassName(mItems[i].getAttribute("data-id")), 
                    menuLink = "#" + mItems[i].getAttribute("data-id")) : 0 === mDiv.length && mItems[i].id && (mDiv = document.getElementsByClassName(mItems[i].id), 
                    menuLink = "#" + mItems[i].id), menuLink === hash && hash && (hashItem = menuLink), 
                    0 === i && (this.firstHash = menuLink), this.menuItems[menuLink] = mItems[i], this.menuDivs[menuLink] = mDiv, 
                    j = 0; j < mDiv.length; j++) Helper.addClass(mDiv[j], "subnav-selectable");
                    mItems[i].onclick = function(e) {
                        var hashval = this.getAttribute("href"), page = location.pathname + location.search + hashval, linkid = this.getAttribute("data-id") ? this.getAttribute("data-id") : this.id, hashLink = "" === hashval ? "#" + linkid : hashval;
                        _this.defaults.preventDefault && e.preventDefault(), "" === hashval && (hashval = url), 
                        history.pushState && history.pushState(null, document.title, hashval), "undefined" != typeof ga && ga("send", "event", "subnav", "click", page), 
                        _this.setMenu(hashLink), subnavCheck && (subnavCheck.checked = !1);
                    };
                }
                window.addEventListener("hashchange", function(e) {
                    var i, navwins, navcls, body = document.getElementsByTagName("body")[0], html = document.getElementsByTagName("html")[0], nav = document.getElementsByTagName("header");
                    if (_this.setMenu(location.hash, !0), subnavCheck && (subnavCheck.checked = !1), 
                    Helper.removeClass(html, "menu-open"), Helper.removeClass(body, "menu-open"), nav.length) {
                        for (navcls = nav[0].getElementsByClassName("close-button"), navwins = nav[0].getElementsByClassName("open-window"), 
                        i = navcls.length - 1; 0 <= i; i--) Helper.removeClass(navcls[i], "close-button");
                        for (i = navwins.length - 1; 0 <= i; i--) Helper.removeClass(navwins[i], "open-window");
                    }
                }, !1), this.defaults.initializeEmpty ? this.setMenu("empty") : hashItem ? this.setMenu(hashItem) : this.setMenu(this.firstHash);
            }
            return _createClass(SubNav, [ {
                key: "initDefaults",
                value: function(options) {
                    var key, defaults = {
                        preventDefault: !0,
                        persistentLabel: !1,
                        initializeEmpty: !1,
                        initializeOpen: !1
                    };
                    for (key in options) defaults.hasOwnProperty(key) && (defaults[key] = options[key]);
                    return defaults;
                }
            }, {
                key: "setMenu",
                value: function(hashIndex, toTop) {
                    var i, active, selected;
                    if ((this.menuItems[hashIndex] || "empty" === hashIndex) && this.currentSelect !== hashIndex) {
                        for (active = this.subnav.getElementsByClassName("active"), selected = document.getElementsByClassName("subnav-selected"), 
                        i = active.length - 1; 0 <= i; i--) Helper.removeClass(active[i], "active");
                        for (i = selected.length - 1; 0 <= i; i--) Helper.removeClass(selected[i], "subnav-selected");
                        "empty" !== hashIndex && (Helper.addClass(this.menuItems[hashIndex], "active"), 
                        this.menuDivs[hashIndex] ? (this.defaults.persistentLabel || (this.toggleLabel.innerHTML = this.menuItems[hashIndex].innerHTML), 
                        this.showMenuDiv(this.menuDivs[hashIndex], !0), toTop && window.scrollTo(0, 0)) : this.toggleLabel.innerHTML = this.toggleLabelDefault, 
                        "function" == typeof this.callback && this.callback(this.menuItems[hashIndex])), 
                        this.currentSelect = hashIndex;
                    }
                }
            }, {
                key: "showMenuDiv",
                value: function(divs, add) {
                    var i;
                    for (i = divs.length - 1; 0 <= i; i--) !0 === add ? Helper.addClass(divs[i], "subnav-selected") : Helper.removeClass(divs[i], "subnav-selected");
                }
            } ]), SubNav;
        }();
        exports.default = SubNav, module.exports = exports.default;
    }, {
        "./Helper": "Helper"
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = require("./Helper"), Validity = function() {
            function Validity(form) {
                var submit = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "", normalSubmit = 2 < arguments.length && void 0 !== arguments[2] && arguments[2];
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, Validity);
                var len, i = 0, $this = this;
                for ($this.validationFn = "function" == typeof form.checkValidity ? function(el) {
                    return el.checkValidity();
                } : function(el) {
                    return $this.isValid(el);
                }, i = 0, len = form.elements.length; i < len; i++) $this.validateOnBlur(form.elements[i]);
                form.validate = function() {
                    var len, j = 0, invalid = 0;
                    for (j = 0, len = this.elements.length; j < len; j++) $this.markField($this.validationFn(this.elements[j]), this.elements[j]) || invalid++;
                    return !(0 < invalid) && (!normalSubmit || void this.submit());
                }, form.onsubmit = submit || function() {
                    if (!this.validate()) return !1;
                };
            }
            return _createClass(Validity, [ {
                key: "validateOnBlur",
                value: function(el) {
                    var $this = this;
                    "checkbox" === el.getAttribute("type") ? el.addEventListener("click", function() {
                        $this.markField($this.validationFn(this), this);
                    }, !1) : el.addEventListener("blur", function() {
                        Helper.hasClass(this, "no-validate") || $this.markField($this.validationFn(this), this);
                    }, !1);
                }
            }, {
                key: "markField",
                value: function(valid, el) {
                    return valid ? (Helper.hasClass(el, "invalid") && Helper.removeClass(el, "invalid"), 
                    !0) : (el.setCustomValidity(""), Helper.addClass(el, "invalid"), !1);
                }
            }, {
                key: "isValid",
                value: function(el) {
                    return "email" === el.getAttribute("type") ? !this.isEmpty(el) && this.validateEmail(el) && !this.isPlaceholder(el) : "tel" === el.getAttribute("type") ? !this.isEmpty(el) && this.validatePhone(el) && !this.isPlaceholder(el) : "url" === el.getAttribute("type") ? !this.isEmpty(el) && this.validateUrl(el) && !this.isPlaceholder(el) : "checkbox" === el.getAttribute("type") ? this.validateCheckbox(el) : !this.isEmpty(el) && !this.isPlaceholder(el);
                }
            }, {
                key: "validateEmail",
                value: function(el) {
                    return /^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]{2,6})$/.test(el.value);
                }
            }, {
                key: "validatePhone",
                value: function(el) {
                    return /^(?:\(\d{3}\)|\d{3})[- ]?\d{3}[- ]?\d{4}$/.test(el.value);
                }
            }, {
                key: "validateUrl",
                value: function(el) {
                    return /^(https?:\/\/)?(\w+(-\w+)*\.){2,}[a-z]{2,}(:[0-9]+)?(\/[\w\-]+)*(\/([\w\-\x40$\.\x2B!*\x27(),]|(%[A-Z0-9]{2}))+)?((\.[a-z]{2,})|\/)?((\?[\w\-]+=([\w\-\x40$\.\x2B!*\x27(),]|(%[A-Z0-9]{2}))+)(\x26[\w\-]+=([\w\-\x40$\.\x2B!*\x27(),]|(%[A-Z0-9]{2}))+)*)?(#([\w\-\x40$\.\x2B!*\x27(),]|(%[A-Z0-9]{2}))+)?$/gi.test(el.value);
                }
            }, {
                key: "validateCheckbox",
                value: function(el) {
                    return el.checked;
                }
            }, {
                key: "isEmpty",
                value: function(el) {
                    return 0 === el.value.length || !el.value.trim();
                }
            }, {
                key: "isPlaceholder",
                value: function(el) {
                    return el.getAttribute("placeholder") && el.value === el.getAttribute("placeholder");
                }
            } ]), Validity;
        }();
        exports.default = Validity, module.exports = exports.default;
    }, {
        "./Helper": "Helper"
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
            return typeof obj;
        } : function(obj) {
            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, keyCounter = 0, allWaypoints = {};
        function Waypoint(options) {
            if (!options) throw new Error("No options passed to Waypoint constructor");
            if (!options.element) throw new Error("No element option passed to Waypoint constructor");
            if (!options.handler) throw new Error("No handler option passed to Waypoint constructor");
            this.key = "waypoint-" + keyCounter, this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options), 
            this.element = this.options.element, this.adapter = new Waypoint.Adapter(this.element), 
            this.callback = options.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", 
            this.enabled = this.options.enabled, this.triggerPoint = null, this.group = Waypoint.Group.findOrCreate({
                name: this.options.group,
                axis: this.axis
            }), this.context = Waypoint.Context.findOrCreateByElement(this.options.context), 
            Waypoint.offsetAliases[this.options.offset] && (this.options.offset = Waypoint.offsetAliases[this.options.offset]), 
            this.group.add(this), this.context.add(this), allWaypoints[this.key] = this, keyCounter += 1;
        }
        function requestAnimationFrameShim(callback) {
            window.setTimeout(callback, 1e3 / 60);
        }
        Waypoint.prototype.queueTrigger = function(direction) {
            this.group.queueTrigger(this, direction);
        }, Waypoint.prototype.trigger = function(args) {
            this.enabled && this.callback && this.callback.apply(this, args);
        }, Waypoint.prototype.destroy = function() {
            this.context.remove(this), this.group.remove(this), delete allWaypoints[this.key];
        }, Waypoint.prototype.disable = function() {
            return this.enabled = !1, this;
        }, Waypoint.prototype.enable = function() {
            return this.context.refresh(), this.enabled = !0, this;
        }, Waypoint.prototype.next = function() {
            return this.group.next(this);
        }, Waypoint.prototype.previous = function() {
            return this.group.previous(this);
        }, Waypoint.invokeAll = function(method) {
            var allWaypointsArray = [];
            for (var waypointKey in allWaypoints) allWaypointsArray.push(allWaypoints[waypointKey]);
            for (var i = 0, end = allWaypointsArray.length; i < end; i++) allWaypointsArray[i][method]();
        }, Waypoint.destroyAll = function() {
            Waypoint.invokeAll("destroy");
        }, Waypoint.disableAll = function() {
            Waypoint.invokeAll("disable");
        }, Waypoint.enableAll = function() {
            Waypoint.invokeAll("enable");
        }, Waypoint.refreshAll = function() {
            Waypoint.Context.refreshAll();
        }, Waypoint.viewportHeight = function() {
            return window.innerHeight || document.documentElement.clientHeight;
        }, Waypoint.viewportWidth = function() {
            return document.documentElement.clientWidth;
        }, Waypoint.adapters = [], Waypoint.defaults = {
            context: window,
            continuous: !0,
            enabled: !0,
            group: "default",
            horizontal: !1,
            offset: 0
        }, Waypoint.offsetAliases = {
            "bottom-in-view": function() {
                return this.context.innerHeight() - this.adapter.outerHeight();
            },
            "right-in-view": function() {
                return this.context.innerWidth() - this.adapter.outerWidth();
            }
        }, window.Waypoint = Waypoint;
        keyCounter = 0;
        var contexts = {}, oldWindowLoad = (Waypoint = window.Waypoint, window.onload);
        function Context(element) {
            this.element = element, this.Adapter = Waypoint.Adapter, this.adapter = new this.Adapter(element), 
            this.key = "waypoint-context-" + keyCounter, this.didScroll = !1, this.didResize = !1, 
            this.oldScroll = {
                x: this.adapter.scrollLeft(),
                y: this.adapter.scrollTop()
            }, this.waypoints = {
                vertical: {},
                horizontal: {}
            }, element.waypointContextKey = this.key, contexts[element.waypointContextKey] = this, 
            keyCounter += 1, this.createThrottledScrollHandler(), this.createThrottledResizeHandler();
        }
        function byTriggerPoint(a, b) {
            return a.triggerPoint - b.triggerPoint;
        }
        function byReverseTriggerPoint(a, b) {
            return b.triggerPoint - a.triggerPoint;
        }
        Context.prototype.add = function(waypoint) {
            var axis = waypoint.options.horizontal ? "horizontal" : "vertical";
            this.waypoints[axis][waypoint.key] = waypoint, this.refresh();
        }, Context.prototype.checkEmpty = function() {
            var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal), verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical);
            horizontalEmpty && verticalEmpty && (this.adapter.off(".waypoints"), delete contexts[this.key]);
        }, Context.prototype.createThrottledResizeHandler = function() {
            var self = this;
            function resizeHandler() {
                self.handleResize(), self.didResize = !1;
            }
            this.adapter.on("resize.waypoints", function() {
                self.didResize || (self.didResize = !0, Waypoint.requestAnimationFrame(resizeHandler));
            });
        }, Context.prototype.createThrottledScrollHandler = function() {
            var self = this;
            function scrollHandler() {
                self.handleScroll(), self.didScroll = !1;
            }
            this.adapter.on("scroll.waypoints", function() {
                self.didScroll && !Waypoint.isTouch || (self.didScroll = !0, Waypoint.requestAnimationFrame(scrollHandler));
            });
        }, Context.prototype.handleResize = function() {
            Waypoint.Context.refreshAll();
        }, Context.prototype.handleScroll = function() {
            var triggeredGroups = {}, axes = {
                horizontal: {
                    newScroll: this.adapter.scrollLeft(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left"
                },
                vertical: {
                    newScroll: this.adapter.scrollTop(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up"
                }
            };
            for (var axisKey in axes) {
                var axis = axes[axisKey], direction = axis.newScroll > axis.oldScroll ? axis.forward : axis.backward;
                for (var waypointKey in this.waypoints[axisKey]) {
                    var waypoint = this.waypoints[axisKey][waypointKey], wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint, nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint;
                    (wasBeforeTriggerPoint && nowAfterTriggerPoint || !wasBeforeTriggerPoint && !nowAfterTriggerPoint) && (waypoint.queueTrigger(direction), 
                    triggeredGroups[waypoint.group.id] = waypoint.group);
                }
            }
            for (var groupKey in triggeredGroups) triggeredGroups[groupKey].flushTriggers();
            this.oldScroll = {
                x: axes.horizontal.newScroll,
                y: axes.vertical.newScroll
            };
        }, Context.prototype.innerHeight = function() {
            return this.element == this.element.window ? Waypoint.viewportHeight() : this.adapter.innerHeight();
        }, Context.prototype.remove = function(waypoint) {
            delete this.waypoints[waypoint.axis][waypoint.key], this.checkEmpty();
        }, Context.prototype.innerWidth = function() {
            return this.element == this.element.window ? Waypoint.viewportWidth() : this.adapter.innerWidth();
        }, Context.prototype.destroy = function() {
            var allWaypoints = [];
            for (var axis in this.waypoints) for (var waypointKey in this.waypoints[axis]) allWaypoints.push(this.waypoints[axis][waypointKey]);
            for (var i = 0, end = allWaypoints.length; i < end; i++) allWaypoints[i].destroy();
        }, Context.prototype.refresh = function() {
            var axes, isWindow = this.element == this.element.window, contextOffset = this.adapter.offset(), triggeredGroups = {};
            for (var axisKey in this.handleScroll(), axes = {
                horizontal: {
                    contextOffset: isWindow ? 0 : contextOffset.left,
                    contextScroll: isWindow ? 0 : this.oldScroll.x,
                    contextDimension: this.innerWidth(),
                    oldScroll: this.oldScroll.x,
                    forward: "right",
                    backward: "left",
                    offsetProp: "left"
                },
                vertical: {
                    contextOffset: isWindow ? 0 : contextOffset.top,
                    contextScroll: isWindow ? 0 : this.oldScroll.y,
                    contextDimension: this.innerHeight(),
                    oldScroll: this.oldScroll.y,
                    forward: "down",
                    backward: "up",
                    offsetProp: "top"
                }
            }) {
                var axis = axes[axisKey];
                for (var waypointKey in this.waypoints[axisKey]) {
                    var contextModifier, wasBeforeScroll, nowAfterScroll, triggeredForward, waypoint = this.waypoints[axisKey][waypointKey], adjustment = waypoint.options.offset, oldTriggerPoint = waypoint.triggerPoint, elementOffset = 0, freshWaypoint = null == oldTriggerPoint;
                    waypoint.element !== waypoint.element.window && (elementOffset = waypoint.adapter.offset()[axis.offsetProp]), 
                    "function" == typeof adjustment ? adjustment = adjustment.apply(waypoint) : "string" == typeof adjustment && (adjustment = parseFloat(adjustment), 
                    -1 < waypoint.options.offset.indexOf("%") && (adjustment = Math.ceil(axis.contextDimension * adjustment / 100))), 
                    contextModifier = axis.contextScroll - axis.contextOffset, waypoint.triggerPoint = elementOffset + contextModifier - adjustment, 
                    wasBeforeScroll = oldTriggerPoint < axis.oldScroll, nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll, 
                    triggeredForward = !wasBeforeScroll && !nowAfterScroll, !freshWaypoint && (wasBeforeScroll && nowAfterScroll) ? (waypoint.queueTrigger(axis.backward), 
                    triggeredGroups[waypoint.group.id] = waypoint.group) : !freshWaypoint && triggeredForward ? (waypoint.queueTrigger(axis.forward), 
                    triggeredGroups[waypoint.group.id] = waypoint.group) : freshWaypoint && axis.oldScroll >= waypoint.triggerPoint && (waypoint.queueTrigger(axis.forward), 
                    triggeredGroups[waypoint.group.id] = waypoint.group);
                }
            }
            for (var groupKey in triggeredGroups) triggeredGroups[groupKey].flushTriggers();
            return this;
        }, Context.findOrCreateByElement = function(element) {
            return Context.findByElement(element) || new Context(element);
        }, Context.refreshAll = function() {
            for (var contextId in contexts) contexts[contextId].refresh();
        }, Context.findByElement = function(element) {
            return contexts[element.waypointContextKey];
        }, window.onload = function() {
            oldWindowLoad && oldWindowLoad(), Context.refreshAll();
        }, Waypoint.requestAnimationFrame = function(callback) {
            (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim).call(window, callback);
        }, Waypoint.Context = Context;
        var groups = {
            vertical: {},
            horizontal: {}
        };
        Waypoint = window.Waypoint;
        function Group(options) {
            this.name = options.name, this.axis = options.axis, this.id = this.name + "-" + this.axis, 
            this.waypoints = [], this.clearTriggerQueues(), groups[this.axis][this.name] = this;
        }
        Group.prototype.add = function(waypoint) {
            this.waypoints.push(waypoint);
        }, Group.prototype.clearTriggerQueues = function() {
            this.triggerQueues = {
                up: [],
                down: [],
                left: [],
                right: []
            };
        }, Group.prototype.flushTriggers = function() {
            for (var direction in this.triggerQueues) {
                var waypoints = this.triggerQueues[direction], reverse = "up" === direction || "left" === direction;
                waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint);
                for (var i = 0, end = waypoints.length; i < end; i += 1) {
                    var waypoint = waypoints[i];
                    (waypoint.options.continuous || i === waypoints.length - 1) && waypoint.trigger([ direction ]);
                }
            }
            this.clearTriggerQueues();
        }, Group.prototype.next = function(waypoint) {
            this.waypoints.sort(byTriggerPoint);
            var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
            return index === this.waypoints.length - 1 ? null : this.waypoints[index + 1];
        }, Group.prototype.previous = function(waypoint) {
            this.waypoints.sort(byTriggerPoint);
            var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
            return index ? this.waypoints[index - 1] : null;
        }, Group.prototype.queueTrigger = function(waypoint, direction) {
            this.triggerQueues[direction].push(waypoint);
        }, Group.prototype.remove = function(waypoint) {
            var index = Waypoint.Adapter.inArray(waypoint, this.waypoints);
            -1 < index && this.waypoints.splice(index, 1);
        }, Group.prototype.first = function() {
            return this.waypoints[0];
        }, Group.prototype.last = function() {
            return this.waypoints[this.waypoints.length - 1];
        }, Group.findOrCreate = function(options) {
            return groups[options.axis][options.name] || new Group(options);
        }, Waypoint.Group = Group;
        var Waypoint = window.Waypoint;
        function isWindow(element) {
            return element === element.window;
        }
        function getWindow(element) {
            return isWindow(element) ? element : element.defaultView;
        }
        function NoFrameworkAdapter(element) {
            this.element = element, this.handlers = {};
        }
        NoFrameworkAdapter.prototype.innerHeight = function() {
            return isWindow(this.element) ? this.element.innerHeight : this.element.clientHeight;
        }, NoFrameworkAdapter.prototype.innerWidth = function() {
            return isWindow(this.element) ? this.element.innerWidth : this.element.clientWidth;
        }, NoFrameworkAdapter.prototype.off = function(event, handler) {
            function removeListeners(element, listeners, handler) {
                for (var i = 0, end = listeners.length - 1; i < end; i++) {
                    var listener = listeners[i];
                    handler && handler !== listener || element.removeEventListener(listener);
                }
            }
            var eventParts = event.split("."), eventType = eventParts[0], namespace = eventParts[1], element = this.element;
            if (namespace && this.handlers[namespace] && eventType) removeListeners(element, this.handlers[namespace][eventType], handler), 
            this.handlers[namespace][eventType] = []; else if (eventType) for (var ns in this.handlers) removeListeners(element, this.handlers[ns][eventType] || [], handler), 
            this.handlers[ns][eventType] = []; else if (namespace && this.handlers[namespace]) {
                for (var type in this.handlers[namespace]) removeListeners(element, this.handlers[namespace][type], handler);
                this.handlers[namespace] = {};
            }
        }, NoFrameworkAdapter.prototype.offset = function() {
            if (!this.element.ownerDocument) return null;
            var documentElement = this.element.ownerDocument.documentElement, win = getWindow(this.element.ownerDocument), rect = {
                top: 0,
                left: 0
            };
            return this.element.getBoundingClientRect && (rect = this.element.getBoundingClientRect()), 
            {
                top: rect.top + win.pageYOffset - documentElement.clientTop,
                left: rect.left + win.pageXOffset - documentElement.clientLeft
            };
        }, NoFrameworkAdapter.prototype.on = function(event, handler) {
            var eventParts = event.split("."), eventType = eventParts[0], namespace = eventParts[1] || "__default", nsHandlers = this.handlers[namespace] = this.handlers[namespace] || {};
            (nsHandlers[eventType] = nsHandlers[eventType] || []).push(handler), this.element.addEventListener(eventType, handler);
        }, NoFrameworkAdapter.prototype.outerHeight = function(includeMargin) {
            var computedStyle, height = this.innerHeight();
            return includeMargin && !isWindow(this.element) && (computedStyle = window.getComputedStyle(this.element), 
            height += parseInt(computedStyle.marginTop, 10), height += parseInt(computedStyle.marginBottom, 10)), 
            height;
        }, NoFrameworkAdapter.prototype.outerWidth = function(includeMargin) {
            var computedStyle, width = this.innerWidth();
            return includeMargin && !isWindow(this.element) && (computedStyle = window.getComputedStyle(this.element), 
            width += parseInt(computedStyle.marginLeft, 10), width += parseInt(computedStyle.marginRight, 10)), 
            width;
        }, NoFrameworkAdapter.prototype.scrollLeft = function() {
            var win = getWindow(this.element);
            return win ? win.pageXOffset : this.element.scrollLeft;
        }, NoFrameworkAdapter.prototype.scrollTop = function() {
            var win = getWindow(this.element);
            return win ? win.pageYOffset : this.element.scrollTop;
        }, NoFrameworkAdapter.extend = function() {
            var args = Array.prototype.slice.call(arguments);
            function merge(target, obj) {
                if ("object" === (void 0 === target ? "undefined" : _typeof(target)) && "object" === (void 0 === obj ? "undefined" : _typeof(obj))) for (var key in obj) obj.hasOwnProperty(key) && (target[key] = obj[key]);
                return target;
            }
            for (var i = 1, end = args.length; i < end; i++) merge(args[0], args[i]);
            return args[0];
        }, NoFrameworkAdapter.inArray = function(element, array, i) {
            return null == array ? -1 : array.indexOf(element, i);
        }, NoFrameworkAdapter.isEmptyObject = function(obj) {
            for (var name in obj) return !1;
            return !0;
        }, Waypoint.adapters.push({
            name: "noframework",
            Adapter: NoFrameworkAdapter
        }), Waypoint.Adapter = NoFrameworkAdapter, module.exports = Waypoint;
    }, {} ],
    8: [ function(require, module, exports) {}, {} ],
    9: [ function(require, module, exports) {
        "use strict";
        var items, title, date, link, categories, category, categoryLink, newsItem, months, validCategories, tag, flipCard, pubDate1, pubDate2, header, customSelect, form, newsList, flipButtons, CustomSelect = require("./globals/modules/CustomSelect"), Validity = (require("./globals/modules/ParallaxImage"), 
        require("./globals/modules/SubNav"), require("./globals/modules/Validity"));
        require("./side-nav");
        (header = document.getElementsByClassName("navbar")).length && header[0].clientHeight, 
        customSelect = document.getElementsByClassName("custom-select"), form = document.getElementById("sm-account-form"), 
        newsList = $(".news-list"), flipButtons = $(".flip-btn"), form && new Validity(document.forms["sm-account-form"], "", !1), 
        0 < customSelect.length && new CustomSelect(customSelect[0]), 0 < newsList.length && (months = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], 
        validCategories = [ "content", "metrics", "socialmedia" ], $.ajax({
            url: "https://api.army.mil/api/v1/digital/feed",
            dataType: "xml",
            success: function(data) {
                items = (items = (items = $(data).find("item").filter(function(index, item) {
                    return !0;
                })).slice(0, 3)).sort(function(a, b) {
                    return pubDate1 = $(a).find("pubDate").text(), pubDate2 = $(b).find("pubDate").text(), 
                    new Date(pubDate2) - new Date(pubDate1);
                }), $(".empty").remove(), $.each(items, function() {
                    title = $(this).find("title").text(), date = $(this).find("pubDate").text(), $(this).find("description").text(), 
                    link = $(this).find("link").text(), categories = $(this).find("category"), newsItem = "", 
                    newsItem += '<div class="news-item">', newsItem += '<div class="news-inner">', newsItem += '<div class="news-right">', 
                    newsItem += '<div class="main-content">', date = new Date(date), date = months[date.getMonth()] + " " + date.getDate() + ", " + date.getFullYear(), 
                    newsItem += '<p class="date">' + date + "</p>", newsItem += '<p class="sections">', 
                    categories = _.uniq(categories, function(a) {
                        return $(a).text().toLowerCase();
                    }), $.each(categories, function() {
                        category = (category = $(this).text().toLowerCase()).trim().replace(" ", ""), tag = "", 
                        -1 < validCategories.indexOf(category) && (categoryLink = category.trim().replace(" ", ""), 
                        "socialmedia" === category && (category = "Social Media"), tag = '<a href="https://www.digitalgov.gov/category/' + categoryLink + '">' + category + "</a>"), 
                        newsItem += tag;
                    }), newsItem += "</p>", newsItem += '<p class="title"><a title="' + title + '" href="' + link + '">' + title + "</a></p>", 
                    newsItem += "</div>", newsItem += '<p class="more"><a title="' + title + '" href="' + link + '">READ MORE</a></p>', 
                    newsItem += "</div>", newsItem += "</div>", newsItem += "</div>", newsList.append(newsItem);
                });
            }
        })), 0 < flipButtons.length && $(flipButtons).each(function(index) {
            $(this).on("click", function() {
                flipCard = $(this).parent().parent().parent(), $(flipCard).hasClass("applyflip") ? $(flipCard).removeClass("applyflip") : $(flipCard).addClass("applyflip");
            });
        });
    }, {
        "./globals/modules/CustomSelect": 2,
        "./globals/modules/ParallaxImage": 3,
        "./globals/modules/SubNav": 5,
        "./globals/modules/Validity": 6,
        "./side-nav": 8
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        var Helper = require("./globals/modules/Helper"), Client = require("node-rest-client").Client;
        require("../_data/email-dummy-data/emails.json");
        !function() {
            var i, subscribeLink = document.getElementsByClassName("sub-link");
            for (i = 0; i < subscribeLink.length; i++) subscribeLink[i].setAttribute("data-email", i), 
            subscribeLink[i].onclick = function() {
                var unsub = "unsubscribe" === this.value.toLowerCase();
                getEmailValue(this.getAttribute("data-email"), unsub);
            };
            function getEmailValue(index, unsub) {
                var emailInput = document.getElementsByClassName("email-input").value;
                emailInput.length > index && (setResultText(index, "..."), function(index, emailAdd, unsub) {
                    new Client();
                    if ("" === emailAdd) setResultText(index, "Please enter a valid email."); else for (var i = 0; i < JSON.length; ++i) {
                        var animal = JSON[i];
                        if ("dog" == animal.Email) {
                            !0;
                            break;
                        }
                    }
                }(index, emailInput[index].value)), alert(emailInput);
            }
            function setResultText(index, result, good) {
                var i, subResults = document.getElementsByClassName("sub-results");
                for (i = 0; i < subResults.length; i++) index ? i == index && (subResults[i].innerHTML = result, 
                good ? Helper.addClass(subResults[i], "good") : Helper.removeClass(subResults[i], "good")) : (subResults[i].innerHTML = results, 
                Helper.removeClass(subResults[i], "good"));
            }
        }();
    }, {
        "../_data/email-dummy-data/emails.json": 1,
        "./globals/modules/Helper": "Helper",
        "node-rest-client": 49
    } ],
    11: [ function(require, module, exports) {}, {} ],
    12: [ function(require, module, exports) {
        (function(Buffer) {
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            exports.isArray = function(arg) {
                return Array.isArray ? Array.isArray(arg) : "[object Array]" === objectToString(arg);
            }, exports.isBoolean = function(arg) {
                return "boolean" == typeof arg;
            }, exports.isNull = function(arg) {
                return null === arg;
            }, exports.isNullOrUndefined = function(arg) {
                return null == arg;
            }, exports.isNumber = function(arg) {
                return "number" == typeof arg;
            }, exports.isString = function(arg) {
                return "string" == typeof arg;
            }, exports.isSymbol = function(arg) {
                return "symbol" == typeof arg;
            }, exports.isUndefined = function(arg) {
                return void 0 === arg;
            }, exports.isRegExp = function(re) {
                return "[object RegExp]" === objectToString(re);
            }, exports.isObject = function(arg) {
                return "object" == typeof arg && null !== arg;
            }, exports.isDate = function(d) {
                return "[object Date]" === objectToString(d);
            }, exports.isError = function(e) {
                return "[object Error]" === objectToString(e) || e instanceof Error;
            }, exports.isFunction = function(arg) {
                return "function" == typeof arg;
            }, exports.isPrimitive = function(arg) {
                return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || void 0 === arg;
            }, exports.isBuffer = Buffer.isBuffer;
        }).call(this, {
            isBuffer: require("../../is-buffer/index.js")
        });
    }, {
        "../../is-buffer/index.js": 47
    } ],
    13: [ function(require, module, exports) {
        var url = require("url"), URL = url.URL, http = require("http"), https = require("https"), assert = require("assert"), Writable = require("stream").Writable, debug = require("debug")("follow-redirects"), SAFE_METHODS = {
            GET: !0,
            HEAD: !0,
            OPTIONS: !0,
            TRACE: !0
        }, eventHandlers = Object.create(null);
        function RedirectableRequest(options, responseCallback) {
            Writable.call(this), options.headers = options.headers || {}, this._options = options, 
            this._ended = !1, this._ending = !1, this._redirectCount = 0, this._redirects = [], 
            this._requestBodyLength = 0, this._requestBodyBuffers = [], options.host && (options.hostname || (options.hostname = options.host), 
            delete options.host), responseCallback && this.on("response", responseCallback);
            var self = this;
            if (this._onNativeResponse = function(response) {
                self._processResponse(response);
            }, !options.pathname && options.path) {
                var searchPos = options.path.indexOf("?");
                searchPos < 0 ? options.pathname = options.path : (options.pathname = options.path.substring(0, searchPos), 
                options.search = options.path.substring(searchPos));
            }
            this._performRequest();
        }
        function startTimer(request, msecs) {
            clearTimeout(request._timeout), request._timeout = setTimeout(function() {
                request.emit("timeout");
            }, msecs);
        }
        function clearTimer() {
            clearTimeout(this._timeout);
        }
        function wrap(protocols) {
            var exports = {
                maxRedirects: 21,
                maxBodyLength: 10485760
            }, nativeProtocols = {};
            return Object.keys(protocols).forEach(function(scheme) {
                var protocol = scheme + ":", nativeProtocol = nativeProtocols[protocol] = protocols[scheme], wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
                wrappedProtocol.request = function(input, options, callback) {
                    if ("string" == typeof input) {
                        var urlStr = input;
                        try {
                            input = urlToOptions(new URL(urlStr));
                        } catch (err) {
                            input = url.parse(urlStr);
                        }
                    } else URL && input instanceof URL ? input = urlToOptions(input) : (callback = options, 
                    options = input, input = {
                        protocol: protocol
                    });
                    return "function" == typeof options && (callback = options, options = null), (options = Object.assign({
                        maxRedirects: exports.maxRedirects,
                        maxBodyLength: exports.maxBodyLength
                    }, input, options)).nativeProtocols = nativeProtocols, assert.equal(options.protocol, protocol, "protocol mismatch"), 
                    debug("options", options), new RedirectableRequest(options, callback);
                }, wrappedProtocol.get = function(input, options, callback) {
                    var request = wrappedProtocol.request(input, options, callback);
                    return request.end(), request;
                };
            }), exports;
        }
        function noop() {}
        function urlToOptions(urlObject) {
            var options = {
                protocol: urlObject.protocol,
                hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
                hash: urlObject.hash,
                search: urlObject.search,
                pathname: urlObject.pathname,
                path: urlObject.pathname + urlObject.search,
                href: urlObject.href
            };
            return "" !== urlObject.port && (options.port = Number(urlObject.port)), options;
        }
        [ "abort", "aborted", "error", "socket", "timeout" ].forEach(function(event) {
            eventHandlers[event] = function(arg) {
                this._redirectable.emit(event, arg);
            };
        }), (RedirectableRequest.prototype = Object.create(Writable.prototype)).write = function(data, encoding, callback) {
            if (this._ending) throw new Error("write after end");
            if (!("string" == typeof data || "object" == typeof data && "length" in data)) throw new Error("data should be a string, Buffer or Uint8Array");
            "function" == typeof encoding && (callback = encoding, encoding = null), 0 !== data.length ? this._requestBodyLength + data.length <= this._options.maxBodyLength ? (this._requestBodyLength += data.length, 
            this._requestBodyBuffers.push({
                data: data,
                encoding: encoding
            }), this._currentRequest.write(data, encoding, callback)) : (this.emit("error", new Error("Request body larger than maxBodyLength limit")), 
            this.abort()) : callback && callback();
        }, RedirectableRequest.prototype.end = function(data, encoding, callback) {
            if ("function" == typeof data ? (callback = data, data = encoding = null) : "function" == typeof encoding && (callback = encoding, 
            encoding = null), data) {
                var self = this, currentRequest = this._currentRequest;
                this.write(data, encoding, function() {
                    self._ended = !0, currentRequest.end(null, null, callback);
                }), this._ending = !0;
            } else this._ended = this._ending = !0, this._currentRequest.end(null, null, callback);
        }, RedirectableRequest.prototype.setHeader = function(name, value) {
            this._options.headers[name] = value, this._currentRequest.setHeader(name, value);
        }, RedirectableRequest.prototype.removeHeader = function(name) {
            delete this._options.headers[name], this._currentRequest.removeHeader(name);
        }, RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
            if (callback && this.once("timeout", callback), this.socket) startTimer(this, msecs); else {
                var self = this;
                this._currentRequest.once("socket", function() {
                    startTimer(self, msecs);
                });
            }
            return this.once("response", clearTimer), this.once("error", clearTimer), this;
        }, [ "abort", "flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive" ].forEach(function(method) {
            RedirectableRequest.prototype[method] = function(a, b) {
                return this._currentRequest[method](a, b);
            };
        }), [ "aborted", "connection", "socket" ].forEach(function(property) {
            Object.defineProperty(RedirectableRequest.prototype, property, {
                get: function() {
                    return this._currentRequest[property];
                }
            });
        }), RedirectableRequest.prototype._performRequest = function() {
            var protocol = this._options.protocol, nativeProtocol = this._options.nativeProtocols[protocol];
            if (nativeProtocol) {
                if (this._options.agents) {
                    var scheme = protocol.substr(0, protocol.length - 1);
                    this._options.agent = this._options.agents[scheme];
                }
                var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
                for (var event in this._currentUrl = url.format(this._options), request._redirectable = this, 
                eventHandlers) event && request.on(event, eventHandlers[event]);
                if (this._isRedirect) {
                    var i = 0, self = this, buffers = this._requestBodyBuffers;
                    !function writeNext(error) {
                        if (request === self._currentRequest) if (error) self.emit("error", error); else if (i < buffers.length) {
                            var buffer = buffers[i++];
                            request.finished || request.write(buffer.data, buffer.encoding, writeNext);
                        } else self._ended && request.end();
                    }();
                }
            } else this.emit("error", new Error("Unsupported protocol " + protocol));
        }, RedirectableRequest.prototype._processResponse = function(response) {
            this._options.trackRedirects && this._redirects.push({
                url: this._currentUrl,
                headers: response.headers,
                statusCode: response.statusCode
            });
            var location = response.headers.location;
            if (location && !1 !== this._options.followRedirects && 300 <= response.statusCode && response.statusCode < 400) {
                if (this._currentRequest.removeAllListeners(), this._currentRequest.on("error", noop), 
                this._currentRequest.abort(), ++this._redirectCount > this._options.maxRedirects) return void this.emit("error", new Error("Max redirects exceeded."));
                var header, headers = this._options.headers;
                if (307 !== response.statusCode && !(this._options.method in SAFE_METHODS)) for (header in this._options.method = "GET", 
                this._requestBodyBuffers = [], headers) /^content-/i.test(header) && delete headers[header];
                if (!this._isRedirect) for (header in headers) /^host$/i.test(header) && delete headers[header];
                var redirectUrl = url.resolve(this._currentUrl, location);
                debug("redirecting to", redirectUrl), Object.assign(this._options, url.parse(redirectUrl)), 
                this._isRedirect = !0, this._performRequest(), response.destroy();
            } else response.responseUrl = this._currentUrl, response.redirects = this._redirects, 
            this.emit("response", response), this._requestBodyBuffers = [];
        }, module.exports = wrap({
            http: http,
            https: https
        }), module.exports.wrap = wrap;
    }, {
        assert: 17,
        debug: 14,
        http: 39,
        https: 27,
        stream: 76,
        url: 43
    } ],
    14: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            function _typeof(obj) {
                return (_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                })(obj);
            }
            exports.log = function() {
                var _console;
                return "object" === ("undefined" == typeof console ? "undefined" : _typeof(console)) && console.log && (_console = console).log.apply(_console, arguments);
            }, exports.formatArgs = function(args) {
                if (args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff), 
                !this.useColors) return;
                var c = "color: " + this.color;
                args.splice(1, 0, c, "color: inherit");
                var index = 0, lastC = 0;
                args[0].replace(/%[a-zA-Z%]/g, function(match) {
                    "%%" !== match && (index++, "%c" === match && (lastC = index));
                }), args.splice(lastC, 0, c);
            }, exports.save = function(namespaces) {
                try {
                    namespaces ? exports.storage.setItem("debug", namespaces) : exports.storage.removeItem("debug");
                } catch (error) {}
            }, exports.load = function() {
                var r;
                try {
                    r = exports.storage.getItem("debug");
                } catch (error) {}
                !r && void 0 !== process && "env" in process && (r = process.env.DEBUG);
                return r;
            }, exports.useColors = function() {
                if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
                if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
                return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
            }, exports.storage = function() {
                try {
                    return localStorage;
                } catch (error) {}
            }(), exports.colors = [ "#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33" ], 
            module.exports = require("./common")(exports), module.exports.formatters.j = function(v) {
                try {
                    return JSON.stringify(v);
                } catch (error) {
                    return "[UnexpectedJSONParseError]: " + error.message;
                }
            };
        }).call(this, require("_process"));
    }, {
        "./common": 15,
        _process: 56
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        module.exports = function(env) {
            function selectColor(namespace) {
                for (var hash = 0, i = 0; i < namespace.length; i++) hash = (hash << 5) - hash + namespace.charCodeAt(i), 
                hash |= 0;
                return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
            }
            function createDebug(namespace) {
                var prevTime;
                function debug() {
                    if (debug.enabled) {
                        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        var self = debug, curr = Number(new Date()), ms = curr - (prevTime || curr);
                        self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, args[0] = createDebug.coerce(args[0]), 
                        "string" != typeof args[0] && args.unshift("%O");
                        var index = 0;
                        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
                            if ("%%" === match) return match;
                            index++;
                            var formatter = createDebug.formatters[format];
                            if ("function" == typeof formatter) {
                                var val = args[index];
                                match = formatter.call(self, val), args.splice(index, 1), index--;
                            }
                            return match;
                        }), createDebug.formatArgs.call(self, args), (self.log || createDebug.log).apply(self, args);
                    }
                }
                return debug.namespace = namespace, debug.enabled = createDebug.enabled(namespace), 
                debug.useColors = createDebug.useColors(), debug.color = selectColor(namespace), 
                debug.destroy = destroy, debug.extend = extend, "function" == typeof createDebug.init && createDebug.init(debug), 
                createDebug.instances.push(debug), debug;
            }
            function destroy() {
                var index = createDebug.instances.indexOf(this);
                return -1 !== index && (createDebug.instances.splice(index, 1), !0);
            }
            function extend(namespace, delimiter) {
                return createDebug(this.namespace + (void 0 === delimiter ? ":" : delimiter) + namespace);
            }
            return ((createDebug.debug = createDebug).default = createDebug).coerce = function(val) {
                return val instanceof Error ? val.stack || val.message : val;
            }, createDebug.disable = function() {
                createDebug.enable("");
            }, createDebug.enable = function(namespaces) {
                var i;
                createDebug.save(namespaces), createDebug.names = [], createDebug.skips = [];
                var split = ("string" == typeof namespaces ? namespaces : "").split(/[\s,]+/), len = split.length;
                for (i = 0; i < len; i++) split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : createDebug.names.push(new RegExp("^" + namespaces + "$")));
                for (i = 0; i < createDebug.instances.length; i++) {
                    var instance = createDebug.instances[i];
                    instance.enabled = createDebug.enabled(instance.namespace);
                }
            }, createDebug.enabled = function(name) {
                if ("*" === name[name.length - 1]) return !0;
                var i, len;
                for (i = 0, len = createDebug.skips.length; i < len; i++) if (createDebug.skips[i].test(name)) return !1;
                for (i = 0, len = createDebug.names.length; i < len; i++) if (createDebug.names[i].test(name)) return !0;
                return !1;
            }, createDebug.humanize = require("ms"), Object.keys(env).forEach(function(key) {
                createDebug[key] = env[key];
            }), createDebug.instances = [], createDebug.names = [], createDebug.skips = [], 
            createDebug.formatters = {}, createDebug.selectColor = selectColor, createDebug.enable(createDebug.load()), 
            createDebug;
        };
    }, {
        ms: 16
    } ],
    16: [ function(require, module, exports) {
        var s = 1e3, m = 6e4, h = 36e5, d = 24 * h;
        function plural(ms, msAbs, n, name) {
            var isPlural = 1.5 * n <= msAbs;
            return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
        }
        module.exports = function(val, options) {
            options = options || {};
            var type = typeof val;
            if ("string" === type && 0 < val.length) return function(str) {
                if (100 < (str = String(str)).length) return;
                var match = /^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
                if (!match) return;
                var n = parseFloat(match[1]);
                switch ((match[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * n;

                  case "weeks":
                  case "week":
                  case "w":
                    return 6048e5 * n;

                  case "days":
                  case "day":
                  case "d":
                    return n * d;

                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return n * h;

                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return n * m;

                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return n * s;

                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return n;

                  default:
                    return;
                }
            }(val);
            if ("number" === type && !1 === isNaN(val)) return options.long ? function(ms) {
                var msAbs = Math.abs(ms);
                if (d <= msAbs) return plural(ms, msAbs, d, "day");
                if (h <= msAbs) return plural(ms, msAbs, h, "hour");
                if (m <= msAbs) return plural(ms, msAbs, m, "minute");
                if (s <= msAbs) return plural(ms, msAbs, s, "second");
                return ms + " ms";
            }(val) : function(ms) {
                var msAbs = Math.abs(ms);
                if (d <= msAbs) return Math.round(ms / d) + "d";
                if (h <= msAbs) return Math.round(ms / h) + "h";
                if (m <= msAbs) return Math.round(ms / m) + "m";
                if (s <= msAbs) return Math.round(ms / s) + "s";
                return ms + "ms";
            }(val);
            throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
        };
    }, {} ],
    17: [ function(require, module, exports) {
        (function(global) {
            "use strict";
            function compare(a, b) {
                if (a === b) return 0;
                for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                    x = a[i], y = b[i];
                    break;
                }
                return x < y ? -1 : y < x ? 1 : 0;
            }
            function isBuffer(b) {
                return global.Buffer && "function" == typeof global.Buffer.isBuffer ? global.Buffer.isBuffer(b) : !(null == b || !b._isBuffer);
            }
            var util = require("util/"), hasOwn = Object.prototype.hasOwnProperty, pSlice = Array.prototype.slice, functionsHaveNames = "foo" === function() {}.name;
            function pToString(obj) {
                return Object.prototype.toString.call(obj);
            }
            function isView(arrbuf) {
                return !isBuffer(arrbuf) && ("function" == typeof global.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(arrbuf) : !!arrbuf && (arrbuf instanceof DataView || !!(arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer))));
            }
            var assert = module.exports = ok, regex = /\s*function\s+([^\(\s]*)\s*/;
            function getName(func) {
                if (util.isFunction(func)) {
                    if (functionsHaveNames) return func.name;
                    var match = func.toString().match(regex);
                    return match && match[1];
                }
            }
            function truncate(s, n) {
                return "string" == typeof s ? s.length < n ? s : s.slice(0, n) : s;
            }
            function inspect(something) {
                if (functionsHaveNames || !util.isFunction(something)) return util.inspect(something);
                var rawname = getName(something);
                return "[Function" + (rawname ? ": " + rawname : "") + "]";
            }
            function fail(actual, expected, message, operator, stackStartFunction) {
                throw new assert.AssertionError({
                    message: message,
                    actual: actual,
                    expected: expected,
                    operator: operator,
                    stackStartFunction: stackStartFunction
                });
            }
            function ok(value, message) {
                value || fail(value, !0, message, "==", assert.ok);
            }
            function _deepEqual(actual, expected, strict, memos) {
                if (actual === expected) return !0;
                if (isBuffer(actual) && isBuffer(expected)) return 0 === compare(actual, expected);
                if (util.isDate(actual) && util.isDate(expected)) return actual.getTime() === expected.getTime();
                if (util.isRegExp(actual) && util.isRegExp(expected)) return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                if (null !== actual && "object" == typeof actual || null !== expected && "object" == typeof expected) {
                    if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer));
                    if (isBuffer(actual) !== isBuffer(expected)) return !1;
                    var actualIndex = (memos = memos || {
                        actual: [],
                        expected: []
                    }).actual.indexOf(actual);
                    return -1 !== actualIndex && actualIndex === memos.expected.indexOf(expected) || (memos.actual.push(actual), 
                    memos.expected.push(expected), function(a, b, strict, actualVisitedObjects) {
                        if (null == a || null == b) return !1;
                        if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
                        if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
                        var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
                        if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
                        if (aIsArgs) return a = pSlice.call(a), b = pSlice.call(b), _deepEqual(a, b, strict);
                        var key, i, ka = objectKeys(a), kb = objectKeys(b);
                        if (ka.length !== kb.length) return !1;
                        for (ka.sort(), kb.sort(), i = ka.length - 1; 0 <= i; i--) if (ka[i] !== kb[i]) return !1;
                        for (i = ka.length - 1; 0 <= i; i--) if (key = ka[i], !_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return !1;
                        return !0;
                    }(actual, expected, strict, memos));
                }
                return strict ? actual === expected : actual == expected;
            }
            function isArguments(object) {
                return "[object Arguments]" == Object.prototype.toString.call(object);
            }
            function expectedException(actual, expected) {
                if (!actual || !expected) return !1;
                if ("[object RegExp]" == Object.prototype.toString.call(expected)) return expected.test(actual);
                try {
                    if (actual instanceof expected) return !0;
                } catch (e) {}
                return !Error.isPrototypeOf(expected) && !0 === expected.call({}, actual);
            }
            function _throws(shouldThrow, block, expected, message) {
                var actual;
                if ("function" != typeof block) throw new TypeError('"block" argument must be a function');
                "string" == typeof expected && (message = expected, expected = null), actual = function(block) {
                    var error;
                    try {
                        block();
                    } catch (e) {
                        error = e;
                    }
                    return error;
                }(block), message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), 
                shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message);
                var userProvidedMessage = "string" == typeof message, isUnexpectedException = !shouldThrow && actual && !expected;
                if ((!shouldThrow && util.isError(actual) && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) && fail(actual, expected, "Got unwanted exception" + message), 
                shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;
            }
            assert.AssertionError = function(options) {
                var self;
                this.name = "AssertionError", this.actual = options.actual, this.expected = options.expected, 
                this.operator = options.operator, options.message ? (this.message = options.message, 
                this.generatedMessage = !1) : (this.message = truncate(inspect((self = this).actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128), 
                this.generatedMessage = !0);
                var stackStartFunction = options.stackStartFunction || fail;
                if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction); else {
                    var err = new Error();
                    if (err.stack) {
                        var out = err.stack, fn_name = getName(stackStartFunction), idx = out.indexOf("\n" + fn_name);
                        if (0 <= idx) {
                            var next_line = out.indexOf("\n", idx + 1);
                            out = out.substring(next_line + 1);
                        }
                        this.stack = out;
                    }
                }
            }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, 
            assert.equal = function(actual, expected, message) {
                actual != expected && fail(actual, expected, message, "==", assert.equal);
            }, assert.notEqual = function(actual, expected, message) {
                actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
            }, assert.deepEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !1) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
            }, assert.deepStrictEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !0) || fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
            }, assert.notDeepEqual = function(actual, expected, message) {
                _deepEqual(actual, expected, !1) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
            }, assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
                _deepEqual(actual, expected, !0) && fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
            }, assert.strictEqual = function(actual, expected, message) {
                actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
            }, assert.notStrictEqual = function(actual, expected, message) {
                actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
            }, assert.throws = function(block, error, message) {
                _throws(!0, block, error, message);
            }, assert.doesNotThrow = function(block, error, message) {
                _throws(!1, block, error, message);
            }, assert.ifError = function(err) {
                if (err) throw err;
            };
            var objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) hasOwn.call(obj, key) && keys.push(key);
                return keys;
            };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "util/": 20
    } ],
    18: [ function(require, module, exports) {
        "function" == typeof Object.create ? module.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            });
        } : module.exports = function(ctor, superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor(), ctor.prototype.constructor = ctor;
        };
    }, {} ],
    19: [ function(require, module, exports) {
        module.exports = function(arg) {
            return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
        };
    }, {} ],
    20: [ function(require, module, exports) {
        (function(process, global) {
            var formatRegExp = /%[sdj%]/g;
            exports.format = function(f) {
                if (!isString(f)) {
                    for (var objects = [], i = 0; i < arguments.length; i++) objects.push(inspect(arguments[i]));
                    return objects.join(" ");
                }
                i = 1;
                for (var args = arguments, len = args.length, str = String(f).replace(formatRegExp, function(x) {
                    if ("%%" === x) return "%";
                    if (len <= i) return x;
                    switch (x) {
                      case "%s":
                        return String(args[i++]);

                      case "%d":
                        return Number(args[i++]);

                      case "%j":
                        try {
                            return JSON.stringify(args[i++]);
                        } catch (_) {
                            return "[Circular]";
                        }

                      default:
                        return x;
                    }
                }), x = args[i]; i < len; x = args[++i]) isNull(x) || !isObject(x) ? str += " " + x : str += " " + inspect(x);
                return str;
            }, exports.deprecate = function(fn, msg) {
                if (isUndefined(global.process)) return function() {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                };
                if (!0 === process.noDeprecation) return fn;
                var warned = !1;
                return function() {
                    if (!warned) {
                        if (process.throwDeprecation) throw new Error(msg);
                        process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
                    }
                    return fn.apply(this, arguments);
                };
            };
            var debugEnviron, debugs = {};
            function inspect(obj, opts) {
                var ctx = {
                    seen: [],
                    stylize: stylizeNoColor
                };
                return 3 <= arguments.length && (ctx.depth = arguments[2]), 4 <= arguments.length && (ctx.colors = arguments[3]), 
                isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), 
                isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), 
                isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), 
                formatValue(ctx, obj, ctx.depth);
            }
            function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str;
            }
            function stylizeNoColor(str, styleType) {
                return str;
            }
            function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                    var ret = value.inspect(recurseTimes, ctx);
                    return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
                }
                var primitive = function(ctx, value) {
                    if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                    if (isString(value)) {
                        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                        return ctx.stylize(simple, "string");
                    }
                    if (isNumber(value)) return ctx.stylize("" + value, "number");
                    if (isBoolean(value)) return ctx.stylize("" + value, "boolean");
                    if (isNull(value)) return ctx.stylize("null", "null");
                }(ctx, value);
                if (primitive) return primitive;
                var keys = Object.keys(value), visibleKeys = function(array) {
                    var hash = {};
                    return array.forEach(function(val, idx) {
                        hash[val] = !0;
                    }), hash;
                }(keys);
                if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (0 <= keys.indexOf("message") || 0 <= keys.indexOf("description"))) return formatError(value);
                if (0 === keys.length) {
                    if (isFunction(value)) {
                        var name = value.name ? ": " + value.name : "";
                        return ctx.stylize("[Function" + name + "]", "special");
                    }
                    if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                    if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                    if (isError(value)) return formatError(value);
                }
                var output, base = "", array = !1, braces = [ "{", "}" ];
                (isArray(value) && (array = !0, braces = [ "[", "]" ]), isFunction(value)) && (base = " [Function" + (value.name ? ": " + value.name : "") + "]");
                return isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), 
                isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), isError(value) && (base = " " + formatError(value)), 
                0 !== keys.length || array && 0 != value.length ? recurseTimes < 0 ? isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special") : (ctx.seen.push(value), 
                output = array ? function(ctx, value, recurseTimes, visibleKeys, keys) {
                    for (var output = [], i = 0, l = value.length; i < l; ++i) hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
                    return keys.forEach(function(key) {
                        key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
                    }), output;
                }(ctx, value, recurseTimes, visibleKeys, keys) : keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                }), ctx.seen.pop(), function(output, base, braces) {
                    if (60 < output.reduce(function(prev, cur) {
                        return 0, 0 <= cur.indexOf("\n") && 0, prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                    }, 0)) return braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
                }(output, base, braces)) : braces[0] + base + braces[1];
            }
            function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
            }
            function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                if ((desc = Object.getOwnPropertyDescriptor(value, key) || {
                    value: value[key]
                }).get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), 
                hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? -1 < (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1)).indexOf("\n") && (str = array ? str.split("\n").map(function(line) {
                    return "  " + line;
                }).join("\n").substr(2) : "\n" + str.split("\n").map(function(line) {
                    return "   " + line;
                }).join("\n")) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
                    if (array && key.match(/^\d+$/)) return str;
                    (name = JSON.stringify("" + key)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), 
                    name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), 
                    name = ctx.stylize(name, "string"));
                }
                return name + ": " + str;
            }
            function isArray(ar) {
                return Array.isArray(ar);
            }
            function isBoolean(arg) {
                return "boolean" == typeof arg;
            }
            function isNull(arg) {
                return null === arg;
            }
            function isNumber(arg) {
                return "number" == typeof arg;
            }
            function isString(arg) {
                return "string" == typeof arg;
            }
            function isUndefined(arg) {
                return void 0 === arg;
            }
            function isRegExp(re) {
                return isObject(re) && "[object RegExp]" === objectToString(re);
            }
            function isObject(arg) {
                return "object" == typeof arg && null !== arg;
            }
            function isDate(d) {
                return isObject(d) && "[object Date]" === objectToString(d);
            }
            function isError(e) {
                return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
            }
            function isFunction(arg) {
                return "function" == typeof arg;
            }
            function objectToString(o) {
                return Object.prototype.toString.call(o);
            }
            function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
            }
            exports.debuglog = function(set) {
                if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), 
                set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                        var msg = exports.format.apply(exports, arguments);
                        console.error("%s %d: %s", set, pid, msg);
                    };
                } else debugs[set] = function() {};
                return debugs[set];
            }, (exports.inspect = inspect).colors = {
                bold: [ 1, 22 ],
                italic: [ 3, 23 ],
                underline: [ 4, 24 ],
                inverse: [ 7, 27 ],
                white: [ 37, 39 ],
                grey: [ 90, 39 ],
                black: [ 30, 39 ],
                blue: [ 34, 39 ],
                cyan: [ 36, 39 ],
                green: [ 32, 39 ],
                magenta: [ 35, 39 ],
                red: [ 31, 39 ],
                yellow: [ 33, 39 ]
            }, inspect.styles = {
                special: "cyan",
                number: "yellow",
                boolean: "yellow",
                undefined: "grey",
                null: "bold",
                string: "green",
                date: "magenta",
                regexp: "red"
            }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, 
            exports.isNullOrUndefined = function(arg) {
                return null == arg;
            }, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = function(arg) {
                return "symbol" == typeof arg;
            }, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.isObject = isObject, 
            exports.isDate = isDate, exports.isError = isError, exports.isFunction = isFunction, 
            exports.isPrimitive = function(arg) {
                return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || void 0 === arg;
            }, exports.isBuffer = require("./support/isBuffer");
            var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            exports.log = function() {
                var d, time;
                console.log("%s - %s", (d = new Date(), time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":"), 
                [ d.getDate(), months[d.getMonth()], time ].join(" ")), exports.format.apply(exports, arguments));
            }, exports.inherits = require("inherits"), exports._extend = function(origin, add) {
                if (!add || !isObject(add)) return origin;
                for (var keys = Object.keys(add), i = keys.length; i--; ) origin[keys[i]] = add[keys[i]];
                return origin;
            };
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "./support/isBuffer": 19,
        _process: 56,
        inherits: 18
    } ],
    21: [ function(require, module, exports) {
        "use strict";
        exports.byteLength = function(b64) {
            var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1];
            return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
        }, exports.toByteArray = function(b64) {
            for (var tmp, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(function(b64, validLen, placeHoldersLen) {
                return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
            }(0, validLen, placeHoldersLen)), curByte = 0, len = 0 < placeHoldersLen ? validLen - 4 : validLen, i = 0; i < len; i += 4) tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], 
            arr[curByte++] = tmp >> 16 & 255, arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp;
            2 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, 
            arr[curByte++] = 255 & tmp);
            1 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, 
            arr[curByte++] = tmp >> 8 & 255, arr[curByte++] = 255 & tmp);
            return arr;
        }, exports.fromByteArray = function(uint8) {
            for (var tmp, len = uint8.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383) parts.push(encodeChunk(uint8, i, len2 < i + 16383 ? len2 : i + 16383));
            1 === extraBytes ? (tmp = uint8[len - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==")) : 2 === extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], 
            parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="));
            return parts.join("");
        };
        for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], 
        revLookup[code.charCodeAt(i)] = i;
        function getLens(b64) {
            var len = b64.length;
            if (0 < len % 4) throw new Error("Invalid string. Length must be a multiple of 4");
            var validLen = b64.indexOf("=");
            return -1 === validLen && (validLen = len), [ validLen, validLen === len ? 0 : 4 - validLen % 4 ];
        }
        function encodeChunk(uint8, start, end) {
            for (var tmp, num, output = [], i = start; i < end; i += 3) tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]), 
            output.push(lookup[(num = tmp) >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[63 & num]);
            return output.join("");
        }
        revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
    }, {} ],
    22: [ function(require, module, exports) {
        (function(process, Buffer) {
            "use strict";
            var assert = require("assert"), Zstream = require("pako/lib/zlib/zstream"), zlib_deflate = require("pako/lib/zlib/deflate.js"), zlib_inflate = require("pako/lib/zlib/inflate.js"), constants = require("pako/lib/zlib/constants");
            for (var key in constants) exports[key] = constants[key];
            exports.NONE = 0, exports.DEFLATE = 1, exports.INFLATE = 2, exports.GZIP = 3, exports.GUNZIP = 4, 
            exports.DEFLATERAW = 5, exports.INFLATERAW = 6, exports.UNZIP = 7;
            function Zlib(mode) {
                if ("number" != typeof mode || mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError("Bad argument");
                this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, 
                this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, 
                this.pending_close = !1, this.gzip_id_bytes_read = 0;
            }
            Zlib.prototype.close = function() {
                this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, assert(this.init_done, "close before init"), 
                assert(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW ? zlib_deflate.deflateEnd(this.strm) : this.mode !== exports.INFLATE && this.mode !== exports.GUNZIP && this.mode !== exports.INFLATERAW && this.mode !== exports.UNZIP || zlib_inflate.inflateEnd(this.strm), 
                this.mode = exports.NONE, this.dictionary = null);
            }, Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
                return this._write(!0, flush, input, in_off, in_len, out, out_off, out_len);
            }, Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
                return this._write(!1, flush, input, in_off, in_len, out, out_off, out_len);
            }, Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
                if (assert.equal(arguments.length, 8), assert(this.init_done, "write before init"), 
                assert(this.mode !== exports.NONE, "already finalized"), assert.equal(!1, this.write_in_progress, "write already in progress"), 
                assert.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, 
                assert.equal(!1, void 0 === flush, "must provide flush value"), this.write_in_progress = !0, 
                flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) throw new Error("Invalid flush value");
                if (null == input && (input = Buffer.alloc(0), in_off = in_len = 0), this.strm.avail_in = in_len, 
                this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, 
                this.strm.output = out, this.strm.next_out = out_off, this.flush = flush, !async) return this._process(), 
                this._checkError() ? this._afterSync() : void 0;
                var self = this;
                return process.nextTick(function() {
                    self._process(), self._after();
                }), this;
            }, Zlib.prototype._afterSync = function() {
                var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
                return this.write_in_progress = !1, [ avail_in, avail_out ];
            }, Zlib.prototype._process = function() {
                var next_expected_header_byte = null;
                switch (this.mode) {
                  case exports.DEFLATE:
                  case exports.GZIP:
                  case exports.DEFLATERAW:
                    this.err = zlib_deflate.deflate(this.strm, this.flush);
                    break;

                  case exports.UNZIP:
                    switch (0 < this.strm.avail_in && (next_expected_header_byte = this.strm.next_in), 
                    this.gzip_id_bytes_read) {
                      case 0:
                        if (null === next_expected_header_byte) break;
                        if (31 !== this.strm.input[next_expected_header_byte]) {
                            this.mode = exports.INFLATE;
                            break;
                        }
                        if (next_expected_header_byte++, (this.gzip_id_bytes_read = 1) === this.strm.avail_in) break;

                      case 1:
                        if (null === next_expected_header_byte) break;
                        139 === this.strm.input[next_expected_header_byte] ? (this.gzip_id_bytes_read = 2, 
                        this.mode = exports.GUNZIP) : this.mode = exports.INFLATE;
                        break;

                      default:
                        throw new Error("invalid number of gzip magic number bytes read");
                    }

                  case exports.INFLATE:
                  case exports.GUNZIP:
                  case exports.INFLATERAW:
                    for (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary && (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), 
                    this.err === exports.Z_OK ? this.err = zlib_inflate.inflate(this.strm, this.flush) : this.err === exports.Z_DATA_ERROR && (this.err = exports.Z_NEED_DICT)); 0 < this.strm.avail_in && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && 0 !== this.strm.next_in[0]; ) this.reset(), 
                    this.err = zlib_inflate.inflate(this.strm, this.flush);
                    break;

                  default:
                    throw new Error("Unknown mode " + this.mode);
                }
            }, Zlib.prototype._checkError = function() {
                switch (this.err) {
                  case exports.Z_OK:
                  case exports.Z_BUF_ERROR:
                    if (0 !== this.strm.avail_out && this.flush === exports.Z_FINISH) return this._error("unexpected end of file"), 
                    !1;
                    break;

                  case exports.Z_STREAM_END:
                    break;

                  case exports.Z_NEED_DICT:
                    return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), 
                    !1;

                  default:
                    return this._error("Zlib error"), !1;
                }
                return !0;
            }, Zlib.prototype._after = function() {
                if (this._checkError()) {
                    var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
                    this.write_in_progress = !1, this.callback(avail_in, avail_out), this.pending_close && this.close();
                }
            }, Zlib.prototype._error = function(message) {
                this.strm.msg && (message = this.strm.msg), this.onerror(message, this.err), this.write_in_progress = !1, 
                this.pending_close && this.close();
            }, Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
                assert(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), 
                assert(8 <= windowBits && windowBits <= 15, "invalid windowBits"), assert(-1 <= level && level <= 9, "invalid compression level"), 
                assert(1 <= memLevel && memLevel <= 9, "invalid memlevel"), assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy"), 
                this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();
            }, Zlib.prototype.params = function() {
                throw new Error("deflateParams Not supported");
            }, Zlib.prototype.reset = function() {
                this._reset(), this._setDictionary();
            }, Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
                switch (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, 
                this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, 
                this.mode !== exports.GZIP && this.mode !== exports.GUNZIP || (this.windowBits += 16), 
                this.mode === exports.UNZIP && (this.windowBits += 32), this.mode !== exports.DEFLATERAW && this.mode !== exports.INFLATERAW || (this.windowBits = -1 * this.windowBits), 
                this.strm = new Zstream(), this.mode) {
                  case exports.DEFLATE:
                  case exports.GZIP:
                  case exports.DEFLATERAW:
                    this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                    break;

                  case exports.INFLATE:
                  case exports.GUNZIP:
                  case exports.INFLATERAW:
                  case exports.UNZIP:
                    this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                    break;

                  default:
                    throw new Error("Unknown mode " + this.mode);
                }
                this.err !== exports.Z_OK && this._error("Init error"), this.dictionary = dictionary, 
                this.write_in_progress = !1, this.init_done = !0;
            }, Zlib.prototype._setDictionary = function() {
                if (null != this.dictionary) {
                    switch (this.err = exports.Z_OK, this.mode) {
                      case exports.DEFLATE:
                      case exports.DEFLATERAW:
                        this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                    }
                    this.err !== exports.Z_OK && this._error("Failed to set dictionary");
                }
            }, Zlib.prototype._reset = function() {
                switch (this.err = exports.Z_OK, this.mode) {
                  case exports.DEFLATE:
                  case exports.DEFLATERAW:
                  case exports.GZIP:
                    this.err = zlib_deflate.deflateReset(this.strm);
                    break;

                  case exports.INFLATE:
                  case exports.INFLATERAW:
                  case exports.GUNZIP:
                    this.err = zlib_inflate.inflateReset(this.strm);
                }
                this.err !== exports.Z_OK && this._error("Failed to reset stream");
            }, exports.Zlib = Zlib;
        }).call(this, require("_process"), require("buffer").Buffer);
    }, {
        _process: 56,
        assert: 17,
        buffer: 24,
        "pako/lib/zlib/constants": 30,
        "pako/lib/zlib/deflate.js": 32,
        "pako/lib/zlib/inflate.js": 34,
        "pako/lib/zlib/zstream": 38
    } ],
    23: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            var Buffer = require("buffer").Buffer, Transform = require("stream").Transform, binding = require("./binding"), util = require("util"), assert = require("assert").ok, kMaxLength = require("buffer").kMaxLength, kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
            binding.Z_MIN_WINDOWBITS = 8, binding.Z_MAX_WINDOWBITS = 15, binding.Z_DEFAULT_WINDOWBITS = 15, 
            binding.Z_MIN_CHUNK = 64, binding.Z_MAX_CHUNK = 1 / 0, binding.Z_DEFAULT_CHUNK = 16384, 
            binding.Z_MIN_MEMLEVEL = 1, binding.Z_MAX_MEMLEVEL = 9, binding.Z_DEFAULT_MEMLEVEL = 8, 
            binding.Z_MIN_LEVEL = -1, binding.Z_MAX_LEVEL = 9, binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
            for (var bkeys = Object.keys(binding), bk = 0; bk < bkeys.length; bk++) {
                var bkey = bkeys[bk];
                bkey.match(/^Z/) && Object.defineProperty(exports, bkey, {
                    enumerable: !0,
                    value: binding[bkey],
                    writable: !1
                });
            }
            for (var codes = {
                Z_OK: binding.Z_OK,
                Z_STREAM_END: binding.Z_STREAM_END,
                Z_NEED_DICT: binding.Z_NEED_DICT,
                Z_ERRNO: binding.Z_ERRNO,
                Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
                Z_DATA_ERROR: binding.Z_DATA_ERROR,
                Z_MEM_ERROR: binding.Z_MEM_ERROR,
                Z_BUF_ERROR: binding.Z_BUF_ERROR,
                Z_VERSION_ERROR: binding.Z_VERSION_ERROR
            }, ckeys = Object.keys(codes), ck = 0; ck < ckeys.length; ck++) {
                var ckey = ckeys[ck];
                codes[codes[ckey]] = ckey;
            }
            function zlibBuffer(engine, buffer, callback) {
                var buffers = [], nread = 0;
                function flow() {
                    for (var chunk; null !== (chunk = engine.read()); ) buffers.push(chunk), nread += chunk.length;
                    engine.once("readable", flow);
                }
                function onEnd() {
                    var buf, err = null;
                    kMaxLength <= nread ? err = new RangeError(kRangeErrorMessage) : buf = Buffer.concat(buffers, nread), 
                    buffers = [], engine.close(), callback(err, buf);
                }
                engine.on("error", function(err) {
                    engine.removeListener("end", onEnd), engine.removeListener("readable", flow), callback(err);
                }), engine.on("end", onEnd), engine.end(buffer), flow();
            }
            function zlibBufferSync(engine, buffer) {
                if ("string" == typeof buffer && (buffer = Buffer.from(buffer)), !Buffer.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
                var flushFlag = engine._finishFlushFlag;
                return engine._processChunk(buffer, flushFlag);
            }
            function Deflate(opts) {
                if (!(this instanceof Deflate)) return new Deflate(opts);
                Zlib.call(this, opts, binding.DEFLATE);
            }
            function Inflate(opts) {
                if (!(this instanceof Inflate)) return new Inflate(opts);
                Zlib.call(this, opts, binding.INFLATE);
            }
            function Gzip(opts) {
                if (!(this instanceof Gzip)) return new Gzip(opts);
                Zlib.call(this, opts, binding.GZIP);
            }
            function Gunzip(opts) {
                if (!(this instanceof Gunzip)) return new Gunzip(opts);
                Zlib.call(this, opts, binding.GUNZIP);
            }
            function DeflateRaw(opts) {
                if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
                Zlib.call(this, opts, binding.DEFLATERAW);
            }
            function InflateRaw(opts) {
                if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
                Zlib.call(this, opts, binding.INFLATERAW);
            }
            function Unzip(opts) {
                if (!(this instanceof Unzip)) return new Unzip(opts);
                Zlib.call(this, opts, binding.UNZIP);
            }
            function isValidFlushFlag(flag) {
                return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
            }
            function Zlib(opts, mode) {
                var _this = this;
                if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, 
                Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush)) throw new Error("Invalid flush flag: " + opts.flush);
                if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) throw new Error("Invalid flush flag: " + opts.finishFlush);
                if (this._flushFlag = opts.flush || binding.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== opts.finishFlush ? opts.finishFlush : binding.Z_FINISH, 
                opts.chunkSize && (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + opts.chunkSize);
                if (opts.windowBits && (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + opts.windowBits);
                if (opts.level && (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + opts.level);
                if (opts.memLevel && (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + opts.memLevel);
                if (opts.strategy && opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + opts.strategy);
                if (opts.dictionary && !Buffer.isBuffer(opts.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance");
                this._handle = new binding.Zlib(mode);
                var self = this;
                this._hadError = !1, this._handle.onerror = function(message, errno) {
                    _close(self), self._hadError = !0;
                    var error = new Error(message);
                    error.errno = errno, error.code = exports.codes[errno], self.emit("error", error);
                };
                var level = exports.Z_DEFAULT_COMPRESSION;
                "number" == typeof opts.level && (level = opts.level);
                var strategy = exports.Z_DEFAULT_STRATEGY;
                "number" == typeof opts.strategy && (strategy = opts.strategy), this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), 
                this._buffer = Buffer.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, 
                this._strategy = strategy, this.once("end", this.close), Object.defineProperty(this, "_closed", {
                    get: function() {
                        return !_this._handle;
                    },
                    configurable: !0,
                    enumerable: !0
                });
            }
            function _close(engine, callback) {
                callback && process.nextTick(callback), engine._handle && (engine._handle.close(), 
                engine._handle = null);
            }
            function emitCloseNT(self) {
                self.emit("close");
            }
            Object.defineProperty(exports, "codes", {
                enumerable: !0,
                value: Object.freeze(codes),
                writable: !1
            }), exports.Deflate = Deflate, exports.Inflate = Inflate, exports.Gzip = Gzip, exports.Gunzip = Gunzip, 
            exports.DeflateRaw = DeflateRaw, exports.InflateRaw = InflateRaw, exports.Unzip = Unzip, 
            exports.createDeflate = function(o) {
                return new Deflate(o);
            }, exports.createInflate = function(o) {
                return new Inflate(o);
            }, exports.createDeflateRaw = function(o) {
                return new DeflateRaw(o);
            }, exports.createInflateRaw = function(o) {
                return new InflateRaw(o);
            }, exports.createGzip = function(o) {
                return new Gzip(o);
            }, exports.createGunzip = function(o) {
                return new Gunzip(o);
            }, exports.createUnzip = function(o) {
                return new Unzip(o);
            }, exports.deflate = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Deflate(opts), buffer, callback);
            }, exports.deflateSync = function(buffer, opts) {
                return zlibBufferSync(new Deflate(opts), buffer);
            }, exports.gzip = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Gzip(opts), buffer, callback);
            }, exports.gzipSync = function(buffer, opts) {
                return zlibBufferSync(new Gzip(opts), buffer);
            }, exports.deflateRaw = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new DeflateRaw(opts), buffer, callback);
            }, exports.deflateRawSync = function(buffer, opts) {
                return zlibBufferSync(new DeflateRaw(opts), buffer);
            }, exports.unzip = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Unzip(opts), buffer, callback);
            }, exports.unzipSync = function(buffer, opts) {
                return zlibBufferSync(new Unzip(opts), buffer);
            }, exports.inflate = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Inflate(opts), buffer, callback);
            }, exports.inflateSync = function(buffer, opts) {
                return zlibBufferSync(new Inflate(opts), buffer);
            }, exports.gunzip = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Gunzip(opts), buffer, callback);
            }, exports.gunzipSync = function(buffer, opts) {
                return zlibBufferSync(new Gunzip(opts), buffer);
            }, exports.inflateRaw = function(buffer, opts, callback) {
                return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new InflateRaw(opts), buffer, callback);
            }, exports.inflateRawSync = function(buffer, opts) {
                return zlibBufferSync(new InflateRaw(opts), buffer);
            }, util.inherits(Zlib, Transform), Zlib.prototype.params = function(level, strategy, callback) {
                if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + level);
                if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + strategy);
                if (this._level !== level || this._strategy !== strategy) {
                    var self = this;
                    this.flush(binding.Z_SYNC_FLUSH, function() {
                        assert(self._handle, "zlib binding closed"), self._handle.params(level, strategy), 
                        self._hadError || (self._level = level, self._strategy = strategy, callback && callback());
                    });
                } else process.nextTick(callback);
            }, Zlib.prototype.reset = function() {
                return assert(this._handle, "zlib binding closed"), this._handle.reset();
            }, Zlib.prototype._flush = function(callback) {
                this._transform(Buffer.alloc(0), "", callback);
            }, Zlib.prototype.flush = function(kind, callback) {
                var _this2 = this, ws = this._writableState;
                ("function" == typeof kind || void 0 === kind && !callback) && (callback = kind, 
                kind = binding.Z_FULL_FLUSH), ws.ended ? callback && process.nextTick(callback) : ws.ending ? callback && this.once("end", callback) : ws.needDrain ? callback && this.once("drain", function() {
                    return _this2.flush(kind, callback);
                }) : (this._flushFlag = kind, this.write(Buffer.alloc(0), "", callback));
            }, Zlib.prototype.close = function(callback) {
                _close(this, callback), process.nextTick(emitCloseNT, this);
            }, Zlib.prototype._transform = function(chunk, encoding, cb) {
                var flushFlag, ws = this._writableState, last = (ws.ending || ws.ended) && (!chunk || ws.length === chunk.length);
                return null === chunk || Buffer.isBuffer(chunk) ? this._handle ? (last ? flushFlag = this._finishFlushFlag : (flushFlag = this._flushFlag, 
                chunk.length >= ws.length && (this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH)), 
                void this._processChunk(chunk, flushFlag, cb)) : cb(new Error("zlib binding closed")) : cb(new Error("invalid input"));
            }, Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
                var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self = this, async = "function" == typeof cb;
                if (!async) {
                    var error, buffers = [], nread = 0;
                    this.on("error", function(er) {
                        error = er;
                    }), assert(this._handle, "zlib binding closed");
                    do {
                        var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                    } while (!this._hadError && callback(res[0], res[1]));
                    if (this._hadError) throw error;
                    if (kMaxLength <= nread) throw _close(this), new RangeError(kRangeErrorMessage);
                    var buf = Buffer.concat(buffers, nread);
                    return _close(this), buf;
                }
                assert(this._handle, "zlib binding closed");
                var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                function callback(availInAfter, availOutAfter) {
                    if (this && (this.buffer = null, this.callback = null), !self._hadError) {
                        var have = availOutBefore - availOutAfter;
                        if (assert(0 <= have, "have should not go down"), 0 < have) {
                            var out = self._buffer.slice(self._offset, self._offset + have);
                            self._offset += have, async ? self.push(out) : (buffers.push(out), nread += out.length);
                        }
                        if ((0 === availOutAfter || self._offset >= self._chunkSize) && (availOutBefore = self._chunkSize, 
                        self._offset = 0, self._buffer = Buffer.allocUnsafe(self._chunkSize)), 0 === availOutAfter) {
                            if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async) return !0;
                            var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
                            return newReq.callback = callback, void (newReq.buffer = chunk);
                        }
                        if (!async) return !1;
                        cb();
                    }
                }
                req.buffer = chunk, req.callback = callback;
            }, util.inherits(Deflate, Zlib), util.inherits(Inflate, Zlib), util.inherits(Gzip, Zlib), 
            util.inherits(Gunzip, Zlib), util.inherits(DeflateRaw, Zlib), util.inherits(InflateRaw, Zlib), 
            util.inherits(Unzip, Zlib);
        }).call(this, require("_process"));
    }, {
        "./binding": 22,
        _process: 56,
        assert: 17,
        buffer: 24,
        stream: 76,
        util: 82
    } ],
    24: [ function(require, module, exports) {
        "use strict";
        var base64 = require("base64-js"), ieee754 = require("ieee754");
        exports.Buffer = Buffer, exports.SlowBuffer = function(length) {
            +length != length && (length = 0);
            return Buffer.alloc(+length);
        }, exports.INSPECT_MAX_BYTES = 50;
        var K_MAX_LENGTH = 2147483647;
        function createBuffer(length) {
            if (K_MAX_LENGTH < length) throw new RangeError('The value "' + length + '" is invalid for option "size"');
            var buf = new Uint8Array(length);
            return buf.__proto__ = Buffer.prototype, buf;
        }
        function Buffer(arg, encodingOrOffset, length) {
            if ("number" == typeof arg) {
                if ("string" == typeof encodingOrOffset) throw new TypeError('The "string" argument must be of type string. Received type number');
                return allocUnsafe(arg);
            }
            return from(arg, encodingOrOffset, length);
        }
        function from(value, encodingOrOffset, length) {
            if ("string" == typeof value) return function(string, encoding) {
                "string" == typeof encoding && "" !== encoding || (encoding = "utf8");
                if (!Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                var length = 0 | byteLength(string, encoding), buf = createBuffer(length), actual = buf.write(string, encoding);
                actual !== length && (buf = buf.slice(0, actual));
                return buf;
            }(value, encodingOrOffset);
            if (ArrayBuffer.isView(value)) return fromArrayLike(value);
            if (null == value) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return function(array, byteOffset, length) {
                if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
                if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
                var buf;
                buf = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length);
                return buf.__proto__ = Buffer.prototype, buf;
            }(value, encodingOrOffset, length);
            if ("number" == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type number');
            var valueOf = value.valueOf && value.valueOf();
            if (null != valueOf && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
            var b = function(obj) {
                if (Buffer.isBuffer(obj)) {
                    var len = 0 | checked(obj.length), buf = createBuffer(len);
                    return 0 === buf.length || obj.copy(buf, 0, 0, len), buf;
                }
                if (void 0 !== obj.length) return "number" != typeof obj.length || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj);
                if ("Buffer" === obj.type && Array.isArray(obj.data)) return fromArrayLike(obj.data);
            }(value);
            if (b) return b;
            if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof value[Symbol.toPrimitive]) return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        function assertSize(size) {
            if ("number" != typeof size) throw new TypeError('"size" argument must be of type number');
            if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        function allocUnsafe(size) {
            return assertSize(size), createBuffer(size < 0 ? 0 : 0 | checked(size));
        }
        function fromArrayLike(array) {
            for (var length = array.length < 0 ? 0 : 0 | checked(array.length), buf = createBuffer(length), i = 0; i < length; i += 1) buf[i] = 255 & array[i];
            return buf;
        }
        function checked(length) {
            if (K_MAX_LENGTH <= length) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
            return 0 | length;
        }
        function byteLength(string, encoding) {
            if (Buffer.isBuffer(string)) return string.length;
            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
            if ("string" != typeof string) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
            var len = string.length, mustMatch = 2 < arguments.length && !0 === arguments[2];
            if (!mustMatch && 0 === len) return 0;
            for (var loweredCase = !1; ;) switch (encoding) {
              case "ascii":
              case "latin1":
              case "binary":
                return len;

              case "utf8":
              case "utf-8":
                return utf8ToBytes(string).length;

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * len;

              case "hex":
                return len >>> 1;

              case "base64":
                return base64ToBytes(string).length;

              default:
                if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
                encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
            }
        }
        function swap(b, n, m) {
            var i = b[n];
            b[n] = b[m], b[m] = i;
        }
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
            if (0 === buffer.length) return -1;
            if ("string" == typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : 2147483647 < byteOffset ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), 
            numberIsNaN(byteOffset = +byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), 
            byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
                if (dir) return -1;
                byteOffset = buffer.length - 1;
            } else if (byteOffset < 0) {
                if (!dir) return -1;
                byteOffset = 0;
            }
            if ("string" == typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val)) return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
            if ("number" == typeof val) return val &= 255, "function" == typeof Uint8Array.prototype.indexOf ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
            throw new TypeError("val must be string, number or Buffer");
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
            var i, indexSize = 1, arrLength = arr.length, valLength = val.length;
            if (void 0 !== encoding && ("ucs2" === (encoding = String(encoding).toLowerCase()) || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding)) {
                if (arr.length < 2 || val.length < 2) return -1;
                arrLength /= indexSize = 2, valLength /= 2, byteOffset /= 2;
            }
            function read(buf, i) {
                return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
            }
            if (dir) {
                var foundIndex = -1;
                for (i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                    if (-1 === foundIndex && (foundIndex = i), i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                } else -1 !== foundIndex && (i -= i - foundIndex), foundIndex = -1;
            } else for (arrLength < byteOffset + valLength && (byteOffset = arrLength - valLength), 
            i = byteOffset; 0 <= i; i--) {
                for (var found = !0, j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
                    found = !1;
                    break;
                }
                if (found) return i;
            }
            return -1;
        }
        function hexWrite(buf, string, offset, length) {
            offset = Number(offset) || 0;
            var remaining = buf.length - offset;
            length ? remaining < (length = Number(length)) && (length = remaining) : length = remaining;
            var strLen = string.length;
            strLen / 2 < length && (length = strLen / 2);
            for (var i = 0; i < length; ++i) {
                var parsed = parseInt(string.substr(2 * i, 2), 16);
                if (numberIsNaN(parsed)) return i;
                buf[offset + i] = parsed;
            }
            return i;
        }
        function utf8Write(buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
            return blitBuffer(function(str) {
                for (var byteArray = [], i = 0; i < str.length; ++i) byteArray.push(255 & str.charCodeAt(i));
                return byteArray;
            }(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
            return blitBuffer(function(str, units) {
                for (var c, hi, lo, byteArray = [], i = 0; i < str.length && !((units -= 2) < 0); ++i) c = str.charCodeAt(i), 
                hi = c >> 8, lo = c % 256, byteArray.push(lo), byteArray.push(hi);
                return byteArray;
            }(string, buf.length - offset), buf, offset, length);
        }
        function base64Slice(buf, start, end) {
            return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
        }
        function utf8Slice(buf, start, end) {
            end = Math.min(buf.length, end);
            for (var res = [], i = start; i < end; ) {
                var secondByte, thirdByte, fourthByte, tempCodePoint, firstByte = buf[i], codePoint = null, bytesPerSequence = 239 < firstByte ? 4 : 223 < firstByte ? 3 : 191 < firstByte ? 2 : 1;
                if (i + bytesPerSequence <= end) switch (bytesPerSequence) {
                  case 1:
                    firstByte < 128 && (codePoint = firstByte);
                    break;

                  case 2:
                    128 == (192 & (secondByte = buf[i + 1])) && 127 < (tempCodePoint = (31 & firstByte) << 6 | 63 & secondByte) && (codePoint = tempCodePoint);
                    break;

                  case 3:
                    secondByte = buf[i + 1], thirdByte = buf[i + 2], 128 == (192 & secondByte) && 128 == (192 & thirdByte) && 2047 < (tempCodePoint = (15 & firstByte) << 12 | (63 & secondByte) << 6 | 63 & thirdByte) && (tempCodePoint < 55296 || 57343 < tempCodePoint) && (codePoint = tempCodePoint);
                    break;

                  case 4:
                    secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], 128 == (192 & secondByte) && 128 == (192 & thirdByte) && 128 == (192 & fourthByte) && 65535 < (tempCodePoint = (15 & firstByte) << 18 | (63 & secondByte) << 12 | (63 & thirdByte) << 6 | 63 & fourthByte) && tempCodePoint < 1114112 && (codePoint = tempCodePoint);
                }
                null === codePoint ? (codePoint = 65533, bytesPerSequence = 1) : 65535 < codePoint && (codePoint -= 65536, 
                res.push(codePoint >>> 10 & 1023 | 55296), codePoint = 56320 | 1023 & codePoint), 
                res.push(codePoint), i += bytesPerSequence;
            }
            return function(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode.apply(String, codePoints);
                var res = "", i = 0;
                for (;i < len; ) res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                return res;
            }(res);
        }
        exports.kMaxLength = K_MAX_LENGTH, (Buffer.TYPED_ARRAY_SUPPORT = function() {
            try {
                var arr = new Uint8Array(1);
                return arr.__proto__ = {
                    __proto__: Uint8Array.prototype,
                    foo: function() {
                        return 42;
                    }
                }, 42 === arr.foo();
            } catch (e) {
                return !1;
            }
        }()) || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), 
        Object.defineProperty(Buffer.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (Buffer.isBuffer(this)) return this.buffer;
            }
        }), Object.defineProperty(Buffer.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (Buffer.isBuffer(this)) return this.byteOffset;
            }
        }), "undefined" != typeof Symbol && null != Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
            value: null,
            configurable: !0,
            enumerable: !1,
            writable: !1
        }), Buffer.poolSize = 8192, Buffer.from = function(value, encodingOrOffset, length) {
            return from(value, encodingOrOffset, length);
        }, Buffer.prototype.__proto__ = Uint8Array.prototype, Buffer.__proto__ = Uint8Array, 
        Buffer.alloc = function(size, fill, encoding) {
            return function(size, fill, encoding) {
                return assertSize(size), size <= 0 ? createBuffer(size) : void 0 !== fill ? "string" == typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size);
            }(size, fill, encoding);
        }, Buffer.allocUnsafe = function(size) {
            return allocUnsafe(size);
        }, Buffer.allocUnsafeSlow = function(size) {
            return allocUnsafe(size);
        }, Buffer.isBuffer = function(b) {
            return null != b && !0 === b._isBuffer && b !== Buffer.prototype;
        }, Buffer.compare = function(a, b) {
            if (isInstance(a, Uint8Array) && (a = Buffer.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer.from(b, b.offset, b.byteLength)), 
            !Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (a === b) return 0;
            for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                x = a[i], y = b[i];
                break;
            }
            return x < y ? -1 : y < x ? 1 : 0;
        }, Buffer.isEncoding = function(encoding) {
            switch (String(encoding).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;

              default:
                return !1;
            }
        }, Buffer.concat = function(list, length) {
            if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (0 === list.length) return Buffer.alloc(0);
            var i;
            if (void 0 === length) for (i = length = 0; i < list.length; ++i) length += list[i].length;
            var buffer = Buffer.allocUnsafe(length), pos = 0;
            for (i = 0; i < list.length; ++i) {
                var buf = list[i];
                if (isInstance(buf, Uint8Array) && (buf = Buffer.from(buf)), !Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
                buf.copy(buffer, pos), pos += buf.length;
            }
            return buffer;
        }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function() {
            var len = this.length;
            if (len % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var i = 0; i < len; i += 2) swap(this, i, i + 1);
            return this;
        }, Buffer.prototype.swap32 = function() {
            var len = this.length;
            if (len % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var i = 0; i < len; i += 4) swap(this, i, i + 3), swap(this, i + 1, i + 2);
            return this;
        }, Buffer.prototype.swap64 = function() {
            var len = this.length;
            if (len % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var i = 0; i < len; i += 8) swap(this, i, i + 7), swap(this, i + 1, i + 6), 
            swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
            return this;
        }, Buffer.prototype.toLocaleString = Buffer.prototype.toString = function() {
            var length = this.length;
            return 0 === length ? "" : 0 === arguments.length ? utf8Slice(this, 0, length) : function(encoding, start, end) {
                var loweredCase = !1;
                if ((void 0 === start || start < 0) && (start = 0), start > this.length) return "";
                if ((void 0 === end || end > this.length) && (end = this.length), end <= 0) return "";
                if ((end >>>= 0) <= (start >>>= 0)) return "";
                for (encoding || (encoding = "utf8"); ;) switch (encoding) {
                  case "hex":
                    return hexSlice(this, start, end);

                  case "utf8":
                  case "utf-8":
                    return utf8Slice(this, start, end);

                  case "ascii":
                    return asciiSlice(this, start, end);

                  case "latin1":
                  case "binary":
                    return latin1Slice(this, start, end);

                  case "base64":
                    return base64Slice(this, start, end);

                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return utf16leSlice(this, start, end);

                  default:
                    if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                    encoding = (encoding + "").toLowerCase(), loweredCase = !0;
                }
            }.apply(this, arguments);
        }, Buffer.prototype.equals = function(b) {
            if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
            return this === b || 0 === Buffer.compare(this, b);
        }, Buffer.prototype.inspect = function() {
            var str = "", max = exports.INSPECT_MAX_BYTES;
            return str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max && (str += " ... "), 
            "<Buffer " + str + ">";
        }, Buffer.prototype.compare = function(target, start, end, thisStart, thisEnd) {
            if (isInstance(target, Uint8Array) && (target = Buffer.from(target, target.offset, target.byteLength)), 
            !Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
            if (void 0 === start && (start = 0), void 0 === end && (end = target ? target.length : 0), 
            void 0 === thisStart && (thisStart = 0), void 0 === thisEnd && (thisEnd = this.length), 
            start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
            if (thisEnd <= thisStart && end <= start) return 0;
            if (thisEnd <= thisStart) return -1;
            if (end <= start) return 1;
            if (this === target) return 0;
            for (var x = (thisEnd >>>= 0) - (thisStart >>>= 0), y = (end >>>= 0) - (start >>>= 0), len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i], y = targetCopy[i];
                break;
            }
            return x < y ? -1 : y < x ? 1 : 0;
        }, Buffer.prototype.includes = function(val, byteOffset, encoding) {
            return -1 !== this.indexOf(val, byteOffset, encoding);
        }, Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
        }, Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
        }, Buffer.prototype.write = function(string, offset, length, encoding) {
            if (void 0 === offset) encoding = "utf8", length = this.length, offset = 0; else if (void 0 === length && "string" == typeof offset) encoding = offset, 
            length = this.length, offset = 0; else {
                if (!isFinite(offset)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                offset >>>= 0, isFinite(length) ? (length >>>= 0, void 0 === encoding && (encoding = "utf8")) : (encoding = length, 
                length = void 0);
            }
            var remaining = this.length - offset;
            if ((void 0 === length || remaining < length) && (length = remaining), 0 < string.length && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            encoding || (encoding = "utf8");
            for (var loweredCase = !1; ;) switch (encoding) {
              case "hex":
                return hexWrite(this, string, offset, length);

              case "utf8":
              case "utf-8":
                return utf8Write(this, string, offset, length);

              case "ascii":
                return asciiWrite(this, string, offset, length);

              case "latin1":
              case "binary":
                return latin1Write(this, string, offset, length);

              case "base64":
                return base64Write(this, string, offset, length);

              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return ucs2Write(this, string, offset, length);

              default:
                if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
            }
        }, Buffer.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            };
        };
        var MAX_ARGUMENTS_LENGTH = 4096;
        function asciiSlice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) ret += String.fromCharCode(127 & buf[i]);
            return ret;
        }
        function latin1Slice(buf, start, end) {
            var ret = "";
            end = Math.min(buf.length, end);
            for (var i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
            return ret;
        }
        function hexSlice(buf, start, end) {
            var len = buf.length;
            (!start || start < 0) && (start = 0), (!end || end < 0 || len < end) && (end = len);
            for (var out = "", i = start; i < end; ++i) out += toHex(buf[i]);
            return out;
        }
        function utf16leSlice(buf, start, end) {
            for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
            return res;
        }
        function checkOffset(offset, ext, length) {
            if (offset % 1 != 0 || offset < 0) throw new RangeError("offset is not uint");
            if (length < offset + ext) throw new RangeError("Trying to access beyond buffer length");
        }
        function checkInt(buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (max < value || value < min) throw new RangeError('"value" argument is out of bounds');
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
        }
        function checkIEEE754(buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError("Index out of range");
            if (offset < 0) throw new RangeError("Index out of range");
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 4), 
            ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
        }
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 8), 
            ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
        }
        Buffer.prototype.slice = function(start, end) {
            var len = this.length;
            (start = ~~start) < 0 ? (start += len) < 0 && (start = 0) : len < start && (start = len), 
            (end = void 0 === end ? len : ~~end) < 0 ? (end += len) < 0 && (end = 0) : len < end && (end = len), 
            end < start && (end = start);
            var newBuf = this.subarray(start, end);
            return newBuf.__proto__ = Buffer.prototype, newBuf;
        }, Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
            offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
            for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256); ) val += this[offset + i] * mul;
            return val;
        }, Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
            offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
            for (var val = this[offset + --byteLength], mul = 1; 0 < byteLength && (mul *= 256); ) val += this[offset + --byteLength] * mul;
            return val;
        }, Buffer.prototype.readUInt8 = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
        }, Buffer.prototype.readUInt16LE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
        }, Buffer.prototype.readUInt16BE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
        }, Buffer.prototype.readUInt32LE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
        }, Buffer.prototype.readUInt32BE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        }, Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
            offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
            for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 256); ) val += this[offset + i] * mul;
            return (mul *= 128) <= val && (val -= Math.pow(2, 8 * byteLength)), val;
        }, Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
            offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
            for (var i = byteLength, mul = 1, val = this[offset + --i]; 0 < i && (mul *= 256); ) val += this[offset + --i] * mul;
            return (mul *= 128) <= val && (val -= Math.pow(2, 8 * byteLength)), val;
        }, Buffer.prototype.readInt8 = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), 128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset];
        }, Buffer.prototype.readInt16LE = function(offset, noAssert) {
            offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
            var val = this[offset] | this[offset + 1] << 8;
            return 32768 & val ? 4294901760 | val : val;
        }, Buffer.prototype.readInt16BE = function(offset, noAssert) {
            offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
            var val = this[offset + 1] | this[offset] << 8;
            return 32768 & val ? 4294901760 | val : val;
        }, Buffer.prototype.readInt32LE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        }, Buffer.prototype.readInt32BE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        }, Buffer.prototype.readFloatLE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4);
        }, Buffer.prototype.readFloatBE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4);
        }, Buffer.prototype.readDoubleLE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8);
        }, Buffer.prototype.readDoubleBE = function(offset, noAssert) {
            return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8);
        }, Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
            (value = +value, offset >>>= 0, byteLength >>>= 0, noAssert) || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
            var mul = 1, i = 0;
            for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); ) this[offset + i] = value / mul & 255;
            return offset + byteLength;
        }, Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
            (value = +value, offset >>>= 0, byteLength >>>= 0, noAssert) || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
            var i = byteLength - 1, mul = 1;
            for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); ) this[offset + i] = value / mul & 255;
            return offset + byteLength;
        }, Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 255, 0), 
            this[offset] = 255 & value, offset + 1;
        }, Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), 
            this[offset] = 255 & value, this[offset + 1] = value >>> 8, offset + 2;
        }, Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), 
            this[offset] = value >>> 8, this[offset + 1] = 255 & value, offset + 2;
        }, Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), 
            this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, 
            this[offset] = 255 & value, offset + 4;
        }, Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), 
            this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, 
            this[offset + 3] = 255 & value, offset + 4;
        }, Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
            if (value = +value, offset >>>= 0, !noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = 0, mul = 1, sub = 0;
            for (this[offset] = 255 & value; ++i < byteLength && (mul *= 256); ) value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1), 
            this[offset + i] = (value / mul >> 0) - sub & 255;
            return offset + byteLength;
        }, Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
            if (value = +value, offset >>>= 0, !noAssert) {
                var limit = Math.pow(2, 8 * byteLength - 1);
                checkInt(this, value, offset, byteLength, limit - 1, -limit);
            }
            var i = byteLength - 1, mul = 1, sub = 0;
            for (this[offset + i] = 255 & value; 0 <= --i && (mul *= 256); ) value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1), 
            this[offset + i] = (value / mul >> 0) - sub & 255;
            return offset + byteLength;
        }, Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 127, -128), 
            value < 0 && (value = 255 + value + 1), this[offset] = 255 & value, offset + 1;
        }, Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), 
            this[offset] = 255 & value, this[offset + 1] = value >>> 8, offset + 2;
        }, Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), 
            this[offset] = value >>> 8, this[offset + 1] = 255 & value, offset + 2;
        }, Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), 
            this[offset] = 255 & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, 
            this[offset + 3] = value >>> 24, offset + 4;
        }, Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
            return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), 
            value < 0 && (value = 4294967295 + value + 1), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, 
            this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value, offset + 4;
        }, Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, !0, noAssert);
        }, Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
            return writeFloat(this, value, offset, !1, noAssert);
        }, Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, !0, noAssert);
        }, Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
            return writeDouble(this, value, offset, !1, noAssert);
        }, Buffer.prototype.copy = function(target, targetStart, start, end) {
            if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
            if (start || (start = 0), end || 0 === end || (end = this.length), targetStart >= target.length && (targetStart = target.length), 
            targetStart || (targetStart = 0), 0 < end && end < start && (end = start), end === start) return 0;
            if (0 === target.length || 0 === this.length) return 0;
            if (targetStart < 0) throw new RangeError("targetStart out of bounds");
            if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
            if (end < 0) throw new RangeError("sourceEnd out of bounds");
            end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
            var len = end - start;
            if (this === target && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(targetStart, start, end); else if (this === target && start < targetStart && targetStart < end) for (var i = len - 1; 0 <= i; --i) target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
            return len;
        }, Buffer.prototype.fill = function(val, start, end, encoding) {
            if ("string" == typeof val) {
                if ("string" == typeof start ? (encoding = start, start = 0, end = this.length) : "string" == typeof end && (encoding = end, 
                end = this.length), void 0 !== encoding && "string" != typeof encoding) throw new TypeError("encoding must be a string");
                if ("string" == typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                if (1 === val.length) {
                    var code = val.charCodeAt(0);
                    ("utf8" === encoding && code < 128 || "latin1" === encoding) && (val = code);
                }
            } else "number" == typeof val && (val &= 255);
            if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
            if (end <= start) return this;
            var i;
            if (start >>>= 0, end = void 0 === end ? this.length : end >>> 0, val || (val = 0), 
            "number" == typeof val) for (i = start; i < end; ++i) this[i] = val; else {
                var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding), len = bytes.length;
                if (0 === len) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
            }
            return this;
        };
        var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
        function toHex(n) {
            return n < 16 ? "0" + n.toString(16) : n.toString(16);
        }
        function utf8ToBytes(string, units) {
            var codePoint;
            units = units || 1 / 0;
            for (var length = string.length, leadSurrogate = null, bytes = [], i = 0; i < length; ++i) {
                if (55295 < (codePoint = string.charCodeAt(i)) && codePoint < 57344) {
                    if (!leadSurrogate) {
                        if (56319 < codePoint) {
                            -1 < (units -= 3) && bytes.push(239, 191, 189);
                            continue;
                        }
                        if (i + 1 === length) {
                            -1 < (units -= 3) && bytes.push(239, 191, 189);
                            continue;
                        }
                        leadSurrogate = codePoint;
                        continue;
                    }
                    if (codePoint < 56320) {
                        -1 < (units -= 3) && bytes.push(239, 191, 189), leadSurrogate = codePoint;
                        continue;
                    }
                    codePoint = 65536 + (leadSurrogate - 55296 << 10 | codePoint - 56320);
                } else leadSurrogate && -1 < (units -= 3) && bytes.push(239, 191, 189);
                if (leadSurrogate = null, codePoint < 128) {
                    if ((units -= 1) < 0) break;
                    bytes.push(codePoint);
                } else if (codePoint < 2048) {
                    if ((units -= 2) < 0) break;
                    bytes.push(codePoint >> 6 | 192, 63 & codePoint | 128);
                } else if (codePoint < 65536) {
                    if ((units -= 3) < 0) break;
                    bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                } else {
                    if (!(codePoint < 1114112)) throw new Error("Invalid code point");
                    if ((units -= 4) < 0) break;
                    bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, 63 & codePoint | 128);
                }
            }
            return bytes;
        }
        function base64ToBytes(str) {
            return base64.toByteArray(function(str) {
                if ((str = (str = str.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
                for (;str.length % 4 != 0; ) str += "=";
                return str;
            }(str));
        }
        function blitBuffer(src, dst, offset, length) {
            for (var i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i) dst[i + offset] = src[i];
            return i;
        }
        function isInstance(obj, type) {
            return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name;
        }
        function numberIsNaN(obj) {
            return obj != obj;
        }
    }, {
        "base64-js": 21,
        ieee754: 45
    } ],
    25: [ function(require, module, exports) {
        module.exports = {
            100: "Continue",
            101: "Switching Protocols",
            102: "Processing",
            200: "OK",
            201: "Created",
            202: "Accepted",
            203: "Non-Authoritative Information",
            204: "No Content",
            205: "Reset Content",
            206: "Partial Content",
            207: "Multi-Status",
            208: "Already Reported",
            226: "IM Used",
            300: "Multiple Choices",
            301: "Moved Permanently",
            302: "Found",
            303: "See Other",
            304: "Not Modified",
            305: "Use Proxy",
            307: "Temporary Redirect",
            308: "Permanent Redirect",
            400: "Bad Request",
            401: "Unauthorized",
            402: "Payment Required",
            403: "Forbidden",
            404: "Not Found",
            405: "Method Not Allowed",
            406: "Not Acceptable",
            407: "Proxy Authentication Required",
            408: "Request Timeout",
            409: "Conflict",
            410: "Gone",
            411: "Length Required",
            412: "Precondition Failed",
            413: "Payload Too Large",
            414: "URI Too Long",
            415: "Unsupported Media Type",
            416: "Range Not Satisfiable",
            417: "Expectation Failed",
            418: "I'm a teapot",
            421: "Misdirected Request",
            422: "Unprocessable Entity",
            423: "Locked",
            424: "Failed Dependency",
            425: "Unordered Collection",
            426: "Upgrade Required",
            428: "Precondition Required",
            429: "Too Many Requests",
            431: "Request Header Fields Too Large",
            451: "Unavailable For Legal Reasons",
            500: "Internal Server Error",
            501: "Not Implemented",
            502: "Bad Gateway",
            503: "Service Unavailable",
            504: "Gateway Timeout",
            505: "HTTP Version Not Supported",
            506: "Variant Also Negotiates",
            507: "Insufficient Storage",
            508: "Loop Detected",
            509: "Bandwidth Limit Exceeded",
            510: "Not Extended",
            511: "Network Authentication Required"
        };
    }, {} ],
    26: [ function(require, module, exports) {
        var objectCreate = Object.create || function(proto) {
            var F = function() {};
            return F.prototype = proto, new F();
        }, objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var k in obj) Object.prototype.hasOwnProperty.call(obj, k) && keys.push(k);
            return k;
        }, bind = Function.prototype.bind || function(context) {
            var fn = this;
            return function() {
                return fn.apply(context, arguments);
            };
        };
        function EventEmitter() {
            this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = objectCreate(null), 
            this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }
        ((module.exports = EventEmitter).EventEmitter = EventEmitter).prototype._events = void 0, 
        EventEmitter.prototype._maxListeners = void 0;
        var hasDefineProperty, defaultMaxListeners = 10;
        try {
            var o = {};
            Object.defineProperty && Object.defineProperty(o, "x", {
                value: 0
            }), hasDefineProperty = 0 === o.x;
        } catch (err) {
            hasDefineProperty = !1;
        }
        function $getMaxListeners(that) {
            return void 0 === that._maxListeners ? EventEmitter.defaultMaxListeners : that._maxListeners;
        }
        function _addListener(target, type, listener, prepend) {
            var m, events, existing;
            if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
            if ((events = target._events) ? (events.newListener && (target.emit("newListener", type, listener.listener ? listener.listener : listener), 
            events = target._events), existing = events[type]) : (events = target._events = objectCreate(null), 
            target._eventsCount = 0), existing) {
                if ("function" == typeof existing ? existing = events[type] = prepend ? [ listener, existing ] : [ existing, listener ] : prepend ? existing.unshift(listener) : existing.push(listener), 
                !existing.warned && (m = $getMaxListeners(target)) && 0 < m && existing.length > m) {
                    existing.warned = !0;
                    var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
                    w.name = "MaxListenersExceededWarning", w.emitter = target, w.type = type, w.count = existing.length, 
                    "object" == typeof console && console.warn && console.warn("%s: %s", w.name, w.message);
                }
            } else existing = events[type] = listener, ++target._eventsCount;
            return target;
        }
        function onceWrapper() {
            if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 
            arguments.length) {
              case 0:
                return this.listener.call(this.target);

              case 1:
                return this.listener.call(this.target, arguments[0]);

              case 2:
                return this.listener.call(this.target, arguments[0], arguments[1]);

              case 3:
                return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);

              default:
                for (var args = new Array(arguments.length), i = 0; i < args.length; ++i) args[i] = arguments[i];
                this.listener.apply(this.target, args);
            }
        }
        function _onceWrap(target, type, listener) {
            var state = {
                fired: !1,
                wrapFn: void 0,
                target: target,
                type: type,
                listener: listener
            }, wrapped = bind.call(onceWrapper, state);
            return wrapped.listener = listener, state.wrapFn = wrapped;
        }
        function _listeners(target, type, unwrap) {
            var events = target._events;
            if (!events) return [];
            var evlistener = events[type];
            return evlistener ? "function" == typeof evlistener ? unwrap ? [ evlistener.listener || evlistener ] : [ evlistener ] : unwrap ? function(arr) {
                for (var ret = new Array(arr.length), i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
                return ret;
            }(evlistener) : arrayClone(evlistener, evlistener.length) : [];
        }
        function listenerCount(type) {
            var events = this._events;
            if (events) {
                var evlistener = events[type];
                if ("function" == typeof evlistener) return 1;
                if (evlistener) return evlistener.length;
            }
            return 0;
        }
        function arrayClone(arr, n) {
            for (var copy = new Array(n), i = 0; i < n; ++i) copy[i] = arr[i];
            return copy;
        }
        hasDefineProperty ? Object.defineProperty(EventEmitter, "defaultMaxListeners", {
            enumerable: !0,
            get: function() {
                return defaultMaxListeners;
            },
            set: function(arg) {
                if ("number" != typeof arg || arg < 0 || arg != arg) throw new TypeError('"defaultMaxListeners" must be a positive number');
                defaultMaxListeners = arg;
            }
        }) : EventEmitter.defaultMaxListeners = defaultMaxListeners, EventEmitter.prototype.setMaxListeners = function(n) {
            if ("number" != typeof n || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
            return this._maxListeners = n, this;
        }, EventEmitter.prototype.getMaxListeners = function() {
            return $getMaxListeners(this);
        }, EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, events, doError = "error" === type;
            if (events = this._events) doError = doError && null == events.error; else if (!doError) return !1;
            if (doError) {
                if (1 < arguments.length && (er = arguments[1]), er instanceof Error) throw er;
                var err = new Error('Unhandled "error" event. (' + er + ")");
                throw err.context = er, err;
            }
            if (!(handler = events[type])) return !1;
            var isFn = "function" == typeof handler;
            switch (len = arguments.length) {
              case 1:
                !function(handler, isFn, self) {
                    if (isFn) handler.call(self); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self);
                }(handler, isFn, this);
                break;

              case 2:
                !function(handler, isFn, self, arg1) {
                    if (isFn) handler.call(self, arg1); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1);
                }(handler, isFn, this, arguments[1]);
                break;

              case 3:
                !function(handler, isFn, self, arg1, arg2) {
                    if (isFn) handler.call(self, arg1, arg2); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
                }(handler, isFn, this, arguments[1], arguments[2]);
                break;

              case 4:
                !function(handler, isFn, self, arg1, arg2, arg3) {
                    if (isFn) handler.call(self, arg1, arg2, arg3); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
                }(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                break;

              default:
                for (args = new Array(len - 1), i = 1; i < len; i++) args[i - 1] = arguments[i];
                !function(handler, isFn, self, args) {
                    if (isFn) handler.apply(self, args); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].apply(self, args);
                }(handler, isFn, this, args);
            }
            return !0;
        }, EventEmitter.prototype.on = EventEmitter.prototype.addListener = function(type, listener) {
            return _addListener(this, type, listener, !1);
        }, EventEmitter.prototype.prependListener = function(type, listener) {
            return _addListener(this, type, listener, !0);
        }, EventEmitter.prototype.once = function(type, listener) {
            if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
            return this.on(type, _onceWrap(this, type, listener)), this;
        }, EventEmitter.prototype.prependOnceListener = function(type, listener) {
            if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
            return this.prependListener(type, _onceWrap(this, type, listener)), this;
        }, EventEmitter.prototype.removeListener = function(type, listener) {
            var list, events, position, i, originalListener;
            if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
            if (!(events = this._events)) return this;
            if (!(list = events[type])) return this;
            if (list === listener || list.listener === listener) 0 == --this._eventsCount ? this._events = objectCreate(null) : (delete events[type], 
            events.removeListener && this.emit("removeListener", type, list.listener || listener)); else if ("function" != typeof list) {
                for (position = -1, i = list.length - 1; 0 <= i; i--) if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener, position = i;
                    break;
                }
                if (position < 0) return this;
                0 === position ? list.shift() : function(list, index) {
                    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
                    list.pop();
                }(list, position), 1 === list.length && (events[type] = list[0]), events.removeListener && this.emit("removeListener", type, originalListener || listener);
            }
            return this;
        }, EventEmitter.prototype.removeAllListeners = function(type) {
            var listeners, events, i;
            if (!(events = this._events)) return this;
            if (!events.removeListener) return 0 === arguments.length ? (this._events = objectCreate(null), 
            this._eventsCount = 0) : events[type] && (0 == --this._eventsCount ? this._events = objectCreate(null) : delete events[type]), 
            this;
            if (0 === arguments.length) {
                var key, keys = objectKeys(events);
                for (i = 0; i < keys.length; ++i) "removeListener" !== (key = keys[i]) && this.removeAllListeners(key);
                return this.removeAllListeners("removeListener"), this._events = objectCreate(null), 
                this._eventsCount = 0, this;
            }
            if ("function" == typeof (listeners = events[type])) this.removeListener(type, listeners); else if (listeners) for (i = listeners.length - 1; 0 <= i; i--) this.removeListener(type, listeners[i]);
            return this;
        }, EventEmitter.prototype.listeners = function(type) {
            return _listeners(this, type, !0);
        }, EventEmitter.prototype.rawListeners = function(type) {
            return _listeners(this, type, !1);
        }, EventEmitter.listenerCount = function(emitter, type) {
            return "function" == typeof emitter.listenerCount ? emitter.listenerCount(type) : listenerCount.call(emitter, type);
        }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function() {
            return 0 < this._eventsCount ? Reflect.ownKeys(this._events) : [];
        };
    }, {} ],
    27: [ function(require, module, exports) {
        var http = require("http"), url = require("url"), https = module.exports;
        for (var key in http) http.hasOwnProperty(key) && (https[key] = http[key]);
        function validateParams(params) {
            if ("string" == typeof params && (params = url.parse(params)), params.protocol || (params.protocol = "https:"), 
            "https:" !== params.protocol) throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
            return params;
        }
        https.request = function(params, cb) {
            return params = validateParams(params), http.request.call(this, params, cb);
        }, https.get = function(params, cb) {
            return params = validateParams(params), http.get.call(this, params, cb);
        };
    }, {
        http: 39,
        url: 43
    } ],
    28: [ function(require, module, exports) {
        "use strict";
        var TYPED_OK = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        function _has(obj, key) {
            return Object.prototype.hasOwnProperty.call(obj, key);
        }
        exports.assign = function(obj) {
            for (var sources = Array.prototype.slice.call(arguments, 1); sources.length; ) {
                var source = sources.shift();
                if (source) {
                    if ("object" != typeof source) throw new TypeError(source + "must be non-object");
                    for (var p in source) _has(source, p) && (obj[p] = source[p]);
                }
            }
            return obj;
        }, exports.shrinkBuf = function(buf, size) {
            return buf.length === size ? buf : buf.subarray ? buf.subarray(0, size) : (buf.length = size, 
            buf);
        };
        var fnTyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
                if (src.subarray && dest.subarray) dest.set(src.subarray(src_offs, src_offs + len), dest_offs); else for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
            },
            flattenChunks: function(chunks) {
                var i, l, len, pos, chunk, result;
                for (i = len = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
                for (result = new Uint8Array(len), i = pos = 0, l = chunks.length; i < l; i++) chunk = chunks[i], 
                result.set(chunk, pos), pos += chunk.length;
                return result;
            }
        }, fnUntyped = {
            arraySet: function(dest, src, src_offs, len, dest_offs) {
                for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
            },
            flattenChunks: function(chunks) {
                return [].concat.apply([], chunks);
            }
        };
        exports.setTyped = function(on) {
            on ? (exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, 
            exports.assign(exports, fnTyped)) : (exports.Buf8 = Array, exports.Buf16 = Array, 
            exports.Buf32 = Array, exports.assign(exports, fnUntyped));
        }, exports.setTyped(TYPED_OK);
    }, {} ],
    29: [ function(require, module, exports) {
        "use strict";
        module.exports = function(adler, buf, len, pos) {
            for (var s1 = 65535 & adler | 0, s2 = adler >>> 16 & 65535 | 0, n = 0; 0 !== len; ) {
                for (len -= n = 2e3 < len ? 2e3 : len; s2 = s2 + (s1 = s1 + buf[pos++] | 0) | 0, 
                --n; ) ;
                s1 %= 65521, s2 %= 65521;
            }
            return s1 | s2 << 16 | 0;
        };
    }, {} ],
    30: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8
        };
    }, {} ],
    31: [ function(require, module, exports) {
        "use strict";
        var crcTable = function() {
            for (var c, table = [], n = 0; n < 256; n++) {
                c = n;
                for (var k = 0; k < 8; k++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
                table[n] = c;
            }
            return table;
        }();
        module.exports = function(crc, buf, len, pos) {
            var t = crcTable, end = pos + len;
            crc ^= -1;
            for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[255 & (crc ^ buf[i])];
            return -1 ^ crc;
        };
    }, {} ],
    32: [ function(require, module, exports) {
        "use strict";
        var configuration_table, utils = require("../utils/common"), trees = require("./trees"), adler32 = require("./adler32"), crc32 = require("./crc32"), msg = require("./messages"), Z_NO_FLUSH = 0, Z_FINISH = 4, Z_OK = 0, Z_STREAM_ERROR = -2, Z_DEFAULT_COMPRESSION = -1, Z_FIXED = 4, Z_UNKNOWN = 2, Z_DEFLATED = 8, MAX_MEM_LEVEL = 9, L_CODES = 286, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, MIN_MATCH = 3, MAX_MATCH = 258, MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1, INIT_STATE = 42, BUSY_STATE = 113, BS_NEED_MORE = 1, BS_BLOCK_DONE = 2, BS_FINISH_STARTED = 3, BS_FINISH_DONE = 4;
        function err(strm, errorCode) {
            return strm.msg = msg[errorCode], errorCode;
        }
        function rank(f) {
            return (f << 1) - (4 < f ? 9 : 0);
        }
        function zero(buf) {
            for (var len = buf.length; 0 <= --len; ) buf[len] = 0;
        }
        function flush_pending(strm) {
            var s = strm.state, len = s.pending;
            len > strm.avail_out && (len = strm.avail_out), 0 !== len && (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), 
            strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, 
            s.pending -= len, 0 === s.pending && (s.pending_out = 0));
        }
        function flush_block_only(s, last) {
            trees._tr_flush_block(s, 0 <= s.block_start ? s.block_start : -1, s.strstart - s.block_start, last), 
            s.block_start = s.strstart, flush_pending(s.strm);
        }
        function put_byte(s, b) {
            s.pending_buf[s.pending++] = b;
        }
        function putShortMSB(s, b) {
            s.pending_buf[s.pending++] = b >>> 8 & 255, s.pending_buf[s.pending++] = 255 & b;
        }
        function longest_match(s, cur_match) {
            var match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + MAX_MATCH, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
            s.prev_length >= s.good_match && (chain_length >>= 2), nice_match > s.lookahead && (nice_match = s.lookahead);
            do {
                if (_win[(match = cur_match) + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                    scan += 2, match++;
                    do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                    if (len = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, best_len < len) {
                        if (s.match_start = cur_match, nice_match <= (best_len = len)) break;
                        scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
                    }
                }
            } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
            return best_len <= s.lookahead ? best_len : s.lookahead;
        }
        function fill_window(s) {
            var p, n, m, more, str, strm, buf, start, size, len, _w_size = s.w_size;
            do {
                if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                    for (utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, 
                    s.strstart -= _w_size, s.block_start -= _w_size, p = n = s.hash_size; m = s.head[--p], 
                    s.head[p] = _w_size <= m ? m - _w_size : 0, --n; ) ;
                    for (p = n = _w_size; m = s.prev[--p], s.prev[p] = _w_size <= m ? m - _w_size : 0, 
                    --n; ) ;
                    more += _w_size;
                }
                if (0 === s.strm.avail_in) break;
                if (strm = s.strm, buf = s.window, start = s.strstart + s.lookahead, size = more, 
                len = void 0, len = strm.avail_in, size < len && (len = size), n = 0 === len ? 0 : (strm.avail_in -= len, 
                utils.arraySet(buf, strm.input, strm.next_in, len, start), 1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)), 
                strm.next_in += len, strm.total_in += len, len), s.lookahead += n, s.lookahead + s.insert >= MIN_MATCH) for (str = s.strstart - s.insert, 
                s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, 
                s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, 
                !(s.lookahead + s.insert < MIN_MATCH)); ) ;
            } while (s.lookahead < MIN_LOOKAHEAD && 0 !== s.strm.avail_in);
        }
        function deflate_fast(s, flush) {
            for (var hash_head, bflush; ;) {
                if (s.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                    if (0 === s.lookahead) break;
                }
                if (hash_head = 0, s.lookahead >= MIN_MATCH && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, 
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                0 !== hash_head && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, hash_head)), 
                s.match_length >= MIN_MATCH) if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), 
                s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                    for (s.match_length--; s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart, 
                    0 != --s.match_length; ) ;
                    s.strstart++;
                } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], 
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; else bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                s.lookahead--, s.strstart++;
                if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE;
            }
            return s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, flush === Z_FINISH ? (flush_block_only(s, !0), 
            0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 
            0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
        }
        function deflate_slow(s, flush) {
            for (var hash_head, bflush, max_insert; ;) {
                if (s.lookahead < MIN_LOOKAHEAD) {
                    if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                    if (0 === s.lookahead) break;
                }
                if (hash_head = 0, s.lookahead >= MIN_MATCH && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, 
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, 
                0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, hash_head), 
                s.match_length <= 5 && (1 === s.strategy || s.match_length === MIN_MATCH && 4096 < s.strstart - s.match_start) && (s.match_length = MIN_MATCH - 1)), 
                s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                    for (max_insert = s.strstart + s.lookahead - MIN_MATCH, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), 
                    s.lookahead -= s.prev_length - 1, s.prev_length -= 2; ++s.strstart <= max_insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                    0 != --s.prev_length; ) ;
                    if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, bflush && (flush_block_only(s, !1), 
                    0 === s.strm.avail_out)) return BS_NEED_MORE;
                } else if (s.match_available) {
                    if ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])) && flush_block_only(s, !1), 
                    s.strstart++, s.lookahead--, 0 === s.strm.avail_out) return BS_NEED_MORE;
                } else s.match_available = 1, s.strstart++, s.lookahead--;
            }
            return s.match_available && (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), 
            s.match_available = 0), s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, 
            flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 
            0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
        }
        function Config(good_length, max_lazy, nice_length, max_chain, func) {
            this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, 
            this.max_chain = max_chain, this.func = func;
        }
        function DeflateState() {
            this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, 
            this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, 
            this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, 
            this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, 
            this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, 
            this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, 
            this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, 
            this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, 
            this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(2 * HEAP_SIZE), 
            this.dyn_dtree = new utils.Buf16(2 * (2 * D_CODES + 1)), this.bl_tree = new utils.Buf16(2 * (2 * BL_CODES + 1)), 
            zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, 
            this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), 
            this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, 
            this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), 
            this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, 
            this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function deflateResetKeep(strm) {
            var s;
            return strm && strm.state ? (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, 
            (s = strm.state).pending = 0, s.pending_out = 0, s.wrap < 0 && (s.wrap = -s.wrap), 
            s.status = s.wrap ? INIT_STATE : BUSY_STATE, strm.adler = 2 === s.wrap ? 0 : 1, 
            s.last_flush = Z_NO_FLUSH, trees._tr_init(s), Z_OK) : err(strm, Z_STREAM_ERROR);
        }
        function deflateReset(strm) {
            var s, ret = deflateResetKeep(strm);
            return ret === Z_OK && ((s = strm.state).window_size = 2 * s.w_size, zero(s.head), 
            s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, 
            s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, 
            s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, 
            s.match_available = 0, s.ins_h = 0), ret;
        }
        function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
            if (!strm) return Z_STREAM_ERROR;
            var wrap = 1;
            if (level === Z_DEFAULT_COMPRESSION && (level = 6), windowBits < 0 ? (wrap = 0, 
            windowBits = -windowBits) : 15 < windowBits && (wrap = 2, windowBits -= 16), memLevel < 1 || MAX_MEM_LEVEL < memLevel || method !== Z_DEFLATED || windowBits < 8 || 15 < windowBits || level < 0 || 9 < level || strategy < 0 || Z_FIXED < strategy) return err(strm, Z_STREAM_ERROR);
            8 === windowBits && (windowBits = 9);
            var s = new DeflateState();
            return (strm.state = s).strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, 
            s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, 
            s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), 
            s.window = new utils.Buf8(2 * s.w_size), s.head = new utils.Buf16(s.hash_size), 
            s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, s.pending_buf_size = 4 * s.lit_bufsize, 
            s.pending_buf = new utils.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, 
            s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, s.method = method, 
            deflateReset(strm);
        }
        configuration_table = [ new Config(0, 0, 0, 0, function(s, flush) {
            var max_block_size = 65535;
            for (max_block_size > s.pending_buf_size - 5 && (max_block_size = s.pending_buf_size - 5); ;) {
                if (s.lookahead <= 1) {
                    if (fill_window(s), 0 === s.lookahead && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                    if (0 === s.lookahead) break;
                }
                s.strstart += s.lookahead, s.lookahead = 0;
                var max_start = s.block_start + max_block_size;
                if ((0 === s.strstart || s.strstart >= max_start) && (s.lookahead = s.strstart - max_start, 
                s.strstart = max_start, flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE;
                if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD && (flush_block_only(s, !1), 
                0 === s.strm.avail_out)) return BS_NEED_MORE;
            }
            return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : (s.strstart > s.block_start && (flush_block_only(s, !1), 
            s.strm.avail_out), BS_NEED_MORE);
        }), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ], 
        exports.deflateInit = function(strm, level) {
            return deflateInit2(strm, level, Z_DEFLATED, 15, 8, 0);
        }, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, 
        exports.deflateSetHeader = function(strm, head) {
            return strm && strm.state ? 2 !== strm.state.wrap ? Z_STREAM_ERROR : (strm.state.gzhead = head, 
            Z_OK) : Z_STREAM_ERROR;
        }, exports.deflate = function(strm, flush) {
            var old_flush, s, beg, val;
            if (!strm || !strm.state || 5 < flush || flush < 0) return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
            if (s = strm.state, !strm.output || !strm.input && 0 !== strm.avail_in || 666 === s.status && flush !== Z_FINISH) return err(strm, 0 === strm.avail_out ? -5 : Z_STREAM_ERROR);
            if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, s.status === INIT_STATE) if (2 === s.wrap) strm.adler = 0, 
            put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), 
            put_byte(s, 255 & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), 
            put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, 9 === s.level ? 2 : 2 <= s.strategy || s.level < 2 ? 4 : 0), 
            put_byte(s, 255 & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 255 & s.gzhead.extra.length), 
            put_byte(s, s.gzhead.extra.length >> 8 & 255)), s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)), 
            s.gzindex = 0, s.status = 69) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), 
            put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : 2 <= s.strategy || s.level < 2 ? 4 : 0), 
            put_byte(s, 3), s.status = BUSY_STATE); else {
                var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
                header |= (2 <= s.strategy || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3) << 6, 
                0 !== s.strstart && (header |= 32), header += 31 - header % 31, s.status = BUSY_STATE, 
                putShortMSB(s, header), 0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16), 
                putShortMSB(s, 65535 & strm.adler)), strm.adler = 1;
            }
            if (69 === s.status) if (s.gzhead.extra) {
                for (beg = s.pending; s.gzindex < (65535 & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                flush_pending(strm), beg = s.pending, s.pending !== s.pending_buf_size)); ) put_byte(s, 255 & s.gzhead.extra[s.gzindex]), 
                s.gzindex++;
                s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = 73);
            } else s.status = 73;
            if (73 === s.status) if (s.gzhead.name) {
                beg = s.pending;
                do {
                    if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                        val = 1;
                        break;
                    }
                    put_byte(s, val = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0);
                } while (0 !== val);
                s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                0 === val && (s.gzindex = 0, s.status = 91);
            } else s.status = 91;
            if (91 === s.status) if (s.gzhead.comment) {
                beg = s.pending;
                do {
                    if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                        val = 1;
                        break;
                    }
                    put_byte(s, val = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0);
                } while (0 !== val);
                s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                0 === val && (s.status = 103);
            } else s.status = 103;
            if (103 === s.status && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm), 
            s.pending + 2 <= s.pending_buf_size && (put_byte(s, 255 & strm.adler), put_byte(s, strm.adler >> 8 & 255), 
            strm.adler = 0, s.status = BUSY_STATE)) : s.status = BUSY_STATE), 0 !== s.pending) {
                if (flush_pending(strm), 0 === strm.avail_out) return s.last_flush = -1, Z_OK;
            } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) return err(strm, -5);
            if (666 === s.status && 0 !== strm.avail_in) return err(strm, -5);
            if (0 !== strm.avail_in || 0 !== s.lookahead || flush !== Z_NO_FLUSH && 666 !== s.status) {
                var bstate = 2 === s.strategy ? function(s, flush) {
                    for (var bflush; ;) {
                        if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                            if (flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            break;
                        }
                        if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, 
                        s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE;
                    }
                    return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 
                    0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
                }(s, flush) : 3 === s.strategy ? function(s, flush) {
                    for (var bflush, prev, scan, strend, _win = s.window; ;) {
                        if (s.lookahead <= MAX_MATCH) {
                            if (fill_window(s), s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            if (0 === s.lookahead) break;
                        }
                        if (s.match_length = 0, s.lookahead >= MIN_MATCH && 0 < s.strstart && (prev = _win[scan = s.strstart - 1]) === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                            strend = s.strstart + MAX_MATCH;
                            do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                            s.match_length = MAX_MATCH - (strend - scan), s.match_length > s.lookahead && (s.match_length = s.lookahead);
                        }
                        if (s.match_length >= MIN_MATCH ? (bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH), 
                        s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0) : (bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                        s.lookahead--, s.strstart++), bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE;
                    }
                    return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 
                    0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE;
                }(s, flush) : configuration_table[s.level].func(s, flush);
                if (bstate !== BS_FINISH_STARTED && bstate !== BS_FINISH_DONE || (s.status = 666), 
                bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) return 0 === strm.avail_out && (s.last_flush = -1), 
                Z_OK;
                if (bstate === BS_BLOCK_DONE && (1 === flush ? trees._tr_align(s) : 5 !== flush && (trees._tr_stored_block(s, 0, 0, !1), 
                3 === flush && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, 
                s.insert = 0))), flush_pending(strm), 0 === strm.avail_out)) return s.last_flush = -1, 
                Z_OK;
            }
            return flush !== Z_FINISH ? Z_OK : s.wrap <= 0 ? 1 : (2 === s.wrap ? (put_byte(s, 255 & strm.adler), 
            put_byte(s, strm.adler >> 8 & 255), put_byte(s, strm.adler >> 16 & 255), put_byte(s, strm.adler >> 24 & 255), 
            put_byte(s, 255 & strm.total_in), put_byte(s, strm.total_in >> 8 & 255), put_byte(s, strm.total_in >> 16 & 255), 
            put_byte(s, strm.total_in >> 24 & 255)) : (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 65535 & strm.adler)), 
            flush_pending(strm), 0 < s.wrap && (s.wrap = -s.wrap), 0 !== s.pending ? Z_OK : 1);
        }, exports.deflateEnd = function(strm) {
            var status;
            return strm && strm.state ? (status = strm.state.status) !== INIT_STATE && 69 !== status && 73 !== status && 91 !== status && 103 !== status && status !== BUSY_STATE && 666 !== status ? err(strm, Z_STREAM_ERROR) : (strm.state = null, 
            status === BUSY_STATE ? err(strm, -3) : Z_OK) : Z_STREAM_ERROR;
        }, exports.deflateSetDictionary = function(strm, dictionary) {
            var s, str, n, wrap, avail, next, input, tmpDict, dictLength = dictionary.length;
            if (!strm || !strm.state) return Z_STREAM_ERROR;
            if (2 === (wrap = (s = strm.state).wrap) || 1 === wrap && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR;
            for (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)), 
            s.wrap = 0, dictLength >= s.w_size && (0 === wrap && (zero(s.head), s.strstart = 0, 
            s.block_start = 0, s.insert = 0), tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), 
            dictionary = tmpDict, dictLength = s.w_size), avail = strm.avail_in, next = strm.next_in, 
            input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, 
            fill_window(s); s.lookahead >= MIN_MATCH; ) {
                for (str = s.strstart, n = s.lookahead - (MIN_MATCH - 1); s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, 
                s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, --n; ) ;
                s.strstart = str, s.lookahead = MIN_MATCH - 1, fill_window(s);
            }
            return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, 
            s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, 
            strm.next_in = next, strm.input = input, strm.avail_in = avail, s.wrap = wrap, Z_OK;
        }, exports.deflateInfo = "pako deflate (from Nodeca project)";
    }, {
        "../utils/common": 28,
        "./adler32": 29,
        "./crc32": 31,
        "./messages": 36,
        "./trees": 37
    } ],
    33: [ function(require, module, exports) {
        "use strict";
        module.exports = function(strm, start) {
            var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
            state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), 
            _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), 
            end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, 
            wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, 
            lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, 
            dmask = (1 << state.distbits) - 1;
            top: do {
                bits < 15 && (hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, 
                bits += 8), here = lcode[hold & lmask];
                dolen: for (;;) {
                    if (hold >>>= op = here >>> 24, bits -= op, 0 === (op = here >>> 16 & 255)) output[_out++] = 65535 & here; else {
                        if (!(16 & op)) {
                            if (0 == (64 & op)) {
                                here = lcode[(65535 & here) + (hold & (1 << op) - 1)];
                                continue dolen;
                            }
                            if (32 & op) {
                                state.mode = 12;
                                break top;
                            }
                            strm.msg = "invalid literal/length code", state.mode = 30;
                            break top;
                        }
                        len = 65535 & here, (op &= 15) && (bits < op && (hold += input[_in++] << bits, bits += 8), 
                        len += hold & (1 << op) - 1, hold >>>= op, bits -= op), bits < 15 && (hold += input[_in++] << bits, 
                        bits += 8, hold += input[_in++] << bits, bits += 8), here = dcode[hold & dmask];
                        dodist: for (;;) {
                            if (hold >>>= op = here >>> 24, bits -= op, !(16 & (op = here >>> 16 & 255))) {
                                if (0 == (64 & op)) {
                                    here = dcode[(65535 & here) + (hold & (1 << op) - 1)];
                                    continue dodist;
                                }
                                strm.msg = "invalid distance code", state.mode = 30;
                                break top;
                            }
                            if (dist = 65535 & here, bits < (op &= 15) && (hold += input[_in++] << bits, (bits += 8) < op && (hold += input[_in++] << bits, 
                            bits += 8)), dmax < (dist += hold & (1 << op) - 1)) {
                                strm.msg = "invalid distance too far back", state.mode = 30;
                                break top;
                            }
                            if (hold >>>= op, bits -= op, (op = _out - beg) < dist) {
                                if (whave < (op = dist - op) && state.sane) {
                                    strm.msg = "invalid distance too far back", state.mode = 30;
                                    break top;
                                }
                                if (from_source = s_window, (from = 0) === wnext) {
                                    if (from += wsize - op, op < len) {
                                        for (len -= op; output[_out++] = s_window[from++], --op; ) ;
                                        from = _out - dist, from_source = output;
                                    }
                                } else if (wnext < op) {
                                    if (from += wsize + wnext - op, (op -= wnext) < len) {
                                        for (len -= op; output[_out++] = s_window[from++], --op; ) ;
                                        if (from = 0, wnext < len) {
                                            for (len -= op = wnext; output[_out++] = s_window[from++], --op; ) ;
                                            from = _out - dist, from_source = output;
                                        }
                                    }
                                } else if (from += wnext - op, op < len) {
                                    for (len -= op; output[_out++] = s_window[from++], --op; ) ;
                                    from = _out - dist, from_source = output;
                                }
                                for (;2 < len; ) output[_out++] = from_source[from++], output[_out++] = from_source[from++], 
                                output[_out++] = from_source[from++], len -= 3;
                                len && (output[_out++] = from_source[from++], 1 < len && (output[_out++] = from_source[from++]));
                            } else {
                                for (from = _out - dist; output[_out++] = output[from++], output[_out++] = output[from++], 
                                output[_out++] = output[from++], 2 < (len -= 3); ) ;
                                len && (output[_out++] = output[from++], 1 < len && (output[_out++] = output[from++]));
                            }
                            break;
                        }
                    }
                    break;
                }
            } while (_in < last && _out < end);
            _in -= len = bits >> 3, hold &= (1 << (bits -= len << 3)) - 1, strm.next_in = _in, 
            strm.next_out = _out, strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last), 
            strm.avail_out = _out < end ? end - _out + 257 : 257 - (_out - end), state.hold = hold, 
            state.bits = bits;
        };
    }, {} ],
    34: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common"), adler32 = require("./adler32"), crc32 = require("./crc32"), inflate_fast = require("./inffast"), inflate_table = require("./inftrees"), LENS = 1, DISTS = 2, Z_OK = 0, Z_STREAM_ERROR = -2, HEAD = 1, ENOUGH_LENS = 852, ENOUGH_DISTS = 592;
        function zswap32(q) {
            return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((65280 & q) << 8) + ((255 & q) << 24);
        }
        function InflateState() {
            this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, 
            this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, 
            this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, 
            this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, 
            this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, 
            this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), 
            this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, 
            this.back = 0, this.was = 0;
        }
        function inflateResetKeep(strm) {
            var state;
            return strm && strm.state ? (state = strm.state, strm.total_in = strm.total_out = state.total = 0, 
            strm.msg = "", state.wrap && (strm.adler = 1 & state.wrap), state.mode = HEAD, state.last = 0, 
            state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, 
            state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), 
            state.sane = 1, state.back = -1, Z_OK) : Z_STREAM_ERROR;
        }
        function inflateReset(strm) {
            var state;
            return strm && strm.state ? ((state = strm.state).wsize = 0, state.whave = 0, state.wnext = 0, 
            inflateResetKeep(strm)) : Z_STREAM_ERROR;
        }
        function inflateReset2(strm, windowBits) {
            var wrap, state;
            return strm && strm.state ? (state = strm.state, windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : (wrap = 1 + (windowBits >> 4), 
            windowBits < 48 && (windowBits &= 15)), windowBits && (windowBits < 8 || 15 < windowBits) ? Z_STREAM_ERROR : (null !== state.window && state.wbits !== windowBits && (state.window = null), 
            state.wrap = wrap, state.wbits = windowBits, inflateReset(strm))) : Z_STREAM_ERROR;
        }
        function inflateInit2(strm, windowBits) {
            var ret, state;
            return strm ? (state = new InflateState(), (strm.state = state).window = null, (ret = inflateReset2(strm, windowBits)) !== Z_OK && (strm.state = null), 
            ret) : Z_STREAM_ERROR;
        }
        var lenfix, distfix, virgin = !0;
        function fixedtables(state) {
            if (virgin) {
                var sym;
                for (lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0; sym < 144; ) state.lens[sym++] = 8;
                for (;sym < 256; ) state.lens[sym++] = 9;
                for (;sym < 280; ) state.lens[sym++] = 7;
                for (;sym < 288; ) state.lens[sym++] = 8;
                for (inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                    bits: 9
                }), sym = 0; sym < 32; ) state.lens[sym++] = 5;
                inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                    bits: 5
                }), virgin = !1;
            }
            state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;
        }
        function updatewindow(strm, src, end, copy) {
            var dist, state = strm.state;
            return null === state.window && (state.wsize = 1 << state.wbits, state.wnext = 0, 
            state.whave = 0, state.window = new utils.Buf8(state.wsize)), copy >= state.wsize ? (utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), 
            state.wnext = 0, state.whave = state.wsize) : (copy < (dist = state.wsize - state.wnext) && (dist = copy), 
            utils.arraySet(state.window, src, end - copy, dist, state.wnext), (copy -= dist) ? (utils.arraySet(state.window, src, end - copy, copy, 0), 
            state.wnext = copy, state.whave = state.wsize) : (state.wnext += dist, state.wnext === state.wsize && (state.wnext = 0), 
            state.whave < state.wsize && (state.whave += dist))), 0;
        }
        exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, 
        exports.inflateInit = function(strm) {
            return inflateInit2(strm, 15);
        }, exports.inflateInit2 = inflateInit2, exports.inflate = function(strm, flush) {
            var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, opts, n, here = 0, hbuf = new utils.Buf8(4), order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
            if (!strm || !strm.state || !strm.output || !strm.input && 0 !== strm.avail_in) return Z_STREAM_ERROR;
            12 === (state = strm.state).mode && (state.mode = 13), put = strm.next_out, output = strm.output, 
            left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, 
            hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;
            inf_leave: for (;;) switch (state.mode) {
              case HEAD:
                if (0 === state.wrap) {
                    state.mode = 13;
                    break;
                }
                for (;bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if (2 & state.wrap && 35615 === hold) {
                    hbuf[state.check = 0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), 
                    bits = hold = 0, state.mode = 2;
                    break;
                }
                if (state.flags = 0, state.head && (state.head.done = !1), !(1 & state.wrap) || (((255 & hold) << 8) + (hold >> 8)) % 31) {
                    strm.msg = "incorrect header check", state.mode = 30;
                    break;
                }
                if (8 != (15 & hold)) {
                    strm.msg = "unknown compression method", state.mode = 30;
                    break;
                }
                if (bits -= 4, len = 8 + (15 & (hold >>>= 4)), 0 === state.wbits) state.wbits = len; else if (len > state.wbits) {
                    strm.msg = "invalid window size", state.mode = 30;
                    break;
                }
                state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = 512 & hold ? 10 : 12, 
                bits = hold = 0;
                break;

              case 2:
                for (;bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if (state.flags = hold, 8 != (255 & state.flags)) {
                    strm.msg = "unknown compression method", state.mode = 30;
                    break;
                }
                if (57344 & state.flags) {
                    strm.msg = "unknown header flags set", state.mode = 30;
                    break;
                }
                state.head && (state.head.text = hold >> 8 & 1), 512 & state.flags && (hbuf[0] = 255 & hold, 
                hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), bits = hold = 0, 
                state.mode = 3;

              case 3:
                for (;bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                state.head && (state.head.time = hold), 512 & state.flags && (hbuf[0] = 255 & hold, 
                hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, 
                state.check = crc32(state.check, hbuf, 4, 0)), bits = hold = 0, state.mode = 4;

              case 4:
                for (;bits < 16; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                state.head && (state.head.xflags = 255 & hold, state.head.os = hold >> 8), 512 & state.flags && (hbuf[0] = 255 & hold, 
                hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), bits = hold = 0, 
                state.mode = 5;

              case 5:
                if (1024 & state.flags) {
                    for (;bits < 16; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.length = hold, state.head && (state.head.extra_len = hold), 512 & state.flags && (hbuf[0] = 255 & hold, 
                    hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), bits = hold = 0;
                } else state.head && (state.head.extra = null);
                state.mode = 6;

              case 6:
                if (1024 & state.flags && (have < (copy = state.length) && (copy = have), copy && (state.head && (len = state.head.extra_len - state.length, 
                state.head.extra || (state.head.extra = new Array(state.head.extra_len)), utils.arraySet(state.head.extra, input, next, copy, len)), 
                512 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, 
                next += copy, state.length -= copy), state.length)) break inf_leave;
                state.length = 0, state.mode = 7;

              case 7:
                if (2048 & state.flags) {
                    if (0 === have) break inf_leave;
                    for (copy = 0; len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len)), 
                    len && copy < have; ) ;
                    if (512 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
                    have -= copy, next += copy, len) break inf_leave;
                } else state.head && (state.head.name = null);
                state.length = 0, state.mode = 8;

              case 8:
                if (4096 & state.flags) {
                    if (0 === have) break inf_leave;
                    for (copy = 0; len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len)), 
                    len && copy < have; ) ;
                    if (512 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
                    have -= copy, next += copy, len) break inf_leave;
                } else state.head && (state.head.comment = null);
                state.mode = 9;

              case 9:
                if (512 & state.flags) {
                    for (;bits < 16; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (hold !== (65535 & state.check)) {
                        strm.msg = "header crc mismatch", state.mode = 30;
                        break;
                    }
                    bits = hold = 0;
                }
                state.head && (state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0), strm.adler = state.check = 0, 
                state.mode = 12;
                break;

              case 10:
                for (;bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                strm.adler = state.check = zswap32(hold), bits = hold = 0, state.mode = 11;

              case 11:
                if (0 === state.havedict) return strm.next_out = put, strm.avail_out = left, strm.next_in = next, 
                strm.avail_in = have, state.hold = hold, state.bits = bits, 2;
                strm.adler = state.check = 1, state.mode = 12;

              case 12:
                if (5 === flush || 6 === flush) break inf_leave;

              case 13:
                if (state.last) {
                    hold >>>= 7 & bits, bits -= 7 & bits, state.mode = 27;
                    break;
                }
                for (;bits < 3; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                switch (state.last = 1 & hold, bits -= 1, 3 & (hold >>>= 1)) {
                  case 0:
                    state.mode = 14;
                    break;

                  case 1:
                    if (fixedtables(state), state.mode = 20, 6 === flush) {
                        hold >>>= 2, bits -= 2;
                        break inf_leave;
                    }
                    break;

                  case 2:
                    state.mode = 17;
                    break;

                  case 3:
                    strm.msg = "invalid block type", state.mode = 30;
                }
                hold >>>= 2, bits -= 2;
                break;

              case 14:
                for (hold >>>= 7 & bits, bits -= 7 & bits; bits < 32; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if ((65535 & hold) != (hold >>> 16 ^ 65535)) {
                    strm.msg = "invalid stored block lengths", state.mode = 30;
                    break;
                }
                if (state.length = 65535 & hold, bits = hold = 0, state.mode = 15, 6 === flush) break inf_leave;

              case 15:
                state.mode = 16;

              case 16:
                if (copy = state.length) {
                    if (have < copy && (copy = have), left < copy && (copy = left), 0 === copy) break inf_leave;
                    utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, 
                    put += copy, state.length -= copy;
                    break;
                }
                state.mode = 12;
                break;

              case 17:
                for (;bits < 14; ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if (state.nlen = 257 + (31 & hold), hold >>>= 5, bits -= 5, state.ndist = 1 + (31 & hold), 
                hold >>>= 5, bits -= 5, state.ncode = 4 + (15 & hold), hold >>>= 4, bits -= 4, 286 < state.nlen || 30 < state.ndist) {
                    strm.msg = "too many length or distance symbols", state.mode = 30;
                    break;
                }
                state.have = 0, state.mode = 18;

              case 18:
                for (;state.have < state.ncode; ) {
                    for (;bits < 3; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.lens[order[state.have++]] = 7 & hold, hold >>>= 3, bits -= 3;
                }
                for (;state.have < 19; ) state.lens[order[state.have++]] = 0;
                if (state.lencode = state.lendyn, state.lenbits = 7, opts = {
                    bits: state.lenbits
                }, ret = inflate_table(0, state.lens, 0, 19, state.lencode, 0, state.work, opts), 
                state.lenbits = opts.bits, ret) {
                    strm.msg = "invalid code lengths set", state.mode = 30;
                    break;
                }
                state.have = 0, state.mode = 19;

              case 19:
                for (;state.have < state.nlen + state.ndist; ) {
                    for (;here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 255, 
                    here_val = 65535 & here, !((here_bits = here >>> 24) <= bits); ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (here_val < 16) hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val; else {
                        if (16 === here_val) {
                            for (n = here_bits + 2; bits < n; ) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8;
                            }
                            if (hold >>>= here_bits, bits -= here_bits, 0 === state.have) {
                                strm.msg = "invalid bit length repeat", state.mode = 30;
                                break;
                            }
                            len = state.lens[state.have - 1], copy = 3 + (3 & hold), hold >>>= 2, bits -= 2;
                        } else if (17 === here_val) {
                            for (n = here_bits + 3; bits < n; ) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8;
                            }
                            bits -= here_bits, len = 0, copy = 3 + (7 & (hold >>>= here_bits)), hold >>>= 3, 
                            bits -= 3;
                        } else {
                            for (n = here_bits + 7; bits < n; ) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8;
                            }
                            bits -= here_bits, len = 0, copy = 11 + (127 & (hold >>>= here_bits)), hold >>>= 7, 
                            bits -= 7;
                        }
                        if (state.have + copy > state.nlen + state.ndist) {
                            strm.msg = "invalid bit length repeat", state.mode = 30;
                            break;
                        }
                        for (;copy--; ) state.lens[state.have++] = len;
                    }
                }
                if (30 === state.mode) break;
                if (0 === state.lens[256]) {
                    strm.msg = "invalid code -- missing end-of-block", state.mode = 30;
                    break;
                }
                if (state.lenbits = 9, opts = {
                    bits: state.lenbits
                }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), 
                state.lenbits = opts.bits, ret) {
                    strm.msg = "invalid literal/lengths set", state.mode = 30;
                    break;
                }
                if (state.distbits = 6, state.distcode = state.distdyn, opts = {
                    bits: state.distbits
                }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), 
                state.distbits = opts.bits, ret) {
                    strm.msg = "invalid distances set", state.mode = 30;
                    break;
                }
                if (state.mode = 20, 6 === flush) break inf_leave;

              case 20:
                state.mode = 21;

              case 21:
                if (6 <= have && 258 <= left) {
                    strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
                    state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, 
                    output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, 
                    have = strm.avail_in, hold = state.hold, bits = state.bits, 12 === state.mode && (state.back = -1);
                    break;
                }
                for (state.back = 0; here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 255, 
                here_val = 65535 & here, !((here_bits = here >>> 24) <= bits); ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if (here_op && 0 == (240 & here_op)) {
                    for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 255, 
                    here_val = 65535 & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
                }
                if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, 
                0 === here_op) {
                    state.mode = 26;
                    break;
                }
                if (32 & here_op) {
                    state.back = -1, state.mode = 12;
                    break;
                }
                if (64 & here_op) {
                    strm.msg = "invalid literal/length code", state.mode = 30;
                    break;
                }
                state.extra = 15 & here_op, state.mode = 22;

              case 22:
                if (state.extra) {
                    for (n = state.extra; bits < n; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
                    state.back += state.extra;
                }
                state.was = state.length, state.mode = 23;

              case 23:
                for (;here_op = (here = state.distcode[hold & (1 << state.distbits) - 1]) >>> 16 & 255, 
                here_val = 65535 & here, !((here_bits = here >>> 24) <= bits); ) {
                    if (0 === have) break inf_leave;
                    have--, hold += input[next++] << bits, bits += 8;
                }
                if (0 == (240 & here_op)) {
                    for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 255, 
                    here_val = 65535 & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
                }
                if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, 64 & here_op) {
                    strm.msg = "invalid distance code", state.mode = 30;
                    break;
                }
                state.offset = here_val, state.extra = 15 & here_op, state.mode = 24;

              case 24:
                if (state.extra) {
                    for (n = state.extra; bits < n; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
                    state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                    strm.msg = "invalid distance too far back", state.mode = 30;
                    break;
                }
                state.mode = 25;

              case 25:
                if (0 === left) break inf_leave;
                if (copy = _out - left, state.offset > copy) {
                    if ((copy = state.offset - copy) > state.whave && state.sane) {
                        strm.msg = "invalid distance too far back", state.mode = 30;
                        break;
                    }
                    copy > state.wnext ? (copy -= state.wnext, from = state.wsize - copy) : from = state.wnext - copy, 
                    copy > state.length && (copy = state.length), from_source = state.window;
                } else from_source = output, from = put - state.offset, copy = state.length;
                for (left < copy && (copy = left), left -= copy, state.length -= copy; output[put++] = from_source[from++], 
                --copy; ) ;
                0 === state.length && (state.mode = 21);
                break;

              case 26:
                if (0 === left) break inf_leave;
                output[put++] = state.length, left--, state.mode = 21;
                break;

              case 27:
                if (state.wrap) {
                    for (;bits < 32; ) {
                        if (0 === have) break inf_leave;
                        have--, hold |= input[next++] << bits, bits += 8;
                    }
                    if (_out -= left, strm.total_out += _out, state.total += _out, _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)), 
                    _out = left, (state.flags ? hold : zswap32(hold)) !== state.check) {
                        strm.msg = "incorrect data check", state.mode = 30;
                        break;
                    }
                    bits = hold = 0;
                }
                state.mode = 28;

              case 28:
                if (state.wrap && state.flags) {
                    for (;bits < 32; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (hold !== (4294967295 & state.total)) {
                        strm.msg = "incorrect length check", state.mode = 30;
                        break;
                    }
                    bits = hold = 0;
                }
                state.mode = 29;

              case 29:
                ret = 1;
                break inf_leave;

              case 30:
                ret = -3;
                break inf_leave;

              case 31:
                return -4;

              case 32:
              default:
                return Z_STREAM_ERROR;
            }
            return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
            state.hold = hold, state.bits = bits, (state.wsize || _out !== strm.avail_out && state.mode < 30 && (state.mode < 27 || 4 !== flush)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out) ? (state.mode = 31, 
            -4) : (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, 
            state.total += _out, state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)), 
            strm.data_type = state.bits + (state.last ? 64 : 0) + (12 === state.mode ? 128 : 0) + (20 === state.mode || 15 === state.mode ? 256 : 0), 
            (0 === _in && 0 === _out || 4 === flush) && ret === Z_OK && (ret = -5), ret);
        }, exports.inflateEnd = function(strm) {
            if (!strm || !strm.state) return Z_STREAM_ERROR;
            var state = strm.state;
            return state.window && (state.window = null), strm.state = null, Z_OK;
        }, exports.inflateGetHeader = function(strm, head) {
            var state;
            return strm && strm.state ? 0 == (2 & (state = strm.state).wrap) ? Z_STREAM_ERROR : ((state.head = head).done = !1, 
            Z_OK) : Z_STREAM_ERROR;
        }, exports.inflateSetDictionary = function(strm, dictionary) {
            var state, dictLength = dictionary.length;
            return strm && strm.state ? 0 !== (state = strm.state).wrap && 11 !== state.mode ? Z_STREAM_ERROR : 11 === state.mode && adler32(1, dictionary, dictLength, 0) !== state.check ? -3 : updatewindow(strm, dictionary, dictLength, dictLength) ? (state.mode = 31, 
            -4) : (state.havedict = 1, Z_OK) : Z_STREAM_ERROR;
        }, exports.inflateInfo = "pako inflate (from Nodeca project)";
    }, {
        "../utils/common": 28,
        "./adler32": 29,
        "./crc32": 31,
        "./inffast": 33,
        "./inftrees": 35
    } ],
    35: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common"), lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ], lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ], dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ], dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ];
        module.exports = function(type, lens, lens_index, codes, table, table_index, work, opts) {
            var incr, fill, low, mask, next, end, here_bits, here_op, here_val, bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, base = null, base_index = 0, count = new utils.Buf16(16), offs = new utils.Buf16(16), extra = null, extra_index = 0;
            for (len = 0; len <= 15; len++) count[len] = 0;
            for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
            for (root = bits, max = 15; 1 <= max && 0 === count[max]; max--) ;
            if (max < root && (root = max), 0 === max) return table[table_index++] = 20971520, 
            table[table_index++] = 20971520, opts.bits = 1, 0;
            for (min = 1; min < max && 0 === count[min]; min++) ;
            for (root < min && (root = min), len = left = 1; len <= 15; len++) if (left <<= 1, 
            (left -= count[len]) < 0) return -1;
            if (0 < left && (0 === type || 1 !== max)) return -1;
            for (offs[1] = 0, len = 1; len < 15; len++) offs[len + 1] = offs[len] + count[len];
            for (sym = 0; sym < codes; sym++) 0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
            if (0 === type ? (base = extra = work, end = 19) : 1 === type ? (base = lbase, base_index -= 257, 
            extra = lext, extra_index -= 257, end = 256) : (base = dbase, extra = dext, end = -1), 
            len = min, next = table_index, drop = sym = huff = 0, low = -1, mask = (used = 1 << (curr = root)) - 1, 
            1 === type && 852 < used || 2 === type && 592 < used) return 1;
            for (;;) {
                for (here_bits = len - drop, work[sym] < end ? (here_op = 0, here_val = work[sym]) : work[sym] > end ? (here_op = extra[extra_index + work[sym]], 
                here_val = base[base_index + work[sym]]) : (here_op = 96, here_val = 0), incr = 1 << len - drop, 
                min = fill = 1 << curr; table[next + (huff >> drop) + (fill -= incr)] = here_bits << 24 | here_op << 16 | here_val | 0, 
                0 !== fill; ) ;
                for (incr = 1 << len - 1; huff & incr; ) incr >>= 1;
                if (0 !== incr ? (huff &= incr - 1, huff += incr) : huff = 0, sym++, 0 == --count[len]) {
                    if (len === max) break;
                    len = lens[lens_index + work[sym]];
                }
                if (root < len && (huff & mask) !== low) {
                    for (0 === drop && (drop = root), next += min, left = 1 << (curr = len - drop); curr + drop < max && !((left -= count[curr + drop]) <= 0); ) curr++, 
                    left <<= 1;
                    if (used += 1 << curr, 1 === type && 852 < used || 2 === type && 592 < used) return 1;
                    table[low = huff & mask] = root << 24 | curr << 16 | next - table_index | 0;
                }
            }
            return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0), opts.bits = root, 
            0;
        };
    }, {
        "../utils/common": 28
    } ],
    36: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version"
        };
    }, {} ],
    37: [ function(require, module, exports) {
        "use strict";
        var utils = require("../utils/common"), Z_BINARY = 0, Z_TEXT = 1;
        function zero(buf) {
            for (var len = buf.length; 0 <= --len; ) buf[len] = 0;
        }
        var STORED_BLOCK = 0, LENGTH_CODES = 29, LITERALS = 256, L_CODES = LITERALS + 1 + LENGTH_CODES, D_CODES = 30, BL_CODES = 19, HEAP_SIZE = 2 * L_CODES + 1, MAX_BITS = 15, Buf_size = 16, MAX_BL_BITS = 7, END_BLOCK = 256, REP_3_6 = 16, REPZ_3_10 = 17, REPZ_11_138 = 18, extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ], extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ], bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], static_ltree = new Array(2 * (L_CODES + 2));
        zero(static_ltree);
        var static_dtree = new Array(2 * D_CODES);
        zero(static_dtree);
        var _dist_code = new Array(512);
        zero(_dist_code);
        var _length_code = new Array(256);
        zero(_length_code);
        var base_length = new Array(LENGTH_CODES);
        zero(base_length);
        var static_l_desc, static_d_desc, static_bl_desc, base_dist = new Array(D_CODES);
        function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
            this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, 
            this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;
        }
        function TreeDesc(dyn_tree, stat_desc) {
            this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;
        }
        function d_code(dist) {
            return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
        }
        function put_short(s, w) {
            s.pending_buf[s.pending++] = 255 & w, s.pending_buf[s.pending++] = w >>> 8 & 255;
        }
        function send_bits(s, value, length) {
            s.bi_valid > Buf_size - length ? (s.bi_buf |= value << s.bi_valid & 65535, put_short(s, s.bi_buf), 
            s.bi_buf = value >> Buf_size - s.bi_valid, s.bi_valid += length - Buf_size) : (s.bi_buf |= value << s.bi_valid & 65535, 
            s.bi_valid += length);
        }
        function send_code(s, c, tree) {
            send_bits(s, tree[2 * c], tree[2 * c + 1]);
        }
        function bi_reverse(code, len) {
            for (var res = 0; res |= 1 & code, code >>>= 1, res <<= 1, 0 < --len; ) ;
            return res >>> 1;
        }
        function gen_codes(tree, max_code, bl_count) {
            var bits, n, next_code = new Array(MAX_BITS + 1), code = 0;
            for (bits = 1; bits <= MAX_BITS; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
            for (n = 0; n <= max_code; n++) {
                var len = tree[2 * n + 1];
                0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len));
            }
        }
        function init_block(s) {
            var n;
            for (n = 0; n < L_CODES; n++) s.dyn_ltree[2 * n] = 0;
            for (n = 0; n < D_CODES; n++) s.dyn_dtree[2 * n] = 0;
            for (n = 0; n < BL_CODES; n++) s.bl_tree[2 * n] = 0;
            s.dyn_ltree[2 * END_BLOCK] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;
        }
        function bi_windup(s) {
            8 < s.bi_valid ? put_short(s, s.bi_buf) : 0 < s.bi_valid && (s.pending_buf[s.pending++] = s.bi_buf), 
            s.bi_buf = 0, s.bi_valid = 0;
        }
        function smaller(tree, n, m, depth) {
            var _n2 = 2 * n, _m2 = 2 * m;
            return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
        }
        function pqdownheap(s, tree, k) {
            for (var v = s.heap[k], j = k << 1; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++, 
            !smaller(tree, v, s.heap[j], s.depth)); ) s.heap[k] = s.heap[j], k = j, j <<= 1;
            s.heap[k] = v;
        }
        function compress_block(s, ltree, dtree) {
            var dist, lc, code, extra, lx = 0;
            if (0 !== s.last_lit) for (;dist = s.pending_buf[s.d_buf + 2 * lx] << 8 | s.pending_buf[s.d_buf + 2 * lx + 1], 
            lc = s.pending_buf[s.l_buf + lx], lx++, 0 === dist ? send_code(s, lc, ltree) : (send_code(s, (code = _length_code[lc]) + LITERALS + 1, ltree), 
            0 !== (extra = extra_lbits[code]) && send_bits(s, lc -= base_length[code], extra), 
            send_code(s, code = d_code(--dist), dtree), 0 !== (extra = extra_dbits[code]) && send_bits(s, dist -= base_dist[code], extra)), 
            lx < s.last_lit; ) ;
            send_code(s, END_BLOCK, ltree);
        }
        function build_tree(s, desc) {
            var n, m, node, tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, max_code = -1;
            for (s.heap_len = 0, s.heap_max = HEAP_SIZE, n = 0; n < elems; n++) 0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n, 
            s.depth[n] = 0) : tree[2 * n + 1] = 0;
            for (;s.heap_len < 2; ) tree[2 * (node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0)] = 1, 
            s.depth[node] = 0, s.opt_len--, has_stree && (s.static_len -= stree[2 * node + 1]);
            for (desc.max_code = max_code, n = s.heap_len >> 1; 1 <= n; n--) pqdownheap(s, tree, n);
            for (node = elems; n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), 
            m = s.heap[1], s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[2 * node] = tree[2 * n] + tree[2 * m], 
            s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1, tree[2 * n + 1] = tree[2 * m + 1] = node, 
            s.heap[1] = node++, pqdownheap(s, tree, 1), 2 <= s.heap_len; ) ;
            s.heap[--s.heap_max] = s.heap[1], function(s, desc) {
                var h, n, m, bits, xbits, f, tree = desc.dyn_tree, max_code = desc.max_code, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, overflow = 0;
                for (bits = 0; bits <= MAX_BITS; bits++) s.bl_count[bits] = 0;
                for (tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1; h < HEAP_SIZE; h++) max_length < (bits = tree[2 * tree[2 * (n = s.heap[h]) + 1] + 1] + 1) && (bits = max_length, 
                overflow++), tree[2 * n + 1] = bits, max_code < n || (s.bl_count[bits]++, xbits = 0, 
                base <= n && (xbits = extra[n - base]), f = tree[2 * n], s.opt_len += f * (bits + xbits), 
                has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                if (0 !== overflow) {
                    do {
                        for (bits = max_length - 1; 0 === s.bl_count[bits]; ) bits--;
                        s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;
                    } while (0 < overflow);
                    for (bits = max_length; 0 !== bits; bits--) for (n = s.bl_count[bits]; 0 !== n; ) max_code < (m = s.heap[--h]) || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m], 
                    tree[2 * m + 1] = bits), n--);
                }
            }(s, desc), gen_codes(tree, max_code, s.bl_count);
        }
        function scan_tree(s, tree, max_code) {
            var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
            for (0 === nextlen && (max_count = 138, min_count = 3), tree[2 * (max_code + 1) + 1] = 65535, 
            n = 0; n <= max_code; n++) curlen = nextlen, nextlen = tree[2 * (n + 1) + 1], ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++, 
            s.bl_tree[2 * REP_3_6]++) : count <= 10 ? s.bl_tree[2 * REPZ_3_10]++ : s.bl_tree[2 * REPZ_11_138]++, 
            prevlen = curlen, (count = 0) === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
            min_count = 3) : (max_count = 7, min_count = 4));
        }
        function send_tree(s, tree, max_code) {
            var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
            for (0 === nextlen && (max_count = 138, min_count = 3), n = 0; n <= max_code; n++) if (curlen = nextlen, 
            nextlen = tree[2 * (n + 1) + 1], !(++count < max_count && curlen === nextlen)) {
                if (count < min_count) for (;send_code(s, curlen, s.bl_tree), 0 != --count; ) ; else 0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree), 
                count--), send_code(s, REP_3_6, s.bl_tree), send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, REPZ_3_10, s.bl_tree), 
                send_bits(s, count - 3, 3)) : (send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, count - 11, 7));
                prevlen = curlen, (count = 0) === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
                min_count = 3) : (max_count = 7, min_count = 4);
            }
        }
        zero(base_dist);
        var static_init_done = !1;
        function _tr_stored_block(s, buf, stored_len, last) {
            send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3), function(s, buf, len, header) {
                bi_windup(s), header && (put_short(s, len), put_short(s, ~len)), utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), 
                s.pending += len;
            }(s, buf, stored_len, !0);
        }
        exports._tr_init = function(s) {
            static_init_done || (function() {
                var n, bits, length, code, dist, bl_count = new Array(MAX_BITS + 1);
                for (code = length = 0; code < LENGTH_CODES - 1; code++) for (base_length[code] = length, 
                n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
                for (_length_code[length - 1] = code, code = dist = 0; code < 16; code++) for (base_dist[code] = dist, 
                n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
                for (dist >>= 7; code < D_CODES; code++) for (base_dist[code] = dist << 7, n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
                for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
                for (n = 0; n <= 143; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                for (;n <= 255; ) static_ltree[2 * n + 1] = 9, n++, bl_count[9]++;
                for (;n <= 279; ) static_ltree[2 * n + 1] = 7, n++, bl_count[7]++;
                for (;n <= 287; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                for (gen_codes(static_ltree, L_CODES + 1, bl_count), n = 0; n < D_CODES; n++) static_dtree[2 * n + 1] = 5, 
                static_dtree[2 * n] = bi_reverse(n, 5);
                static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), 
                static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), 
                static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
            }(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), 
            s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), 
            s.bi_buf = 0, s.bi_valid = 0, init_block(s);
        }, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = function(s, buf, stored_len, last) {
            var opt_lenb, static_lenb, max_blindex = 0;
            0 < s.level ? (2 === s.strm.data_type && (s.strm.data_type = function(s) {
                var n, black_mask = 4093624447;
                for (n = 0; n <= 31; n++, black_mask >>>= 1) if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return Z_BINARY;
                if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26]) return Z_TEXT;
                for (n = 32; n < LITERALS; n++) if (0 !== s.dyn_ltree[2 * n]) return Z_TEXT;
                return Z_BINARY;
            }(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = function(s) {
                var max_blindex;
                for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), 
                build_tree(s, s.bl_desc), max_blindex = BL_CODES - 1; 3 <= max_blindex && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--) ;
                return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;
            }(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, (static_lenb = s.static_len + 3 + 7 >>> 3) <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5, 
            stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3), 
            compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3), 
            function(s, lcodes, dcodes, blcodes) {
                var rank;
                for (send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4), 
                rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);
            }(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), 
            init_block(s), last && bi_windup(s);
        }, exports._tr_tally = function(s, dist, lc) {
            return s.pending_buf[s.d_buf + 2 * s.last_lit] = dist >>> 8 & 255, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 255 & dist, 
            s.pending_buf[s.l_buf + s.last_lit] = 255 & lc, s.last_lit++, 0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++, 
            dist--, s.dyn_ltree[2 * (_length_code[lc] + LITERALS + 1)]++, s.dyn_dtree[2 * d_code(dist)]++), 
            s.last_lit === s.lit_bufsize - 1;
        }, exports._tr_align = function(s) {
            send_bits(s, 2, 3), send_code(s, END_BLOCK, static_ltree), function(s) {
                16 === s.bi_valid ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : 8 <= s.bi_valid && (s.pending_buf[s.pending++] = 255 & s.bi_buf, 
                s.bi_buf >>= 8, s.bi_valid -= 8);
            }(s);
        };
    }, {
        "../utils/common": 28
    } ],
    38: [ function(require, module, exports) {
        "use strict";
        module.exports = function() {
            this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, 
            this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, 
            this.data_type = 2, this.adler = 0;
        };
    }, {} ],
    39: [ function(require, module, exports) {
        (function(global) {
            var ClientRequest = require("./lib/request"), response = require("./lib/response"), extend = require("xtend"), statusCodes = require("builtin-status-codes"), url = require("url"), http = exports;
            http.request = function(opts, cb) {
                opts = "string" == typeof opts ? url.parse(opts) : extend(opts);
                var defaultProtocol = -1 === global.location.protocol.search(/^https?:$/) ? "http:" : "", protocol = opts.protocol || defaultProtocol, host = opts.hostname || opts.host, port = opts.port, path = opts.path || "/";
                host && -1 !== host.indexOf(":") && (host = "[" + host + "]"), opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path, 
                opts.method = (opts.method || "GET").toUpperCase(), opts.headers = opts.headers || {};
                var req = new ClientRequest(opts);
                return cb && req.on("response", cb), req;
            }, http.get = function(opts, cb) {
                var req = http.request(opts, cb);
                return req.end(), req;
            }, http.ClientRequest = ClientRequest, http.IncomingMessage = response.IncomingMessage, 
            http.Agent = function() {}, http.Agent.defaultMaxSockets = 4, http.globalAgent = new http.Agent(), 
            http.STATUS_CODES = statusCodes, http.METHODS = [ "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE" ];
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "./lib/request": 41,
        "./lib/response": 42,
        "builtin-status-codes": 25,
        url: 43,
        xtend: 111
    } ],
    40: [ function(require, module, exports) {
        (function(global) {
            exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream), exports.writableStream = isFunction(global.WritableStream), 
            exports.abortController = isFunction(global.AbortController), exports.blobConstructor = !1;
            try {
                new Blob([ new ArrayBuffer(1) ]), exports.blobConstructor = !0;
            } catch (e) {}
            var xhr;
            function getXHR() {
                if (void 0 !== xhr) return xhr;
                if (global.XMLHttpRequest) {
                    xhr = new global.XMLHttpRequest();
                    try {
                        xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
                    } catch (e) {
                        xhr = null;
                    }
                } else xhr = null;
                return xhr;
            }
            function checkTypeSupport(type) {
                var xhr = getXHR();
                if (!xhr) return !1;
                try {
                    return xhr.responseType = type, xhr.responseType === type;
                } catch (e) {}
                return !1;
            }
            var haveArrayBuffer = void 0 !== global.ArrayBuffer, haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice);
            function isFunction(value) {
                return "function" == typeof value;
            }
            exports.arraybuffer = exports.fetch || haveArrayBuffer && checkTypeSupport("arraybuffer"), 
            exports.msstream = !exports.fetch && haveSlice && checkTypeSupport("ms-stream"), 
            exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer && checkTypeSupport("moz-chunked-arraybuffer"), 
            exports.overrideMimeType = exports.fetch || !!getXHR() && isFunction(getXHR().overrideMimeType), 
            exports.vbArray = isFunction(global.VBArray), xhr = null;
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ],
    41: [ function(require, module, exports) {
        (function(process, global, Buffer) {
            var capability = require("./capability"), inherits = require("inherits"), response = require("./response"), stream = require("readable-stream"), toArrayBuffer = require("to-arraybuffer"), IncomingMessage = response.IncomingMessage, rStates = response.readyStates;
            var ClientRequest = module.exports = function(opts) {
                var preferBinary, self = this;
                stream.Writable.call(self), self._opts = opts, self._body = [], self._headers = {}, 
                opts.auth && self.setHeader("Authorization", "Basic " + new Buffer(opts.auth).toString("base64")), 
                Object.keys(opts.headers).forEach(function(name) {
                    self.setHeader(name, opts.headers[name]);
                });
                var useFetch = !0;
                if ("disable-fetch" === opts.mode || "requestTimeout" in opts && !capability.abortController) preferBinary = !(useFetch = !1); else if ("prefer-streaming" === opts.mode) preferBinary = !1; else if ("allow-wrong-content-type" === opts.mode) preferBinary = !capability.overrideMimeType; else {
                    if (opts.mode && "default" !== opts.mode && "prefer-fast" !== opts.mode) throw new Error("Invalid value for opts.mode");
                    preferBinary = !0;
                }
                self._mode = function(preferBinary, useFetch) {
                    return capability.fetch && useFetch ? "fetch" : capability.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : capability.msstream ? "ms-stream" : capability.arraybuffer && preferBinary ? "arraybuffer" : capability.vbArray && preferBinary ? "text:vbarray" : "text";
                }(preferBinary, useFetch), self._fetchTimer = null, self.on("finish", function() {
                    self._onFinish();
                });
            };
            inherits(ClientRequest, stream.Writable), ClientRequest.prototype.setHeader = function(name, value) {
                var lowerName = name.toLowerCase();
                -1 === unsafeHeaders.indexOf(lowerName) && (this._headers[lowerName] = {
                    name: name,
                    value: value
                });
            }, ClientRequest.prototype.getHeader = function(name) {
                var header = this._headers[name.toLowerCase()];
                return header ? header.value : null;
            }, ClientRequest.prototype.removeHeader = function(name) {
                delete this._headers[name.toLowerCase()];
            }, ClientRequest.prototype._onFinish = function() {
                var self = this;
                if (!self._destroyed) {
                    var opts = self._opts, headersObj = self._headers, body = null;
                    "GET" !== opts.method && "HEAD" !== opts.method && (body = capability.arraybuffer ? toArrayBuffer(Buffer.concat(self._body)) : capability.blobConstructor ? new global.Blob(self._body.map(function(buffer) {
                        return toArrayBuffer(buffer);
                    }), {
                        type: (headersObj["content-type"] || {}).value || ""
                    }) : Buffer.concat(self._body).toString());
                    var headersList = [];
                    if (Object.keys(headersObj).forEach(function(keyName) {
                        var name = headersObj[keyName].name, value = headersObj[keyName].value;
                        Array.isArray(value) ? value.forEach(function(v) {
                            headersList.push([ name, v ]);
                        }) : headersList.push([ name, value ]);
                    }), "fetch" === self._mode) {
                        var signal = null;
                        if (capability.abortController) {
                            var controller = new AbortController();
                            signal = controller.signal, self._fetchAbortController = controller, "requestTimeout" in opts && 0 !== opts.requestTimeout && (self._fetchTimer = global.setTimeout(function() {
                                self.emit("requestTimeout"), self._fetchAbortController && self._fetchAbortController.abort();
                            }, opts.requestTimeout));
                        }
                        global.fetch(self._opts.url, {
                            method: self._opts.method,
                            headers: headersList,
                            body: body || void 0,
                            mode: "cors",
                            credentials: opts.withCredentials ? "include" : "same-origin",
                            signal: signal
                        }).then(function(response) {
                            self._fetchResponse = response, self._connect();
                        }, function(reason) {
                            global.clearTimeout(self._fetchTimer), self._destroyed || self.emit("error", reason);
                        });
                    } else {
                        var xhr = self._xhr = new global.XMLHttpRequest();
                        try {
                            xhr.open(self._opts.method, self._opts.url, !0);
                        } catch (err) {
                            return void process.nextTick(function() {
                                self.emit("error", err);
                            });
                        }
                        "responseType" in xhr && (xhr.responseType = self._mode.split(":")[0]), "withCredentials" in xhr && (xhr.withCredentials = !!opts.withCredentials), 
                        "text" === self._mode && "overrideMimeType" in xhr && xhr.overrideMimeType("text/plain; charset=x-user-defined"), 
                        "requestTimeout" in opts && (xhr.timeout = opts.requestTimeout, xhr.ontimeout = function() {
                            self.emit("requestTimeout");
                        }), headersList.forEach(function(header) {
                            xhr.setRequestHeader(header[0], header[1]);
                        }), self._response = null, xhr.onreadystatechange = function() {
                            switch (xhr.readyState) {
                              case rStates.LOADING:
                              case rStates.DONE:
                                self._onXHRProgress();
                            }
                        }, "moz-chunked-arraybuffer" === self._mode && (xhr.onprogress = function() {
                            self._onXHRProgress();
                        }), xhr.onerror = function() {
                            self._destroyed || self.emit("error", new Error("XHR error"));
                        };
                        try {
                            xhr.send(body);
                        } catch (err) {
                            return void process.nextTick(function() {
                                self.emit("error", err);
                            });
                        }
                    }
                }
            }, ClientRequest.prototype._onXHRProgress = function() {
                (function(xhr) {
                    try {
                        var status = xhr.status;
                        return null !== status && 0 !== status;
                    } catch (e) {
                        return !1;
                    }
                })(this._xhr) && !this._destroyed && (this._response || this._connect(), this._response._onXHRProgress());
            }, ClientRequest.prototype._connect = function() {
                var self = this;
                self._destroyed || (self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer), 
                self._response.on("error", function(err) {
                    self.emit("error", err);
                }), self.emit("response", self._response));
            }, ClientRequest.prototype._write = function(chunk, encoding, cb) {
                this._body.push(chunk), cb();
            }, ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
                this._destroyed = !0, global.clearTimeout(this._fetchTimer), this._response && (this._response._destroyed = !0), 
                this._xhr ? this._xhr.abort() : this._fetchAbortController && this._fetchAbortController.abort();
            }, ClientRequest.prototype.end = function(data, encoding, cb) {
                "function" == typeof data && (cb = data, data = void 0), stream.Writable.prototype.end.call(this, data, encoding, cb);
            }, ClientRequest.prototype.flushHeaders = function() {}, ClientRequest.prototype.setTimeout = function() {}, 
            ClientRequest.prototype.setNoDelay = function() {}, ClientRequest.prototype.setSocketKeepAlive = function() {};
            var unsafeHeaders = [ "accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via" ];
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, require("buffer").Buffer);
    }, {
        "./capability": 40,
        "./response": 42,
        _process: 56,
        buffer: 24,
        inherits: 46,
        "readable-stream": 71,
        "to-arraybuffer": 79
    } ],
    42: [ function(require, module, exports) {
        (function(process, global, Buffer) {
            var capability = require("./capability"), inherits = require("inherits"), stream = require("readable-stream"), rStates = exports.readyStates = {
                UNSENT: 0,
                OPENED: 1,
                HEADERS_RECEIVED: 2,
                LOADING: 3,
                DONE: 4
            }, IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, fetchTimer) {
                var self = this;
                if (stream.Readable.call(self), self._mode = mode, self.headers = {}, self.rawHeaders = [], 
                self.trailers = {}, self.rawTrailers = [], self.on("end", function() {
                    process.nextTick(function() {
                        self.emit("close");
                    });
                }), "fetch" === mode) {
                    if (self._fetchResponse = response, self.url = response.url, self.statusCode = response.status, 
                    self.statusMessage = response.statusText, response.headers.forEach(function(header, key) {
                        self.headers[key.toLowerCase()] = header, self.rawHeaders.push(key, header);
                    }), capability.writableStream) {
                        var writable = new WritableStream({
                            write: function(chunk) {
                                return new Promise(function(resolve, reject) {
                                    self._destroyed ? reject() : self.push(new Buffer(chunk)) ? resolve() : self._resumeFetch = resolve;
                                });
                            },
                            close: function() {
                                global.clearTimeout(fetchTimer), self._destroyed || self.push(null);
                            },
                            abort: function(err) {
                                self._destroyed || self.emit("error", err);
                            }
                        });
                        try {
                            return void response.body.pipeTo(writable).catch(function(err) {
                                global.clearTimeout(fetchTimer), self._destroyed || self.emit("error", err);
                            });
                        } catch (e) {}
                    }
                    var reader = response.body.getReader();
                    !function read() {
                        reader.read().then(function(result) {
                            if (!self._destroyed) {
                                if (result.done) return global.clearTimeout(fetchTimer), void self.push(null);
                                self.push(new Buffer(result.value)), read();
                            }
                        }).catch(function(err) {
                            global.clearTimeout(fetchTimer), self._destroyed || self.emit("error", err);
                        });
                    }();
                } else {
                    if (self._xhr = xhr, self._pos = 0, self.url = xhr.responseURL, self.statusCode = xhr.status, 
                    self.statusMessage = xhr.statusText, xhr.getAllResponseHeaders().split(/\r?\n/).forEach(function(header) {
                        var matches = header.match(/^([^:]+):\s*(.*)/);
                        if (matches) {
                            var key = matches[1].toLowerCase();
                            "set-cookie" === key ? (void 0 === self.headers[key] && (self.headers[key] = []), 
                            self.headers[key].push(matches[2])) : void 0 !== self.headers[key] ? self.headers[key] += ", " + matches[2] : self.headers[key] = matches[2], 
                            self.rawHeaders.push(matches[1], matches[2]);
                        }
                    }), self._charset = "x-user-defined", !capability.overrideMimeType) {
                        var mimeType = self.rawHeaders["mime-type"];
                        if (mimeType) {
                            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                            charsetMatch && (self._charset = charsetMatch[1].toLowerCase());
                        }
                        self._charset || (self._charset = "utf-8");
                    }
                }
            };
            inherits(IncomingMessage, stream.Readable), IncomingMessage.prototype._read = function() {
                var resolve = this._resumeFetch;
                resolve && (this._resumeFetch = null, resolve());
            }, IncomingMessage.prototype._onXHRProgress = function() {
                var self = this, xhr = self._xhr, response = null;
                switch (self._mode) {
                  case "text:vbarray":
                    if (xhr.readyState !== rStates.DONE) break;
                    try {
                        response = new global.VBArray(xhr.responseBody).toArray();
                    } catch (e) {}
                    if (null !== response) {
                        self.push(new Buffer(response));
                        break;
                    }

                  case "text":
                    try {
                        response = xhr.responseText;
                    } catch (e) {
                        self._mode = "text:vbarray";
                        break;
                    }
                    if (response.length > self._pos) {
                        var newData = response.substr(self._pos);
                        if ("x-user-defined" === self._charset) {
                            for (var buffer = new Buffer(newData.length), i = 0; i < newData.length; i++) buffer[i] = 255 & newData.charCodeAt(i);
                            self.push(buffer);
                        } else self.push(newData, self._charset);
                        self._pos = response.length;
                    }
                    break;

                  case "arraybuffer":
                    if (xhr.readyState !== rStates.DONE || !xhr.response) break;
                    response = xhr.response, self.push(new Buffer(new Uint8Array(response)));
                    break;

                  case "moz-chunked-arraybuffer":
                    if (response = xhr.response, xhr.readyState !== rStates.LOADING || !response) break;
                    self.push(new Buffer(new Uint8Array(response)));
                    break;

                  case "ms-stream":
                    if (response = xhr.response, xhr.readyState !== rStates.LOADING) break;
                    var reader = new global.MSStreamReader();
                    reader.onprogress = function() {
                        reader.result.byteLength > self._pos && (self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos)))), 
                        self._pos = reader.result.byteLength);
                    }, reader.onload = function() {
                        self.push(null);
                    }, reader.readAsArrayBuffer(response);
                }
                self._xhr.readyState === rStates.DONE && "ms-stream" !== self._mode && self.push(null);
            };
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, require("buffer").Buffer);
    }, {
        "./capability": 40,
        _process: 56,
        buffer: 24,
        inherits: 46,
        "readable-stream": 71
    } ],
    43: [ function(require, module, exports) {
        "use strict";
        var punycode = require("punycode"), util = require("./util");
        function Url() {
            this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, 
            this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, 
            this.path = null, this.href = null;
        }
        exports.parse = urlParse, exports.resolve = function(source, relative) {
            return urlParse(source, !1, !0).resolve(relative);
        }, exports.resolveObject = function(source, relative) {
            return source ? urlParse(source, !1, !0).resolveObject(relative) : relative;
        }, exports.format = function(obj) {
            util.isString(obj) && (obj = urlParse(obj));
            return obj instanceof Url ? obj.format() : Url.prototype.format.call(obj);
        }, exports.Url = Url;
        var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, unwise = [ "{", "}", "|", "\\", "^", "`" ].concat([ "<", ">", '"', "`", " ", "\r", "\n", "\t" ]), autoEscape = [ "'" ].concat(unwise), nonHostChars = [ "%", "/", "?", ";", "#" ].concat(autoEscape), hostEndingChars = [ "/", "?", "#" ], hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
            javascript: !0,
            "javascript:": !0
        }, hostlessProtocol = {
            javascript: !0,
            "javascript:": !0
        }, slashedProtocol = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
        }, querystring = require("querystring");
        function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && util.isObject(url) && url instanceof Url) return url;
            var u = new Url();
            return u.parse(url, parseQueryString, slashesDenoteHost), u;
        }
        Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!util.isString(url)) throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            var queryIndex = url.indexOf("?"), splitter = -1 !== queryIndex && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter);
            uSplit[0] = uSplit[0].replace(/\\/g, "/");
            var rest = url = uSplit.join(splitter);
            if (rest = rest.trim(), !slashesDenoteHost && 1 === url.split("#").length) {
                var simplePath = simplePathPattern.exec(rest);
                if (simplePath) return this.path = rest, this.href = rest, this.pathname = simplePath[1], 
                simplePath[2] ? (this.search = simplePath[2], this.query = parseQueryString ? querystring.parse(this.search.substr(1)) : this.search.substr(1)) : parseQueryString && (this.search = "", 
                this.query = {}), this;
            }
            var proto = protocolPattern.exec(rest);
            if (proto) {
                var lowerProto = (proto = proto[0]).toLowerCase();
                this.protocol = lowerProto, rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                var slashes = "//" === rest.substr(0, 2);
                !slashes || proto && hostlessProtocol[proto] || (rest = rest.substr(2), this.slashes = !0);
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                for (var auth, atSign, hostEnd = -1, i = 0; i < hostEndingChars.length; i++) {
                    -1 !== (hec = rest.indexOf(hostEndingChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                }
                -1 !== (atSign = -1 === hostEnd ? rest.lastIndexOf("@") : rest.lastIndexOf("@", hostEnd)) && (auth = rest.slice(0, atSign), 
                rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth)), hostEnd = -1;
                for (i = 0; i < nonHostChars.length; i++) {
                    var hec;
                    -1 !== (hec = rest.indexOf(nonHostChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                }
                -1 === hostEnd && (hostEnd = rest.length), this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), 
                this.parseHost(), this.hostname = this.hostname || "";
                var ipv6Hostname = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                if (!ipv6Hostname) for (var hostparts = this.hostname.split(/\./), l = (i = 0, hostparts.length); i < l; i++) {
                    var part = hostparts[i];
                    if (part && !part.match(hostnamePartPattern)) {
                        for (var newpart = "", j = 0, k = part.length; j < k; j++) 127 < part.charCodeAt(j) ? newpart += "x" : newpart += part[j];
                        if (!newpart.match(hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);
                            bit && (validParts.push(bit[1]), notHost.unshift(bit[2])), notHost.length && (rest = "/" + notHost.join(".") + rest), 
                            this.hostname = validParts.join(".");
                            break;
                        }
                    }
                }
                255 < this.hostname.length ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), 
                ipv6Hostname || (this.hostname = punycode.toASCII(this.hostname));
                var p = this.port ? ":" + this.port : "", h = this.hostname || "";
                this.host = h + p, this.href += this.host, ipv6Hostname && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), 
                "/" !== rest[0] && (rest = "/" + rest));
            }
            if (!unsafeProtocol[lowerProto]) for (i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                if (-1 !== rest.indexOf(ae)) {
                    var esc = encodeURIComponent(ae);
                    esc === ae && (esc = escape(ae)), rest = rest.split(ae).join(esc);
                }
            }
            var hash = rest.indexOf("#");
            -1 !== hash && (this.hash = rest.substr(hash), rest = rest.slice(0, hash));
            var qm = rest.indexOf("?");
            if (-1 !== qm ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), 
            parseQueryString && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : parseQueryString && (this.search = "", 
            this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = "/"), 
            this.pathname || this.search) {
                p = this.pathname || "";
                var s = this.search || "";
                this.path = p + s;
            }
            return this.href = this.format(), this;
        }, Url.prototype.format = function() {
            var auth = this.auth || "";
            auth && (auth = (auth = encodeURIComponent(auth)).replace(/%3A/i, ":"), auth += "@");
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = !1, query = "";
            this.host ? host = auth + this.host : this.hostname && (host = auth + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), 
            this.port && (host += ":" + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (query = querystring.stringify(this.query));
            var search = this.search || query && "?" + query || "";
            return protocol && ":" !== protocol.substr(-1) && (protocol += ":"), this.slashes || (!protocol || slashedProtocol[protocol]) && !1 !== host ? (host = "//" + (host || ""), 
            pathname && "/" !== pathname.charAt(0) && (pathname = "/" + pathname)) : host || (host = ""), 
            hash && "#" !== hash.charAt(0) && (hash = "#" + hash), search && "?" !== search.charAt(0) && (search = "?" + search), 
            protocol + host + (pathname = pathname.replace(/[?#]/g, function(match) {
                return encodeURIComponent(match);
            })) + (search = search.replace("#", "%23")) + hash;
        }, Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, !1, !0)).format();
        }, Url.prototype.resolveObject = function(relative) {
            if (util.isString(relative)) {
                var rel = new Url();
                rel.parse(relative, !1, !0), relative = rel;
            }
            for (var result = new Url(), tkeys = Object.keys(this), tk = 0; tk < tkeys.length; tk++) {
                var tkey = tkeys[tk];
                result[tkey] = this[tkey];
            }
            if (result.hash = relative.hash, "" === relative.href) return result.href = result.format(), 
            result;
            if (relative.slashes && !relative.protocol) {
                for (var rkeys = Object.keys(relative), rk = 0; rk < rkeys.length; rk++) {
                    var rkey = rkeys[rk];
                    "protocol" !== rkey && (result[rkey] = relative[rkey]);
                }
                return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = "/"), 
                result.href = result.format(), result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
                if (!slashedProtocol[relative.protocol]) {
                    for (var keys = Object.keys(relative), v = 0; v < keys.length; v++) {
                        var k = keys[v];
                        result[k] = relative[k];
                    }
                    return result.href = result.format(), result;
                }
                if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol]) result.pathname = relative.pathname; else {
                    for (var relPath = (relative.pathname || "").split("/"); relPath.length && !(relative.host = relPath.shift()); ) ;
                    relative.host || (relative.host = ""), relative.hostname || (relative.hostname = ""), 
                    "" !== relPath[0] && relPath.unshift(""), relPath.length < 2 && relPath.unshift(""), 
                    result.pathname = relPath.join("/");
                }
                if (result.search = relative.search, result.query = relative.query, result.host = relative.host || "", 
                result.auth = relative.auth, result.hostname = relative.hostname || relative.host, 
                result.port = relative.port, result.pathname || result.search) {
                    var p = result.pathname || "", s = result.search || "";
                    result.path = p + s;
                }
                return result.slashes = result.slashes || relative.slashes, result.href = result.format(), 
                result;
            }
            var isSourceAbs = result.pathname && "/" === result.pathname.charAt(0), isRelAbs = relative.host || relative.pathname && "/" === relative.pathname.charAt(0), mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = (relPath = relative.pathname && relative.pathname.split("/") || [], 
            result.protocol && !slashedProtocol[result.protocol]);
            if (psychotic && (result.hostname = "", result.port = null, result.host && ("" === srcPath[0] ? srcPath[0] = result.host : srcPath.unshift(result.host)), 
            result.host = "", relative.protocol && (relative.hostname = null, relative.port = null, 
            relative.host && ("" === relPath[0] ? relPath[0] = relative.host : relPath.unshift(relative.host)), 
            relative.host = null), mustEndAbs = mustEndAbs && ("" === relPath[0] || "" === srcPath[0])), 
            isRelAbs) result.host = relative.host || "" === relative.host ? relative.host : result.host, 
            result.hostname = relative.hostname || "" === relative.hostname ? relative.hostname : result.hostname, 
            result.search = relative.search, result.query = relative.query, srcPath = relPath; else if (relPath.length) srcPath || (srcPath = []), 
            srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, 
            result.query = relative.query; else if (!util.isNullOrUndefined(relative.search)) {
                if (psychotic) result.hostname = result.host = srcPath.shift(), (authInHost = !!(result.host && 0 < result.host.indexOf("@")) && result.host.split("@")) && (result.auth = authInHost.shift(), 
                result.host = result.hostname = authInHost.shift());
                return result.search = relative.search, result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), 
                result.href = result.format(), result;
            }
            if (!srcPath.length) return result.pathname = null, result.search ? result.path = "/" + result.search : result.path = null, 
            result.href = result.format(), result;
            for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || 1 < srcPath.length) && ("." === last || ".." === last) || "" === last, up = 0, i = srcPath.length; 0 <= i; i--) "." === (last = srcPath[i]) ? srcPath.splice(i, 1) : ".." === last ? (srcPath.splice(i, 1), 
            up++) : up && (srcPath.splice(i, 1), up--);
            if (!mustEndAbs && !removeAllDots) for (;up--; up) srcPath.unshift("..");
            !mustEndAbs || "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0) || srcPath.unshift(""), 
            hasTrailingSlash && "/" !== srcPath.join("/").substr(-1) && srcPath.push("");
            var authInHost, isAbsolute = "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0);
            psychotic && (result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "", 
            (authInHost = !!(result.host && 0 < result.host.indexOf("@")) && result.host.split("@")) && (result.auth = authInHost.shift(), 
            result.host = result.hostname = authInHost.shift()));
            return (mustEndAbs = mustEndAbs || result.host && srcPath.length) && !isAbsolute && srcPath.unshift(""), 
            srcPath.length ? result.pathname = srcPath.join("/") : (result.pathname = null, 
            result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), 
            result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, 
            result.href = result.format(), result;
        }, Url.prototype.parseHost = function() {
            var host = this.host, port = portPattern.exec(host);
            port && (":" !== (port = port[0]) && (this.port = port.substr(1)), host = host.substr(0, host.length - port.length)), 
            host && (this.hostname = host);
        };
    }, {
        "./util": 44,
        punycode: 57,
        querystring: 60
    } ],
    44: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            isString: function(arg) {
                return "string" == typeof arg;
            },
            isObject: function(arg) {
                return "object" == typeof arg && null !== arg;
            },
            isNull: function(arg) {
                return null === arg;
            },
            isNullOrUndefined: function(arg) {
                return null == arg;
            }
        };
    }, {} ],
    45: [ function(require, module, exports) {
        exports.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
            for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; 0 < nBits; e = 256 * e + buffer[offset + i], 
            i += d, nBits -= 8) ;
            for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; 0 < nBits; m = 256 * m + buffer[offset + i], 
            i += d, nBits -= 8) ;
            if (0 === e) e = 1 - eBias; else {
                if (e === eMax) return m ? NaN : 1 / 0 * (s ? -1 : 1);
                m += Math.pow(2, mLen), e -= eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
        }, exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
            for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, 
            e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, 
            c *= 2), 2 <= (value += 1 <= e + eBias ? rt / c : rt * Math.pow(2, 1 - eBias)) * c && (e++, 
            c /= 2), eMax <= e + eBias ? (m = 0, e = eMax) : 1 <= e + eBias ? (m = (value * c - 1) * Math.pow(2, mLen), 
            e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); 8 <= mLen; buffer[offset + i] = 255 & m, 
            i += d, m /= 256, mLen -= 8) ;
            for (e = e << mLen | m, eLen += mLen; 0 < eLen; buffer[offset + i] = 255 & e, i += d, 
            e /= 256, eLen -= 8) ;
            buffer[offset + i - d] |= 128 * s;
        };
    }, {} ],
    46: [ function(require, module, exports) {
        arguments[4][18][0].apply(exports, arguments);
    }, {
        dup: 18
    } ],
    47: [ function(require, module, exports) {
        function isBuffer(obj) {
            return !!obj.constructor && "function" == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj);
        }
        module.exports = function(obj) {
            return null != obj && (isBuffer(obj) || function(obj) {
                return "function" == typeof obj.readFloatLE && "function" == typeof obj.slice && isBuffer(obj.slice(0, 0));
            }(obj) || !!obj._isBuffer);
        };
    }, {} ],
    48: [ function(require, module, exports) {
        var toString = {}.toString;
        module.exports = Array.isArray || function(arr) {
            return "[object Array]" == toString.call(arr);
        };
    }, {} ],
    49: [ function(require, module, exports) {
        (function(process, Buffer) {
            var http = require("follow-redirects").http, https = require("follow-redirects").https, urlParser = require("url"), util = require("util"), events = require("events"), zlib = require("zlib"), node_debug = require("debug")("NRC");
            exports.Client = function(options) {
                var self = this, parserManager = require("./nrc-parser-manager")(), serializerManager = require("./nrc-serializer-manager")(), connectManager = new ConnectManager(this, parserManager), ioFacade = function(parserManager, serializerManager) {
                    var errorContext = function(logic) {
                        return function() {
                            try {
                                return logic.apply(this, arguments);
                            } catch (err) {
                                self.emit("error", err);
                            }
                        };
                    }, result = {
                        parsers: {},
                        serializers: {}
                    };
                    return result.parsers.add = errorContext(parserManager.add), result.parsers.remove = errorContext(parserManager.remove), 
                    result.parsers.find = errorContext(parserManager.find), result.parsers.getAll = errorContext(parserManager.getAll), 
                    result.parsers.getDefault = errorContext(parserManager.getDefault), result.parsers.clean = errorContext(parserManager.clean), 
                    result.serializers.add = errorContext(serializerManager.add), result.serializers.remove = errorContext(serializerManager.remove), 
                    result.serializers.find = errorContext(serializerManager.find), result.serializers.getAll = errorContext(serializerManager.getAll), 
                    result.serializers.getDefault = errorContext(serializerManager.getDefault), result.serializers.clean = errorContext(serializerManager.clean), 
                    result;
                }(parserManager, serializerManager), CONSTANTS_HEADER_CONTENT_LENGTH = "Content-Length";
                self.options = options || {}, self.useProxy = !!self.options.proxy, self.useProxyTunnel = !(!self.useProxy || void 0 === self.options.proxy.tunnel) && self.options.proxy.tunnel, 
                self.proxy = self.options.proxy, self.connection = self.options.connection || {}, 
                self.mimetypes = self.options.mimetypes || {}, self.requestConfig = self.options.requestConfig || {}, 
                self.responseConfig = self.options.responseConfig || {}, this.methods = {}, this.parsers = {}, 
                this.serializers = {};
                var ClientRequest = function() {
                    events.EventEmitter.call(this);
                };
                util.inherits(ClientRequest, events.EventEmitter), ClientRequest.prototype.end = function() {
                    this._httpRequest && this._httpRequest.end();
                }, ClientRequest.prototype.setHttpRequest = function(req) {
                    this._httpRequest = req;
                };
                var Util = {
                    createProxyPath: function(url) {
                        var result = url.host;
                        return "https:" === url.protocol && (result = -1 == url.host.indexOf(":") ? url.hostname + ":443" : url.host), 
                        result;
                    },
                    createProxyHeaders: function(url) {
                        var result = {};
                        return self.proxy.user && self.proxy.password && (result["Proxy-Authorization"] = "Basic " + new Buffer([ self.proxy.user, self.proxy.password ].join(":")).toString("base64")), 
                        self.useProxyTunnel || (result.host = url.host), result;
                    },
                    createConnectOptions: function(connectURL, connectMethod) {
                        debug("connect URL = ", connectURL);
                        var url = urlParser.parse(connectURL), result = {}, protocol = -1 == url.protocol.indexOf(":") ? url.protocol : url.protocol.substring(0, url.protocol.indexOf(":")), defaultPort = "http" === protocol ? 80 : 443;
                        if (result = {
                            host: -1 == url.host.indexOf(":") ? url.host : url.host.substring(0, url.host.indexOf(":")),
                            port: void 0 === url.port ? defaultPort : url.port,
                            path: url.path,
                            protocol: protocol,
                            href: url.href
                        }, self.useProxy && (result.agent = !1), self.options.user && self.options.password ? result.auth = [ self.options.user, self.options.password ].join(":") : self.options.user && !self.options.password && (result.auth = self.options.user + ":"), 
                        self.useProxy && (result.proxy = {
                            host: self.proxy.host,
                            port: self.proxy.port,
                            method: self.useProxyTunnel ? "CONNECT" : connectMethod,
                            path: self.useProxyTunnel ? this.createProxyPath(url) : connectURL,
                            headers: this.createProxyHeaders(url)
                        }), self.connection && "object" == typeof self.connection) for (var option in self.connection) result[option] = self.connection[option];
                        if (!self.useProxyTunnel) {
                            for (var proxyOption in result.proxy) result[proxyOption] = result.proxy[proxyOption];
                            delete result.proxy;
                        }
                        return result.requestConfig = self.requestConfig, result.responseConfig = self.responseConfig, 
                        result;
                    },
                    decodeQueryFromURL: function(connectURL) {
                        for (var keyValue, query = urlParser.parse(connectURL).query.substring(1).split("&"), result = {}, i = 0; i < query.length; i++) result[(keyValue = query[i].split("="))[0]] = decodeURIComponent(keyValue[1]);
                        return result;
                    },
                    serializeEncodeQueryFromArgs: function(args) {
                        return debug("args is", args), args && "object" != typeof args && self.emit("error", "cannot serialize parameters: invalid type " + typeof args + " should be an object type"), 
                        function serialize(obj, parent) {
                            var propertyName, tokens = [];
                            for (propertyName in obj) if (obj.hasOwnProperty(propertyName)) {
                                var parsedProperty = parent ? parent + "[" + propertyName + "]" : propertyName, propertyValue = obj[propertyName];
                                tokens.push(null !== propertyValue && "object" == typeof propertyValue ? serialize(propertyValue, parsedProperty) : encodeURIComponent(parsedProperty) + "=" + encodeURIComponent(propertyValue));
                            }
                            return tokens.join("&");
                        }(args);
                    },
                    parsePathParameters: function(args, url) {
                        var result = url;
                        if (!args || !args.path) return url;
                        for (var placeholder in args.path) {
                            var regex = new RegExp("\\$\\{" + placeholder + "\\}", "i");
                            result = result.replace(regex, args.path[placeholder]);
                        }
                        return result;
                    },
                    overrideClientConfig: function(connectOptions, methodOptions) {
                        function validateReqResOptions(reqResOption) {
                            return reqResOption && "object" == typeof reqResOption;
                        }
                        validateReqResOptions(methodOptions.requestConfig) && util._extend(connectOptions.requestConfig, methodOptions.requestConfig), 
                        validateReqResOptions(methodOptions.responseConfig) && util._extend(connectOptions.responseConfig, methodOptions.responseConfig);
                    },
                    connect: function(method, url, args, callback, clientRequest) {
                        callback && args && "object" != typeof args && self.emit("error", "args should be and object");
                        var options = this.createConnectOptions(this.parsePathParameters(args, url), method);
                        if (debug("options pre connect", options), options.method = method, clientRequest.href = options.href, 
                        options.clientRequest = clientRequest, options.headers = options.headers || {}, 
                        debug("args = ", args), debug("args.data = ", void 0 !== args ? args.data : void 0), 
                        "function" == typeof args) callback = args, "POST" !== method && "PUT" !== method && "DELETE" !== method && "PATCH" !== method || (options.headers[CONSTANTS_HEADER_CONTENT_LENGTH] = 0); else if ("object" == typeof args) {
                            if (args.headers) for (var headerName in args.headers) args.headers.hasOwnProperty(headerName) && (options.headers[headerName] = args.headers[headerName]);
                            if (args.parameters && 0 < Object.keys(args.parameters).length) {
                                var pathLength = options.path.length, pathParameterSepCharPos = options.path.indexOf("?");
                                0 <= pathParameterSepCharPos && pathParameterSepCharPos !== pathLength - 1 && self.emit("error", "parameters argument cannot be used if parameters are already defined in URL " + options.path), 
                                options.path += "?" === options.path.charAt(pathLength - 1) ? "" : "?", options.path = options.path.concat(Util.serializeEncodeQueryFromArgs(args.parameters)), 
                                debug("options.path after request parameters = ", options.path);
                            }
                            this.overrideClientConfig(options, args), void 0 === args.data || options.headers.hasOwnProperty(CONSTANTS_HEADER_CONTENT_LENGTH) ? options.headers[CONSTANTS_HEADER_CONTENT_LENGTH] = 0 : serializerManager.get(options).serialize(args.data, function(client) {
                                client = client;
                                return function(type, event) {
                                    client.emit(type, event);
                                };
                            }(self), function(serializedData) {
                                options.data = serializedData, options.headers[CONSTANTS_HEADER_CONTENT_LENGTH] = Buffer.byteLength(options.data, "utf8");
                            });
                        }
                        debug("options post connect", options), debug("FINAL SELF object  ====>", self), 
                        self.useProxy && self.useProxyTunnel ? connectManager.proxy(options, callback) : connectManager.normal(options, callback);
                    },
                    mergeMimeTypes: function(mimetypes) {
                        if (mimetypes && "object" == typeof mimetypes) try {
                            mimetypes.json && mimetypes.json instanceof Array && 0 < mimetypes.json.length ? parserManager.find("JSON").contentTypes = mimetypes.json : mimetypes.xml && mimetypes.xml instanceof Array && 0 < mimetypes.xml.length && (parserManager.find("XML").contentTypes = mimetypes.xml);
                        } catch (err) {
                            self.emit("error", "cannot assign custom content types to parser, cause: " + err);
                        }
                    },
                    createHttpMethod: function(methodName) {
                        return function(url, args, callback) {
                            var clientRequest = new ClientRequest();
                            return Util.connect(methodName.toUpperCase(), url, args, callback, clientRequest), 
                            clientRequest;
                        };
                    }
                }, Method = function(url, method) {
                    var httpMethod = self[method.toLowerCase()];
                    return function(args, callback) {
                        return "function" == typeof args && (callback = args, args = {}), httpMethod(url, args, callback);
                    };
                };
                this.get = Util.createHttpMethod("get"), this.post = Util.createHttpMethod("post"), 
                this.put = Util.createHttpMethod("put"), this.delete = Util.createHttpMethod("delete"), 
                this.patch = Util.createHttpMethod("patch"), this.registerMethod = function(name, url, method) {
                    this.methods[name] = new Method(url, method);
                }, this.unregisterMethod = function(name) {
                    delete this.methods[name];
                }, this.addCustomHttpMethod = function(methodName) {
                    self[methodName.toLowerCase()] = Util.createHttpMethod(methodName);
                }, this.parsers = ioFacade.parsers, this.serializers = ioFacade.serializers, Util.mergeMimeTypes(self.mimetypes), 
                debug("ConnectManager", connectManager);
            };
            var ConnectManager = function(client, parserManager) {
                client = client;
                this.configureRequest = function(req, config, clientRequest) {
                    config.timeout && req.setTimeout(config.timeout, function() {
                        clientRequest.emit("requestTimeout", req);
                    }), config.noDelay && req.setNoDelay(config.noDelay), config.keepAlive && req.setSocketKeepAlive(config.noDelay, config.keepAliveDelay || 0);
                }, this.configureResponse = function(res, config, clientRequest) {
                    config.timeout && res.setTimeout(config.timeout, function() {
                        clientRequest.emit("responseTimeout", res), res.close();
                    });
                }, this.configureOptions = function(options) {
                    !function(propsArray, optionsElement) {
                        for (var index in propsArray) optionsElement.hasOwnProperty(propsArray[index]) && (options[propsArray[index]] = optionsElement[propsArray[index]]);
                    }([ "followRedirects", "maxRedirects" ], options.requestConfig), delete options.protocol, 
                    delete options.clientRequest, delete options.requestConfig, delete options.responseConfig, 
                    debug("options pre connect", options);
                }, this.handleEnd = function(res, buffer, callback) {
                    var self = this, content = res.headers["content-type"], encoding = res.headers["content-encoding"];
                    debug("content-type: ", content), debug("content-encoding: ", encoding), void 0 !== encoding && 0 <= encoding.indexOf("gzip") ? (debug("gunzip"), 
                    zlib.gunzip(Buffer.concat(buffer), function(er, gunzipped) {
                        self.handleResponse(res, gunzipped, callback);
                    })) : void 0 !== encoding && 0 <= encoding.indexOf("deflate") ? (debug("inflate"), 
                    zlib.inflate(Buffer.concat(buffer), function(er, inflated) {
                        self.handleResponse(res, inflated, callback);
                    })) : (debug("not compressed"), self.handleResponse(res, Buffer.concat(buffer), callback));
                }, this.handleResponse = function(res, data, callback) {
                    parserManager.get(res).parse(data, function(client) {
                        client = client;
                        return function(type, event) {
                            client.emit(type, event);
                        };
                    }(client), function(parsedData) {
                        callback(parsedData, res);
                    });
                }, this.prepareData = function(data) {
                    return data instanceof Buffer || "object" != typeof data ? data : JSON.stringify(data);
                }, this.proxy = function(options, callback) {
                    debug("proxy options", options.proxy);
                    var proxyTunnel = http.request(options.proxy), self = this;
                    proxyTunnel.on("connect", function(res, socket, head) {
                        debug("proxy connected", socket), options.socket = socket;
                        var buffer = [], protocol = "http" == options.protocol ? http : https, clientRequest = options.clientRequest, requestConfig = options.requestConfig, responseConfig = options.responseConfig;
                        self.configureOptions(options), clientRequest.options = options;
                        var request = protocol.request(options, function(res) {
                            self.configureResponse(res, responseConfig, clientRequest), res.on("data", function(chunk) {
                                buffer.push(new Buffer(chunk));
                            }), res.on("end", function() {
                                self.handleEnd(res, buffer, callback);
                            }), res.on("error", function(err) {
                                void 0 !== clientRequest && "object" == typeof clientRequest ? (err.request = clientRequest, 
                                err.response = res, clientRequest.emit("error", err)) : client.emit("error", err);
                            });
                        });
                        self.configureRequest(request, requestConfig, clientRequest), clientRequest.setHttpRequest(request), 
                        options.data && request.write(options.data), request.end(), request.on("error", function(err) {
                            void 0 !== clientRequest && "object" == typeof clientRequest ? (err.request = clientRequest).emit("error", err) : client.emit("error", err);
                        });
                    }), proxyTunnel.on("error", function(e) {
                        client.emit("error", e);
                    }), proxyTunnel.end();
                }, this.normal = function(options, callback) {
                    var buffer = [], protocol = "http" === options.protocol ? http : https, clientRequest = options.clientRequest, requestConfig = options.requestConfig, responseConfig = options.responseConfig, self = this;
                    self.configureOptions(options), clientRequest.options = options;
                    var request = protocol.request(options, function(res) {
                        self.configureResponse(res, responseConfig, clientRequest), res.on("data", function(chunk) {
                            buffer.push(new Buffer(chunk));
                        }), res.on("end", function() {
                            self.handleEnd(res, buffer, callback);
                        }), res.on("error", function(err) {
                            void 0 !== clientRequest && "object" == typeof clientRequest ? (err.request = clientRequest, 
                            err.response = res, clientRequest.emit("error", err)) : client.emit("error", err);
                        });
                    });
                    self.configureRequest(request, requestConfig, clientRequest), debug("clientRequest", clientRequest), 
                    clientRequest.setHttpRequest(request), debug("options data", options.data), options.data && request.write(options.data), 
                    request.end(), request.on("error", function(err) {
                        void 0 !== clientRequest && "object" == typeof clientRequest ? (err.request = clientRequest).emit("error", err) : client.emit("error", err);
                    });
                };
            };
            util.inherits(exports.Client, events.EventEmitter);
            var debug = function() {
                if (process.env.DEBUG) {
                    var now = new Date(), header = now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + " [NRC CLIENT]" + arguments.callee.caller.name + " -> ", args = Array.prototype.slice.call(arguments);
                    args.splice(0, 0, header), node_debug.apply(console, args);
                }
            };
        }).call(this, require("_process"), require("buffer").Buffer);
    }, {
        "./nrc-parser-manager": 50,
        "./nrc-serializer-manager": 51,
        _process: 56,
        buffer: 24,
        debug: 52,
        events: 26,
        "follow-redirects": 13,
        url: 43,
        util: 82,
        zlib: 23
    } ],
    50: [ function(require, module, exports) {
        var ParserManager = function() {
            var registry = {}, defaultParser = null, _private_validate = function(parser) {
                function validateProperties(parser, props) {
                    var result = !0;
                    for (var propIndex in props) {
                        var propType = props[propIndex].split(":");
                        if (!parser.hasOwnProperty([ propType[0] ]) || typeof parser[propType[0]] !== propType[1]) {
                            result = !1;
                            break;
                        }
                    }
                    return result;
                }
                return result = validateProperties(parser, [ "name:string", "parse:function", "isDefault:boolean" ]), 
                result && !parser.isDefault && (result = validateProperties(parser, [ "match:function" ])), 
                result;
            };
            this.add = function(parser) {
                if (!_private_validate(parser)) throw "parser cannot be added: invalid parser definition";
                parser.isDefault ? defaultParser = parser : registry[parser.name] = parser;
            }, this.remove = function(parserName) {
                if (!registry[parserName]) throw "cannot remove parser: " + parserName + " doesn't exists";
                delete registry[parserName];
            }, this.clean = function() {
                registry = {};
            }, this.find = function(parserName) {
                var result = registry[parserName];
                if (!result) throw "cannot find parser: " + parserName + " doesn't exists ";
                return result;
            }, this.getDefault = function() {
                return defaultParser;
            }, this.get = function(response) {
                var result = null;
                for (var parserName in registry) if (registry[parserName].match(response)) {
                    result = registry[parserName];
                    break;
                }
                return null === result ? defaultParser : result;
            }, this.getAll = function() {
                var result = [];
                for (var parserName in registry) result.push(registry[parserName]);
                return result;
            };
        };
        module.exports = function() {
            var parserManager = new ParserManager(), BaseParser = {
                isDefault: !1,
                match: function(response) {
                    var result = !1, contentType = response.headers["content-type"] && response.headers["content-type"].replace(/ /g, "");
                    if (!contentType) return result;
                    for (var i = 0; i < this.contentTypes.length && !(result = this.contentTypes[i].trim().toLowerCase() === contentType.trim().toLowerCase()); i++) ;
                    return result;
                }
            };
            return parserManager.add(Object.assign({
                name: "XML",
                options: {
                    explicitArray: !1
                },
                contentTypes: [ "application/xml", "application/xml;charset=utf-8", "text/xml", "text/xml;charset=utf-8" ],
                parseString: require("xml2js").parseString,
                parse: function(byteBuffer, nrcEventEmitter, parsedCallback) {
                    this.parseString(byteBuffer.toString(), this.options, function(err, result) {
                        parsedCallback(result);
                    });
                }
            }, BaseParser)), parserManager.add(Object.assign({
                name: "JSON",
                contentTypes: [ "application/json", "application/json;charset=utf-8" ],
                isValidData: function(data) {
                    return void 0 !== data && void 0 !== data.length && 0 < data.length;
                },
                parse: function(byteBuffer, nrcEventEmitter, parsedCallback) {
                    var jsonData, data = byteBuffer.toString();
                    try {
                        jsonData = this.isValidData(data) ? JSON.parse(data) : data;
                    } catch (err) {
                        nrcEventEmitter("error", "Error parsing response. response: [" + data + "], error: [" + err + "]");
                    }
                    parsedCallback(jsonData);
                }
            }, BaseParser)), parserManager.add({
                name: "DEFAULT",
                isDefault: !0,
                parse: function(byteBuffer, nrcEventEmitter, parsedCallback) {
                    parsedCallback(byteBuffer);
                }
            }), parserManager;
        };
    }, {
        xml2js: 88
    } ],
    51: [ function(require, module, exports) {
        var xmlserializer = require("xml2js"), SerializerManager = function() {
            var registry = {}, defaultSerializer = null, _private_validate = function(serializer) {
                function validateProperties(serializer, props) {
                    var result = !0;
                    for (var propIndex in props) {
                        var propType = props[propIndex].split(":");
                        if (!serializer.hasOwnProperty([ propType[0] ]) || typeof serializer[propType[0]] !== propType[1]) {
                            result = !1;
                            break;
                        }
                    }
                    return result;
                }
                return result = validateProperties(serializer, [ "name:string", "serialize:function", "isDefault:boolean" ]), 
                result && !serializer.isDefault && (result = validateProperties(serializer, [ "match:function" ])), 
                result;
            };
            this.add = function(serializer) {
                if (!_private_validate(serializer)) throw "serializer cannot be added: invalid serializer definition";
                serializer.isDefault ? defaultSerializer = serializer : registry[serializer.name] = serializer;
            }, this.remove = function(serializerName) {
                if (!registry[serializerName]) throw "cannot remove serializer: " + serializerName + " doesn't exists";
                delete registry[serializerName];
            }, this.find = function(serializerName) {
                var result = registry[serializerName];
                if (!result) throw "cannot find serializer: " + serializerName + " doesn't exists";
                return result;
            }, this.clean = function() {
                registry = {};
            }, this.get = function(request) {
                var result = null;
                for (var serializerName in registry) if (registry[serializerName].match(request)) {
                    result = registry[serializerName];
                    break;
                }
                return null === result ? defaultSerializer : result;
            }, this.getAll = function() {
                var result = [];
                for (var serializerName in registry) result.push(registry[serializerName]);
                return result;
            }, this.getDefault = function() {
                return defaultSerializer;
            };
        };
        module.exports = function() {
            var serializerManager = new SerializerManager(), BaseSerializer = {
                isDefault: !1,
                match: function(request) {
                    var result = !1, contentType = request.headers["Content-Type"] && request.headers["Content-Type"].replace(/ /g, "");
                    if (!contentType) return result;
                    for (var i = 0; i < this.contentTypes.length && !(result = this.contentTypes[i].trim().toLowerCase() === contentType.trim().toLowerCase()); i++) ;
                    return result;
                }
            };
            return serializerManager.add(Object.assign({
                name: "XML",
                options: {},
                contentTypes: [ "application/xml", "application/xml;charset=utf-8", "text/xml", "text/xml;charset=utf-8" ],
                xmlSerializer: new xmlserializer.Builder(this.options),
                serialize: function(data, nrcEventEmitter, serializedCallback) {
                    "object" == typeof data && (data = xmlSerializer.buildObject(data)), serializedCallback(data);
                }
            }, BaseSerializer)), serializerManager.add(Object.assign({
                name: "JSON",
                contentTypes: [ "application/json", "application/json;charset=utf-8" ],
                serialize: function(data, nrcEventEmitter, serializedCallback) {
                    "object" == typeof data && (data = JSON.stringify(data)), serializedCallback(data);
                }
            }, BaseSerializer)), serializerManager.add(Object.assign({
                name: "FORM-ENCODED",
                contentTypes: [ "application/x-www-form-urlencoded", "multipart/form-data", "text/plain" ],
                encode: function(obj, parent) {
                    var propertyName, tokens = [];
                    for (propertyName in obj) if (obj.hasOwnProperty(propertyName)) {
                        var parsedProperty = parent ? parent + "[" + propertyName + "]" : propertyName, propertyValue = obj[propertyName];
                        tokens.push(null !== propertyValue && "object" == typeof propertyValue ? serialize(propertyValue, parsedProperty) : encodeURIComponent(parsedProperty) + "=" + encodeURIComponent(propertyValue));
                    }
                    return tokens.join("&");
                },
                serialize: function(data, nrcEventEmitter, serializedCallback) {
                    "object" == typeof data && (data = this.encode(data)), serializedCallback(data);
                }
            }, BaseSerializer)), serializerManager.add({
                name: "DEFAULT",
                isDefault: !0,
                serialize: function(data, nrcEventEmitter, serializedCallback) {
                    serializedCallback(data.toString());
                }
            }), serializerManager;
        };
    }, {
        xml2js: 88
    } ],
    52: [ function(require, module, exports) {
        function load() {
            var r;
            try {
                r = exports.storage.debug;
            } catch (e) {}
            return r;
        }
        (exports = module.exports = require("./debug")).log = function() {
            return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
        }, exports.formatArgs = function() {
            var args = arguments, useColors = this.useColors;
            if (args[0] = (useColors ? "%c" : "") + this.namespace + (useColors ? " %c" : " ") + args[0] + (useColors ? "%c " : " ") + "+" + exports.humanize(this.diff), 
            !useColors) return args;
            var c = "color: " + this.color;
            args = [ args[0], c, "color: inherit" ].concat(Array.prototype.slice.call(args, 1));
            var index = 0, lastC = 0;
            return args[0].replace(/%[a-z%]/g, function(match) {
                "%%" !== match && (index++, "%c" === match && (lastC = index));
            }), args.splice(lastC, 0, c), args;
        }, exports.save = function(namespaces) {
            try {
                null == namespaces ? exports.storage.removeItem("debug") : exports.storage.debug = namespaces;
            } catch (e) {}
        }, exports.load = load, exports.useColors = function() {
            return "WebkitAppearance" in document.documentElement.style || window.console && (console.firebug || console.exception && console.table) || navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10);
        }, exports.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
            try {
                return window.localStorage;
            } catch (e) {}
        }(), exports.colors = [ "lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson" ], 
        exports.formatters.j = function(v) {
            return JSON.stringify(v);
        }, exports.enable(load());
    }, {
        "./debug": 53
    } ],
    53: [ function(require, module, exports) {
        (exports = module.exports = function(namespace) {
            function disabled() {}
            function enabled() {
                var self = enabled, curr = +new Date(), ms = curr - (prevTime || curr);
                self.diff = ms, self.prev = prevTime, self.curr = curr, prevTime = curr, null == self.useColors && (self.useColors = exports.useColors()), 
                null == self.color && self.useColors && (self.color = exports.colors[prevColor++ % exports.colors.length]);
                var args = Array.prototype.slice.call(arguments);
                args[0] = exports.coerce(args[0]), "string" != typeof args[0] && (args = [ "%o" ].concat(args));
                var index = 0;
                args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
                    if ("%%" === match) return match;
                    index++;
                    var formatter = exports.formatters[format];
                    if ("function" == typeof formatter) {
                        var val = args[index];
                        match = formatter.call(self, val), args.splice(index, 1), index--;
                    }
                    return match;
                }), "function" == typeof exports.formatArgs && (args = exports.formatArgs.apply(self, args));
                var logFn = enabled.log || exports.log || console.log.bind(console);
                logFn.apply(self, args);
            }
            disabled.enabled = !1, enabled.enabled = !0;
            var fn = exports.enabled(namespace) ? enabled : disabled;
            return fn.namespace = namespace, fn;
        }).coerce = function(val) {
            return val instanceof Error ? val.stack || val.message : val;
        }, exports.disable = function() {
            exports.enable("");
        }, exports.enable = function(namespaces) {
            exports.save(namespaces);
            for (var split = (namespaces || "").split(/[\s,]+/), len = split.length, i = 0; i < len; i++) split[i] && ("-" === (namespaces = split[i].replace(/\*/g, ".*?"))[0] ? exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$")) : exports.names.push(new RegExp("^" + namespaces + "$")));
        }, exports.enabled = function(name) {
            var i, len;
            for (i = 0, len = exports.skips.length; i < len; i++) if (exports.skips[i].test(name)) return !1;
            for (i = 0, len = exports.names.length; i < len; i++) if (exports.names[i].test(name)) return !0;
            return !1;
        }, exports.humanize = require("ms"), exports.names = [], exports.skips = [], exports.formatters = {};
        var prevTime, prevColor = 0;
    }, {
        ms: 54
    } ],
    54: [ function(require, module, exports) {
        var s = 1e3, m = 6e4, h = 36e5, d = 24 * h;
        function plural(ms, n, name) {
            if (!(ms < n)) return ms < 1.5 * n ? Math.floor(ms / n) + " " + name : Math.ceil(ms / n) + " " + name + "s";
        }
        module.exports = function(val, options) {
            return options = options || {}, "string" == typeof val ? function(str) {
                if (1e4 < (str = "" + str).length) return;
                var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
                if (!match) return;
                var n = parseFloat(match[1]);
                switch ((match[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * n;

                  case "days":
                  case "day":
                  case "d":
                    return n * d;

                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return n * h;

                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return n * m;

                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return n * s;

                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return n;
                }
            }(val) : options.long ? plural(ms = val, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms" : function(ms) {
                return d <= ms ? Math.round(ms / d) + "d" : h <= ms ? Math.round(ms / h) + "h" : m <= ms ? Math.round(ms / m) + "m" : s <= ms ? Math.round(ms / s) + "s" : ms + "ms";
            }(val);
            var ms;
        };
    }, {} ],
    55: [ function(require, module, exports) {
        (function(process) {
            "use strict";
            !process.version || 0 === process.version.indexOf("v0.") || 0 === process.version.indexOf("v1.") && 0 !== process.version.indexOf("v1.8.") ? module.exports = {
                nextTick: function(fn, arg1, arg2, arg3) {
                    if ("function" != typeof fn) throw new TypeError('"callback" argument must be a function');
                    var args, i, len = arguments.length;
                    switch (len) {
                      case 0:
                      case 1:
                        return process.nextTick(fn);

                      case 2:
                        return process.nextTick(function() {
                            fn.call(null, arg1);
                        });

                      case 3:
                        return process.nextTick(function() {
                            fn.call(null, arg1, arg2);
                        });

                      case 4:
                        return process.nextTick(function() {
                            fn.call(null, arg1, arg2, arg3);
                        });

                      default:
                        for (args = new Array(len - 1), i = 0; i < args.length; ) args[i++] = arguments[i];
                        return process.nextTick(function() {
                            fn.apply(null, args);
                        });
                    }
                }
            } : module.exports = process;
        }).call(this, require("_process"));
    }, {
        _process: 56
    } ],
    56: [ function(require, module, exports) {
        var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
        function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
        }
        function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
        }
        function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
            setTimeout(fun, 0);
            try {
                return cachedSetTimeout(fun, 0);
            } catch (e) {
                try {
                    return cachedSetTimeout.call(null, fun, 0);
                } catch (e) {
                    return cachedSetTimeout.call(this, fun, 0);
                }
            }
        }
        !function() {
            try {
                cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
            } catch (e) {
                cachedSetTimeout = defaultSetTimout;
            }
            try {
                cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
            } catch (e) {
                cachedClearTimeout = defaultClearTimeout;
            }
        }();
        var currentQueue, queue = [], draining = !1, queueIndex = -1;
        function cleanUpNextTick() {
            draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
            queue.length && drainQueue());
        }
        function drainQueue() {
            if (!draining) {
                var timeout = runTimeout(cleanUpNextTick);
                draining = !0;
                for (var len = queue.length; len; ) {
                    for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                    queueIndex = -1, len = queue.length;
                }
                currentQueue = null, draining = !1, function(marker) {
                    if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                    clearTimeout(marker);
                    try {
                        cachedClearTimeout(marker);
                    } catch (e) {
                        try {
                            return cachedClearTimeout.call(null, marker);
                        } catch (e) {
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }(timeout);
            }
        }
        function Item(fun, array) {
            this.fun = fun, this.array = array;
        }
        function noop() {}
        process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (1 < arguments.length) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
            queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
        }, Item.prototype.run = function() {
            this.fun.apply(null, this.array);
        }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
        process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
        process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
        process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
        process.listeners = function(name) {
            return [];
        }, process.binding = function(name) {
            throw new Error("process.binding is not supported");
        }, process.cwd = function() {
            return "/";
        }, process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
        }, process.umask = function() {
            return 0;
        };
    }, {} ],
    57: [ function(require, module, exports) {
        (function(global) {
            !function(root) {
                var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = "object" == typeof module && module && !module.nodeType && module, freeGlobal = "object" == typeof global && global;
                freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal);
                var punycode, key, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                    overflow: "Overflow: input needs wider integers to process",
                    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                    "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode;
                function error(type) {
                    throw new RangeError(errors[type]);
                }
                function map(array, fn) {
                    for (var length = array.length, result = []; length--; ) result[length] = fn(array[length]);
                    return result;
                }
                function mapDomain(string, fn) {
                    var parts = string.split("@"), result = "";
                    return 1 < parts.length && (result = parts[0] + "@", string = parts[1]), result + map((string = string.replace(regexSeparators, ".")).split("."), fn).join(".");
                }
                function ucs2decode(string) {
                    for (var value, extra, output = [], counter = 0, length = string.length; counter < length; ) 55296 <= (value = string.charCodeAt(counter++)) && value <= 56319 && counter < length ? 56320 == (64512 & (extra = string.charCodeAt(counter++))) ? output.push(((1023 & value) << 10) + (1023 & extra) + 65536) : (output.push(value), 
                    counter--) : output.push(value);
                    return output;
                }
                function ucs2encode(array) {
                    return map(array, function(value) {
                        var output = "";
                        return 65535 < value && (output += stringFromCharCode((value -= 65536) >>> 10 & 1023 | 55296), 
                        value = 56320 | 1023 & value), output += stringFromCharCode(value);
                    }).join("");
                }
                function digitToBasic(digit, flag) {
                    return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    for (delta = firstTime ? floor(delta / damp) : delta >> 1, delta += floor(delta / numPoints); baseMinusTMin * tMax >> 1 < delta; k += base) delta = floor(delta / baseMinusTMin);
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                    var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, codePoint, output = [], inputLength = input.length, i = 0, n = initialN, bias = initialBias;
                    for ((basic = input.lastIndexOf(delimiter)) < 0 && (basic = 0), j = 0; j < basic; ++j) 128 <= input.charCodeAt(j) && error("not-basic"), 
                    output.push(input.charCodeAt(j));
                    for (index = 0 < basic ? basic + 1 : 0; index < inputLength; ) {
                        for (oldi = i, w = 1, k = base; inputLength <= index && error("invalid-input"), 
                        codePoint = input.charCodeAt(index++), (base <= (digit = codePoint - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : base) || digit > floor((maxInt - i) / w)) && error("overflow"), 
                        i += digit * w, !(digit < (t = k <= bias ? tMin : bias + tMax <= k ? tMax : k - bias)); k += base) w > floor(maxInt / (baseMinusT = base - t)) && error("overflow"), 
                        w *= baseMinusT;
                        bias = adapt(i - oldi, out = output.length + 1, 0 == oldi), floor(i / out) > maxInt - n && error("overflow"), 
                        n += floor(i / out), i %= out, output.splice(i++, 0, n);
                    }
                    return ucs2encode(output);
                }
                function encode(input) {
                    var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                    for (inputLength = (input = ucs2decode(input)).length, n = initialN, bias = initialBias, 
                    j = delta = 0; j < inputLength; ++j) (currentValue = input[j]) < 128 && output.push(stringFromCharCode(currentValue));
                    for (handledCPCount = basicLength = output.length, basicLength && output.push(delimiter); handledCPCount < inputLength; ) {
                        for (m = maxInt, j = 0; j < inputLength; ++j) n <= (currentValue = input[j]) && currentValue < m && (m = currentValue);
                        for (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1)) && error("overflow"), 
                        delta += (m - n) * handledCPCountPlusOne, n = m, j = 0; j < inputLength; ++j) if ((currentValue = input[j]) < n && ++delta > maxInt && error("overflow"), 
                        currentValue == n) {
                            for (q = delta, k = base; !(q < (t = k <= bias ? tMin : bias + tMax <= k ? tMax : k - bias)); k += base) qMinusT = q - t, 
                            baseMinusT = base - t, output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), 
                            q = floor(qMinusT / baseMinusT);
                            output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), 
                            delta = 0, ++handledCPCount;
                        }
                        ++delta, ++n;
                    }
                    return output.join("");
                }
                if (punycode = {
                    version: "1.4.1",
                    ucs2: {
                        decode: ucs2decode,
                        encode: ucs2encode
                    },
                    decode: decode,
                    encode: encode,
                    toASCII: function(input) {
                        return mapDomain(input, function(string) {
                            return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                        });
                    },
                    toUnicode: function(input) {
                        return mapDomain(input, function(string) {
                            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                        });
                    }
                }, "function" == typeof define && "object" == typeof define.amd && define.amd) define("punycode", function() {
                    return punycode;
                }); else if (freeExports && freeModule) if (module.exports == freeExports) freeModule.exports = punycode; else for (key in punycode) punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); else root.punycode = punycode;
            }(this);
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ],
    58: [ function(require, module, exports) {
        "use strict";
        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        module.exports = function(qs, sep, eq, options) {
            sep = sep || "&", eq = eq || "=";
            var obj = {};
            if ("string" != typeof qs || 0 === qs.length) return obj;
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            options && "number" == typeof options.maxKeys && (maxKeys = options.maxKeys);
            var len = qs.length;
            0 < maxKeys && maxKeys < len && (len = maxKeys);
            for (var i = 0; i < len; ++i) {
                var kstr, vstr, k, v, x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq);
                0 <= idx ? (kstr = x.substr(0, idx), vstr = x.substr(idx + 1)) : (kstr = x, vstr = ""), 
                k = decodeURIComponent(kstr), v = decodeURIComponent(vstr), hasOwnProperty(obj, k) ? isArray(obj[k]) ? obj[k].push(v) : obj[k] = [ obj[k], v ] : obj[k] = v;
            }
            return obj;
        };
        var isArray = Array.isArray || function(xs) {
            return "[object Array]" === Object.prototype.toString.call(xs);
        };
    }, {} ],
    59: [ function(require, module, exports) {
        "use strict";
        var stringifyPrimitive = function(v) {
            switch (typeof v) {
              case "string":
                return v;

              case "boolean":
                return v ? "true" : "false";

              case "number":
                return isFinite(v) ? v : "";

              default:
                return "";
            }
        };
        module.exports = function(obj, sep, eq, name) {
            return sep = sep || "&", eq = eq || "=", null === obj && (obj = void 0), "object" == typeof obj ? map(objectKeys(obj), function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                return isArray(obj[k]) ? map(obj[k], function(v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                }).join(sep) : ks + encodeURIComponent(stringifyPrimitive(obj[k]));
            }).join(sep) : name ? encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)) : "";
        };
        var isArray = Array.isArray || function(xs) {
            return "[object Array]" === Object.prototype.toString.call(xs);
        };
        function map(xs, f) {
            if (xs.map) return xs.map(f);
            for (var res = [], i = 0; i < xs.length; i++) res.push(f(xs[i], i));
            return res;
        }
        var objectKeys = Object.keys || function(obj) {
            var res = [];
            for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && res.push(key);
            return res;
        };
    }, {} ],
    60: [ function(require, module, exports) {
        "use strict";
        exports.decode = exports.parse = require("./decode"), exports.encode = exports.stringify = require("./encode");
    }, {
        "./decode": 58,
        "./encode": 59
    } ],
    61: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_duplex.js");
    }, {
        "./lib/_stream_duplex.js": 62
    } ],
    62: [ function(require, module, exports) {
        "use strict";
        var pna = require("process-nextick-args"), objectKeys = Object.keys || function(obj) {
            var keys = [];
            for (var key in obj) keys.push(key);
            return keys;
        };
        module.exports = Duplex;
        var util = require("core-util-is");
        util.inherits = require("inherits");
        var Readable = require("./_stream_readable"), Writable = require("./_stream_writable");
        util.inherits(Duplex, Readable);
        for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
            var method = keys[v];
            Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
        }
        function Duplex(options) {
            if (!(this instanceof Duplex)) return new Duplex(options);
            Readable.call(this, options), Writable.call(this, options), options && !1 === options.readable && (this.readable = !1), 
            options && !1 === options.writable && (this.writable = !1), this.allowHalfOpen = !0, 
            options && !1 === options.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", onend);
        }
        function onend() {
            this.allowHalfOpen || this._writableState.ended || pna.nextTick(onEndNT, this);
        }
        function onEndNT(self) {
            self.end();
        }
        Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function() {
                return this._writableState.highWaterMark;
            }
        }), Object.defineProperty(Duplex.prototype, "destroyed", {
            get: function() {
                return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
            },
            set: function(value) {
                void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = value, 
                this._writableState.destroyed = value);
            }
        }), Duplex.prototype._destroy = function(err, cb) {
            this.push(null), this.end(), pna.nextTick(cb, err);
        };
    }, {
        "./_stream_readable": 64,
        "./_stream_writable": 66,
        "core-util-is": 12,
        inherits: 46,
        "process-nextick-args": 55
    } ],
    63: [ function(require, module, exports) {
        "use strict";
        module.exports = PassThrough;
        var Transform = require("./_stream_transform"), util = require("core-util-is");
        function PassThrough(options) {
            if (!(this instanceof PassThrough)) return new PassThrough(options);
            Transform.call(this, options);
        }
        util.inherits = require("inherits"), util.inherits(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {
            cb(null, chunk);
        };
    }, {
        "./_stream_transform": 65,
        "core-util-is": 12,
        inherits: 46
    } ],
    64: [ function(require, module, exports) {
        (function(process, global) {
            "use strict";
            var pna = require("process-nextick-args");
            module.exports = Readable;
            var Duplex, isArray = require("isarray");
            Readable.ReadableState = ReadableState;
            require("events").EventEmitter;
            var EElistenerCount = function(emitter, type) {
                return emitter.listeners(type).length;
            }, Stream = require("./internal/streams/stream"), Buffer = require("safe-buffer").Buffer, OurUint8Array = global.Uint8Array || function() {};
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var debugUtil = require("util"), debug = void 0;
            debug = debugUtil && debugUtil.debuglog ? debugUtil.debuglog("stream") : function() {};
            var StringDecoder, BufferList = require("./internal/streams/BufferList"), destroyImpl = require("./internal/streams/destroy");
            util.inherits(Readable, Stream);
            var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];
            function ReadableState(options, stream) {
                options = options || {};
                var isDuplex = stream instanceof (Duplex = Duplex || require("./_stream_duplex"));
                this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.readableObjectMode);
                var hwm = options.highWaterMark, readableHwm = options.readableHighWaterMark, defaultHwm = this.objectMode ? 16 : 16384;
                this.highWaterMark = hwm || 0 === hwm ? hwm : isDuplex && (readableHwm || 0 === readableHwm) ? readableHwm : defaultHwm, 
                this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new BufferList(), 
                this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, 
                this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, 
                this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, 
                this.destroyed = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.awaitDrain = 0, 
                this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding && (StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding);
            }
            function Readable(options) {
                if (Duplex = Duplex || require("./_stream_duplex"), !(this instanceof Readable)) return new Readable(options);
                this._readableState = new ReadableState(options, this), this.readable = !0, options && ("function" == typeof options.read && (this._read = options.read), 
                "function" == typeof options.destroy && (this._destroy = options.destroy)), Stream.call(this);
            }
            function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                var er, state = stream._readableState;
                null === chunk ? (state.reading = !1, function(stream, state) {
                    if (state.ended) return;
                    if (state.decoder) {
                        var chunk = state.decoder.end();
                        chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
                    }
                    state.ended = !0, emitReadable(stream);
                }(stream, state)) : (skipChunkCheck || (er = function(state, chunk) {
                    var er;
                    obj = chunk, Buffer.isBuffer(obj) || obj instanceof OurUint8Array || "string" == typeof chunk || void 0 === chunk || state.objectMode || (er = new TypeError("Invalid non-string/buffer chunk"));
                    var obj;
                    return er;
                }(state, chunk)), er ? stream.emit("error", er) : state.objectMode || chunk && 0 < chunk.length ? ("string" == typeof chunk || state.objectMode || Object.getPrototypeOf(chunk) === Buffer.prototype || (chunk = function(chunk) {
                    return Buffer.from(chunk);
                }(chunk)), addToFront ? state.endEmitted ? stream.emit("error", new Error("stream.unshift() after end event")) : addChunk(stream, state, chunk, !0) : state.ended ? stream.emit("error", new Error("stream.push() after EOF")) : (state.reading = !1, 
                state.decoder && !encoding ? (chunk = state.decoder.write(chunk), state.objectMode || 0 !== chunk.length ? addChunk(stream, state, chunk, !1) : maybeReadMore(stream, state)) : addChunk(stream, state, chunk, !1))) : addToFront || (state.reading = !1));
                return function(state) {
                    return !state.ended && (state.needReadable || state.length < state.highWaterMark || 0 === state.length);
                }(state);
            }
            function addChunk(stream, state, chunk, addToFront) {
                state.flowing && 0 === state.length && !state.sync ? (stream.emit("data", chunk), 
                stream.read(0)) : (state.length += state.objectMode ? 1 : chunk.length, addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), 
                state.needReadable && emitReadable(stream)), maybeReadMore(stream, state);
            }
            Object.defineProperty(Readable.prototype, "destroyed", {
                get: function() {
                    return void 0 !== this._readableState && this._readableState.destroyed;
                },
                set: function(value) {
                    this._readableState && (this._readableState.destroyed = value);
                }
            }), Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, 
            Readable.prototype._destroy = function(err, cb) {
                this.push(null), cb(err);
            }, Readable.prototype.push = function(chunk, encoding) {
                var skipChunkCheck, state = this._readableState;
                return state.objectMode ? skipChunkCheck = !0 : "string" == typeof chunk && ((encoding = encoding || state.defaultEncoding) !== state.encoding && (chunk = Buffer.from(chunk, encoding), 
                encoding = ""), skipChunkCheck = !0), readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
            }, Readable.prototype.unshift = function(chunk) {
                return readableAddChunk(this, chunk, null, !0, !1);
            }, Readable.prototype.isPaused = function() {
                return !1 === this._readableState.flowing;
            }, Readable.prototype.setEncoding = function(enc) {
                return StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, 
                this;
            };
            var MAX_HWM = 8388608;
            function howMuchToRead(n, state) {
                return n <= 0 || 0 === state.length && state.ended ? 0 : state.objectMode ? 1 : n != n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = function(n) {
                    return MAX_HWM <= n ? n = MAX_HWM : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, 
                    n |= n >>> 8, n |= n >>> 16, n++), n;
                }(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = !0, 
                0));
            }
            function emitReadable(stream) {
                var state = stream._readableState;
                state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), 
                state.emittedReadable = !0, state.sync ? pna.nextTick(emitReadable_, stream) : emitReadable_(stream));
            }
            function emitReadable_(stream) {
                debug("emit readable"), stream.emit("readable"), flow(stream);
            }
            function maybeReadMore(stream, state) {
                state.readingMore || (state.readingMore = !0, pna.nextTick(maybeReadMore_, stream, state));
            }
            function maybeReadMore_(stream, state) {
                for (var len = state.length; !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark && (debug("maybeReadMore read 0"), 
                stream.read(0), len !== state.length); ) len = state.length;
                state.readingMore = !1;
            }
            function nReadingNextTick(self) {
                debug("readable nexttick read 0"), self.read(0);
            }
            function resume_(stream, state) {
                state.reading || (debug("resume read 0"), stream.read(0)), state.resumeScheduled = !1, 
                state.awaitDrain = 0, stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
            }
            function flow(stream) {
                var state = stream._readableState;
                for (debug("flow", state.flowing); state.flowing && null !== stream.read(); ) ;
            }
            function fromList(n, state) {
                return 0 === state.length ? null : (state.objectMode ? ret = state.buffer.shift() : !n || n >= state.length ? (ret = state.decoder ? state.buffer.join("") : 1 === state.buffer.length ? state.buffer.head.data : state.buffer.concat(state.length), 
                state.buffer.clear()) : ret = function(n, list, hasStrings) {
                    var ret;
                    n < list.head.data.length ? (ret = list.head.data.slice(0, n), list.head.data = list.head.data.slice(n)) : ret = n === list.head.data.length ? list.shift() : hasStrings ? function(n, list) {
                        var p = list.head, c = 1, ret = p.data;
                        n -= ret.length;
                        for (;p = p.next; ) {
                            var str = p.data, nb = n > str.length ? str.length : n;
                            if (nb === str.length ? ret += str : ret += str.slice(0, n), 0 === (n -= nb)) {
                                nb === str.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p).data = str.slice(nb);
                                break;
                            }
                            ++c;
                        }
                        return list.length -= c, ret;
                    }(n, list) : function(n, list) {
                        var ret = Buffer.allocUnsafe(n), p = list.head, c = 1;
                        p.data.copy(ret), n -= p.data.length;
                        for (;p = p.next; ) {
                            var buf = p.data, nb = n > buf.length ? buf.length : n;
                            if (buf.copy(ret, ret.length - n, 0, nb), 0 === (n -= nb)) {
                                nb === buf.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p).data = buf.slice(nb);
                                break;
                            }
                            ++c;
                        }
                        return list.length -= c, ret;
                    }(n, list);
                    return ret;
                }(n, state.buffer, state.decoder), ret);
                var ret;
            }
            function endReadable(stream) {
                var state = stream._readableState;
                if (0 < state.length) throw new Error('"endReadable()" called on non-empty stream');
                state.endEmitted || (state.ended = !0, pna.nextTick(endReadableNT, state, stream));
            }
            function endReadableNT(state, stream) {
                state.endEmitted || 0 !== state.length || (state.endEmitted = !0, stream.readable = !1, 
                stream.emit("end"));
            }
            function indexOf(xs, x) {
                for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
                return -1;
            }
            Readable.prototype.read = function(n) {
                debug("read", n), n = parseInt(n, 10);
                var state = this._readableState, nOrig = n;
                if (0 !== n && (state.emittedReadable = !1), 0 === n && state.needReadable && (state.length >= state.highWaterMark || state.ended)) return debug("read: emitReadable", state.length, state.ended), 
                0 === state.length && state.ended ? endReadable(this) : emitReadable(this), null;
                if (0 === (n = howMuchToRead(n, state)) && state.ended) return 0 === state.length && endReadable(this), 
                null;
                var ret, doRead = state.needReadable;
                return debug("need readable", doRead), (0 === state.length || state.length - n < state.highWaterMark) && debug("length less than watermark", doRead = !0), 
                state.ended || state.reading ? debug("reading or ended", doRead = !1) : doRead && (debug("do read"), 
                state.reading = !0, state.sync = !0, 0 === state.length && (state.needReadable = !0), 
                this._read(state.highWaterMark), state.sync = !1, state.reading || (n = howMuchToRead(nOrig, state))), 
                null === (ret = 0 < n ? fromList(n, state) : null) ? (state.needReadable = !0, n = 0) : state.length -= n, 
                0 === state.length && (state.ended || (state.needReadable = !0), nOrig !== n && state.ended && endReadable(this)), 
                null !== ret && this.emit("data", ret), ret;
            }, Readable.prototype._read = function(n) {
                this.emit("error", new Error("_read() is not implemented"));
            }, Readable.prototype.pipe = function(dest, pipeOpts) {
                var src = this, state = this._readableState;
                switch (state.pipesCount) {
                  case 0:
                    state.pipes = dest;
                    break;

                  case 1:
                    state.pipes = [ state.pipes, dest ];
                    break;

                  default:
                    state.pipes.push(dest);
                }
                state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                var endFn = (!pipeOpts || !1 !== pipeOpts.end) && dest !== process.stdout && dest !== process.stderr ? onend : unpipe;
                function onunpipe(readable, unpipeInfo) {
                    debug("onunpipe"), readable === src && unpipeInfo && !1 === unpipeInfo.hasUnpiped && (unpipeInfo.hasUnpiped = !0, 
                    debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), 
                    dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), 
                    src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), 
                    cleanedUp = !0, !state.awaitDrain || dest._writableState && !dest._writableState.needDrain || ondrain());
                }
                function onend() {
                    debug("onend"), dest.end();
                }
                state.endEmitted ? pna.nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", onunpipe);
                var ondrain = function(src) {
                    return function() {
                        var state = src._readableState;
                        debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, 
                        0 === state.awaitDrain && EElistenerCount(src, "data") && (state.flowing = !0, flow(src));
                    };
                }(src);
                dest.on("drain", ondrain);
                var cleanedUp = !1;
                var increasedAwaitDrain = !1;
                function ondata(chunk) {
                    debug("ondata"), (increasedAwaitDrain = !1) !== dest.write(chunk) || increasedAwaitDrain || ((1 === state.pipesCount && state.pipes === dest || 1 < state.pipesCount && -1 !== indexOf(state.pipes, dest)) && !cleanedUp && (debug("false write response, pause", src._readableState.awaitDrain), 
                    src._readableState.awaitDrain++, increasedAwaitDrain = !0), src.pause());
                }
                function onerror(er) {
                    debug("onerror", er), unpipe(), dest.removeListener("error", onerror), 0 === EElistenerCount(dest, "error") && dest.emit("error", er);
                }
                function onclose() {
                    dest.removeListener("finish", onfinish), unpipe();
                }
                function onfinish() {
                    debug("onfinish"), dest.removeListener("close", onclose), unpipe();
                }
                function unpipe() {
                    debug("unpipe"), src.unpipe(dest);
                }
                return src.on("data", ondata), function(emitter, event, fn) {
                    if ("function" == typeof emitter.prependListener) return emitter.prependListener(event, fn);
                    emitter._events && emitter._events[event] ? isArray(emitter._events[event]) ? emitter._events[event].unshift(fn) : emitter._events[event] = [ fn, emitter._events[event] ] : emitter.on(event, fn);
                }(dest, "error", onerror), dest.once("close", onclose), dest.once("finish", onfinish), 
                dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
            }, Readable.prototype.unpipe = function(dest) {
                var state = this._readableState, unpipeInfo = {
                    hasUnpiped: !1
                };
                if (0 === state.pipesCount) return this;
                if (1 === state.pipesCount) return dest && dest !== state.pipes || (dest || (dest = state.pipes), 
                state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this, unpipeInfo)), 
                this;
                if (!dest) {
                    var dests = state.pipes, len = state.pipesCount;
                    state.pipes = null, state.pipesCount = 0, state.flowing = !1;
                    for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, unpipeInfo);
                    return this;
                }
                var index = indexOf(state.pipes, dest);
                return -1 === index || (state.pipes.splice(index, 1), state.pipesCount -= 1, 1 === state.pipesCount && (state.pipes = state.pipes[0]), 
                dest.emit("unpipe", this, unpipeInfo)), this;
            }, Readable.prototype.addListener = Readable.prototype.on = function(ev, fn) {
                var res = Stream.prototype.on.call(this, ev, fn);
                if ("data" === ev) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === ev) {
                    var state = this._readableState;
                    state.endEmitted || state.readableListening || (state.readableListening = state.needReadable = !0, 
                    state.emittedReadable = !1, state.reading ? state.length && emitReadable(this) : pna.nextTick(nReadingNextTick, this));
                }
                return res;
            }, Readable.prototype.resume = function() {
                var state = this._readableState;
                return state.flowing || (debug("resume"), state.flowing = !0, function(stream, state) {
                    state.resumeScheduled || (state.resumeScheduled = !0, pna.nextTick(resume_, stream, state));
                }(this, state)), this;
            }, Readable.prototype.pause = function() {
                return debug("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (debug("pause"), 
                this._readableState.flowing = !1, this.emit("pause")), this;
            }, Readable.prototype.wrap = function(stream) {
                var _this = this, state = this._readableState, paused = !1;
                for (var i in stream.on("end", function() {
                    if (debug("wrapped end"), state.decoder && !state.ended) {
                        var chunk = state.decoder.end();
                        chunk && chunk.length && _this.push(chunk);
                    }
                    _this.push(null);
                }), stream.on("data", function(chunk) {
                    (debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), state.objectMode && null == chunk) || (state.objectMode || chunk && chunk.length) && (_this.push(chunk) || (paused = !0, 
                    stream.pause()));
                }), stream) void 0 === this[i] && "function" == typeof stream[i] && (this[i] = function(method) {
                    return function() {
                        return stream[method].apply(stream, arguments);
                    };
                }(i));
                for (var n = 0; n < kProxyEvents.length; n++) stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                return this._read = function(n) {
                    debug("wrapped _read", n), paused && (paused = !1, stream.resume());
                }, this;
            }, Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._readableState.highWaterMark;
                }
            }), Readable._fromList = fromList;
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {
        "./_stream_duplex": 62,
        "./internal/streams/BufferList": 67,
        "./internal/streams/destroy": 68,
        "./internal/streams/stream": 69,
        _process: 56,
        "core-util-is": 12,
        events: 26,
        inherits: 46,
        isarray: 48,
        "process-nextick-args": 55,
        "safe-buffer": 74,
        "string_decoder/": 77,
        util: 11
    } ],
    65: [ function(require, module, exports) {
        "use strict";
        module.exports = Transform;
        var Duplex = require("./_stream_duplex"), util = require("core-util-is");
        function Transform(options) {
            if (!(this instanceof Transform)) return new Transform(options);
            Duplex.call(this, options), this._transformState = {
                afterTransform: function(er, data) {
                    var ts = this._transformState;
                    ts.transforming = !1;
                    var cb = ts.writecb;
                    if (!cb) return this.emit("error", new Error("write callback called multiple times"));
                    ts.writechunk = null, (ts.writecb = null) != data && this.push(data), cb(er);
                    var rs = this._readableState;
                    rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
                }.bind(this),
                needTransform: !1,
                transforming: !1,
                writecb: null,
                writechunk: null,
                writeencoding: null
            }, this._readableState.needReadable = !0, this._readableState.sync = !1, options && ("function" == typeof options.transform && (this._transform = options.transform), 
            "function" == typeof options.flush && (this._flush = options.flush)), this.on("prefinish", prefinish);
        }
        function prefinish() {
            var _this = this;
            "function" == typeof this._flush ? this._flush(function(er, data) {
                done(_this, er, data);
            }) : done(this, null, null);
        }
        function done(stream, er, data) {
            if (er) return stream.emit("error", er);
            if (null != data && stream.push(data), stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
            if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
            return stream.push(null);
        }
        util.inherits = require("inherits"), util.inherits(Transform, Duplex), Transform.prototype.push = function(chunk, encoding) {
            return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
        }, Transform.prototype._transform = function(chunk, encoding, cb) {
            throw new Error("_transform() is not implemented");
        }, Transform.prototype._write = function(chunk, encoding, cb) {
            var ts = this._transformState;
            if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
                var rs = this._readableState;
                (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
            }
        }, Transform.prototype._read = function(n) {
            var ts = this._transformState;
            null !== ts.writechunk && ts.writecb && !ts.transforming ? (ts.transforming = !0, 
            this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
        }, Transform.prototype._destroy = function(err, cb) {
            var _this2 = this;
            Duplex.prototype._destroy.call(this, err, function(err2) {
                cb(err2), _this2.emit("close");
            });
        };
    }, {
        "./_stream_duplex": 62,
        "core-util-is": 12,
        inherits: 46
    } ],
    66: [ function(require, module, exports) {
        (function(process, global, setImmediate) {
            "use strict";
            var pna = require("process-nextick-args");
            function CorkedRequest(state) {
                var _this = this;
                this.next = null, this.entry = null, this.finish = function() {
                    !function(corkReq, state, err) {
                        var entry = corkReq.entry;
                        corkReq.entry = null;
                        for (;entry; ) {
                            var cb = entry.callback;
                            state.pendingcb--, cb(err), entry = entry.next;
                        }
                        state.corkedRequestsFree ? state.corkedRequestsFree.next = corkReq : state.corkedRequestsFree = corkReq;
                    }(_this, state);
                };
            }
            module.exports = Writable;
            var Duplex, asyncWrite = !process.browser && -1 < [ "v0.10", "v0.9." ].indexOf(process.version.slice(0, 5)) ? setImmediate : pna.nextTick;
            Writable.WritableState = WritableState;
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var internalUtil = {
                deprecate: require("util-deprecate")
            }, Stream = require("./internal/streams/stream"), Buffer = require("safe-buffer").Buffer, OurUint8Array = global.Uint8Array || function() {};
            var realHasInstance, destroyImpl = require("./internal/streams/destroy");
            function nop() {}
            function WritableState(options, stream) {
                Duplex = Duplex || require("./_stream_duplex"), options = options || {};
                var isDuplex = stream instanceof Duplex;
                this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.writableObjectMode);
                var hwm = options.highWaterMark, writableHwm = options.writableHighWaterMark, defaultHwm = this.objectMode ? 16 : 16384;
                this.highWaterMark = hwm || 0 === hwm ? hwm : isDuplex && (writableHwm || 0 === writableHwm) ? writableHwm : defaultHwm, 
                this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, 
                this.ending = !1, this.ended = !1, this.finished = !1;
                var noDecode = (this.destroyed = !1) === options.decodeStrings;
                this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", 
                this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, 
                this.onwrite = function(er) {
                    !function(stream, er) {
                        var state = stream._writableState, sync = state.sync, cb = state.writecb;
                        if (function(state) {
                            state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
                        }(state), er) !function(stream, state, sync, er, cb) {
                            --state.pendingcb, sync ? (pna.nextTick(cb, er), pna.nextTick(finishMaybe, stream, state), 
                            stream._writableState.errorEmitted = !0, stream.emit("error", er)) : (cb(er), stream._writableState.errorEmitted = !0, 
                            stream.emit("error", er), finishMaybe(stream, state));
                        }(stream, state, sync, er, cb); else {
                            var finished = needFinish(state);
                            finished || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(stream, state), 
                            sync ? asyncWrite(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
                        }
                    }(stream, er);
                }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, 
                this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, 
                this.corkedRequestsFree = new CorkedRequest(this);
            }
            function Writable(options) {
                if (Duplex = Duplex || require("./_stream_duplex"), !(realHasInstance.call(Writable, this) || this instanceof Duplex)) return new Writable(options);
                this._writableState = new WritableState(options, this), this.writable = !0, options && ("function" == typeof options.write && (this._write = options.write), 
                "function" == typeof options.writev && (this._writev = options.writev), "function" == typeof options.destroy && (this._destroy = options.destroy), 
                "function" == typeof options.final && (this._final = options.final)), Stream.call(this);
            }
            function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), 
                state.sync = !1;
            }
            function afterWrite(stream, state, finished, cb) {
                finished || function(stream, state) {
                    0 === state.length && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
                }(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
            }
            function clearBuffer(stream, state) {
                state.bufferProcessing = !0;
                var entry = state.bufferedRequest;
                if (stream._writev && entry && entry.next) {
                    var l = state.bufferedRequestCount, buffer = new Array(l), holder = state.corkedRequestsFree;
                    holder.entry = entry;
                    for (var count = 0, allBuffers = !0; entry; ) (buffer[count] = entry).isBuf || (allBuffers = !1), 
                    entry = entry.next, count += 1;
                    buffer.allBuffers = allBuffers, doWrite(stream, state, !0, state.length, buffer, "", holder.finish), 
                    state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, 
                    holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state), state.bufferedRequestCount = 0;
                } else {
                    for (;entry; ) {
                        var chunk = entry.chunk, encoding = entry.encoding, cb = entry.callback;
                        if (doWrite(stream, state, !1, state.objectMode ? 1 : chunk.length, chunk, encoding, cb), 
                        entry = entry.next, state.bufferedRequestCount--, state.writing) break;
                    }
                    null === entry && (state.lastBufferedRequest = null);
                }
                state.bufferedRequest = entry, state.bufferProcessing = !1;
            }
            function needFinish(state) {
                return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing;
            }
            function callFinal(stream, state) {
                stream._final(function(err) {
                    state.pendingcb--, err && stream.emit("error", err), state.prefinished = !0, stream.emit("prefinish"), 
                    finishMaybe(stream, state);
                });
            }
            function finishMaybe(stream, state) {
                var need = needFinish(state);
                return need && (!function(stream, state) {
                    state.prefinished || state.finalCalled || ("function" == typeof stream._final ? (state.pendingcb++, 
                    state.finalCalled = !0, pna.nextTick(callFinal, stream, state)) : (state.prefinished = !0, 
                    stream.emit("prefinish")));
                }(stream, state), 0 === state.pendingcb && (state.finished = !0, stream.emit("finish"))), 
                need;
            }
            util.inherits(Writable, Stream), WritableState.prototype.getBuffer = function() {
                for (var current = this.bufferedRequest, out = []; current; ) out.push(current), 
                current = current.next;
                return out;
            }, function() {
                try {
                    Object.defineProperty(WritableState.prototype, "buffer", {
                        get: internalUtil.deprecate(function() {
                            return this.getBuffer();
                        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                    });
                } catch (_) {}
            }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (realHasInstance = Function.prototype[Symbol.hasInstance], 
            Object.defineProperty(Writable, Symbol.hasInstance, {
                value: function(object) {
                    return !!realHasInstance.call(this, object) || this === Writable && (object && object._writableState instanceof WritableState);
                }
            })) : realHasInstance = function(object) {
                return object instanceof this;
            }, Writable.prototype.pipe = function() {
                this.emit("error", new Error("Cannot pipe, not readable"));
            }, Writable.prototype.write = function(chunk, encoding, cb) {
                var obj, state = this._writableState, ret = !1, isBuf = !state.objectMode && (obj = chunk, 
                Buffer.isBuffer(obj) || obj instanceof OurUint8Array);
                return isBuf && !Buffer.isBuffer(chunk) && (chunk = function(chunk) {
                    return Buffer.from(chunk);
                }(chunk)), "function" == typeof encoding && (cb = encoding, encoding = null), isBuf ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), 
                "function" != typeof cb && (cb = nop), state.ended ? function(stream, cb) {
                    var er = new Error("write after end");
                    stream.emit("error", er), pna.nextTick(cb, er);
                }(this, cb) : (isBuf || function(stream, state, chunk, cb) {
                    var valid = !0, er = !1;
                    return null === chunk ? er = new TypeError("May not write null values to stream") : "string" == typeof chunk || void 0 === chunk || state.objectMode || (er = new TypeError("Invalid non-string/buffer chunk")), 
                    er && (stream.emit("error", er), pna.nextTick(cb, er), valid = !1), valid;
                }(this, state, chunk, cb)) && (state.pendingcb++, ret = function(stream, state, isBuf, chunk, encoding, cb) {
                    if (!isBuf) {
                        var newChunk = function(state, chunk, encoding) {
                            state.objectMode || !1 === state.decodeStrings || "string" != typeof chunk || (chunk = Buffer.from(chunk, encoding));
                            return chunk;
                        }(state, chunk, encoding);
                        chunk !== newChunk && (isBuf = !0, encoding = "buffer", chunk = newChunk);
                    }
                    var len = state.objectMode ? 1 : chunk.length;
                    state.length += len;
                    var ret = state.length < state.highWaterMark;
                    ret || (state.needDrain = !0);
                    if (state.writing || state.corked) {
                        var last = state.lastBufferedRequest;
                        state.lastBufferedRequest = {
                            chunk: chunk,
                            encoding: encoding,
                            isBuf: isBuf,
                            callback: cb,
                            next: null
                        }, last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, 
                        state.bufferedRequestCount += 1;
                    } else doWrite(stream, state, !1, len, chunk, encoding, cb);
                    return ret;
                }(this, state, isBuf, chunk, encoding, cb)), ret;
            }, Writable.prototype.cork = function() {
                this._writableState.corked++;
            }, Writable.prototype.uncork = function() {
                var state = this._writableState;
                state.corked && (state.corked--, state.writing || state.corked || state.finished || state.bufferProcessing || !state.bufferedRequest || clearBuffer(this, state));
            }, Writable.prototype.setDefaultEncoding = function(encoding) {
                if ("string" == typeof encoding && (encoding = encoding.toLowerCase()), !(-1 < [ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((encoding + "").toLowerCase()))) throw new TypeError("Unknown encoding: " + encoding);
                return this._writableState.defaultEncoding = encoding, this;
            }, Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._writableState.highWaterMark;
                }
            }), Writable.prototype._write = function(chunk, encoding, cb) {
                cb(new Error("_write() is not implemented"));
            }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb) {
                var state = this._writableState;
                "function" == typeof chunk ? (cb = chunk, encoding = chunk = null) : "function" == typeof encoding && (cb = encoding, 
                encoding = null), null != chunk && this.write(chunk, encoding), state.corked && (state.corked = 1, 
                this.uncork()), state.ending || state.finished || function(stream, state, cb) {
                    state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? pna.nextTick(cb) : stream.once("finish", cb));
                    state.ended = !0, stream.writable = !1;
                }(this, state, cb);
            }, Object.defineProperty(Writable.prototype, "destroyed", {
                get: function() {
                    return void 0 !== this._writableState && this._writableState.destroyed;
                },
                set: function(value) {
                    this._writableState && (this._writableState.destroyed = value);
                }
            }), Writable.prototype.destroy = destroyImpl.destroy, Writable.prototype._undestroy = destroyImpl.undestroy, 
            Writable.prototype._destroy = function(err, cb) {
                this.end(), cb(err);
            };
        }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, require("timers").setImmediate);
    }, {
        "./_stream_duplex": 62,
        "./internal/streams/destroy": 68,
        "./internal/streams/stream": 69,
        _process: 56,
        "core-util-is": 12,
        inherits: 46,
        "process-nextick-args": 55,
        "safe-buffer": 74,
        timers: 78,
        "util-deprecate": 80
    } ],
    67: [ function(require, module, exports) {
        "use strict";
        var Buffer = require("safe-buffer").Buffer, util = require("util");
        module.exports = function() {
            function BufferList() {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, BufferList), this.head = null, this.tail = null, this.length = 0;
            }
            return BufferList.prototype.push = function(v) {
                var entry = {
                    data: v,
                    next: null
                };
                0 < this.length ? this.tail.next = entry : this.head = entry, this.tail = entry, 
                ++this.length;
            }, BufferList.prototype.unshift = function(v) {
                var entry = {
                    data: v,
                    next: this.head
                };
                0 === this.length && (this.tail = entry), this.head = entry, ++this.length;
            }, BufferList.prototype.shift = function() {
                if (0 !== this.length) {
                    var ret = this.head.data;
                    return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, 
                    --this.length, ret;
                }
            }, BufferList.prototype.clear = function() {
                this.head = this.tail = null, this.length = 0;
            }, BufferList.prototype.join = function(s) {
                if (0 === this.length) return "";
                for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
                return ret;
            }, BufferList.prototype.concat = function(n) {
                if (0 === this.length) return Buffer.alloc(0);
                if (1 === this.length) return this.head.data;
                for (var src, target, offset, ret = Buffer.allocUnsafe(n >>> 0), p = this.head, i = 0; p; ) src = p.data, 
                target = ret, offset = i, src.copy(target, offset), i += p.data.length, p = p.next;
                return ret;
            }, BufferList;
        }(), util && util.inspect && util.inspect.custom && (module.exports.prototype[util.inspect.custom] = function() {
            var obj = util.inspect({
                length: this.length
            });
            return this.constructor.name + " " + obj;
        });
    }, {
        "safe-buffer": 74,
        util: 11
    } ],
    68: [ function(require, module, exports) {
        "use strict";
        var pna = require("process-nextick-args");
        function emitErrorNT(self, err) {
            self.emit("error", err);
        }
        module.exports = {
            destroy: function(err, cb) {
                var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
                return readableDestroyed || writableDestroyed ? cb ? cb(err) : !err || this._writableState && this._writableState.errorEmitted || pna.nextTick(emitErrorNT, this, err) : (this._readableState && (this._readableState.destroyed = !0), 
                this._writableState && (this._writableState.destroyed = !0), this._destroy(err || null, function(err) {
                    !cb && err ? (pna.nextTick(emitErrorNT, _this, err), _this._writableState && (_this._writableState.errorEmitted = !0)) : cb && cb(err);
                })), this;
            },
            undestroy: function() {
                this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, 
                this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, 
                this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, 
                this._writableState.errorEmitted = !1);
            }
        };
    }, {
        "process-nextick-args": 55
    } ],
    69: [ function(require, module, exports) {
        module.exports = require("events").EventEmitter;
    }, {
        events: 26
    } ],
    70: [ function(require, module, exports) {
        module.exports = require("./readable").PassThrough;
    }, {
        "./readable": 71
    } ],
    71: [ function(require, module, exports) {
        (((exports = module.exports = require("./lib/_stream_readable.js")).Stream = exports).Readable = exports).Writable = require("./lib/_stream_writable.js"), 
        exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), 
        exports.PassThrough = require("./lib/_stream_passthrough.js");
    }, {
        "./lib/_stream_duplex.js": 62,
        "./lib/_stream_passthrough.js": 63,
        "./lib/_stream_readable.js": 64,
        "./lib/_stream_transform.js": 65,
        "./lib/_stream_writable.js": 66
    } ],
    72: [ function(require, module, exports) {
        module.exports = require("./readable").Transform;
    }, {
        "./readable": 71
    } ],
    73: [ function(require, module, exports) {
        module.exports = require("./lib/_stream_writable.js");
    }, {
        "./lib/_stream_writable.js": 66
    } ],
    74: [ function(require, module, exports) {
        var buffer = require("buffer"), Buffer = buffer.Buffer;
        function copyProps(src, dst) {
            for (var key in src) dst[key] = src[key];
        }
        function SafeBuffer(arg, encodingOrOffset, length) {
            return Buffer(arg, encodingOrOffset, length);
        }
        Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), 
        exports.Buffer = SafeBuffer), copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
            if ("number" == typeof arg) throw new TypeError("Argument must not be a number");
            return Buffer(arg, encodingOrOffset, length);
        }, SafeBuffer.alloc = function(size, fill, encoding) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            var buf = Buffer(size);
            return void 0 !== fill ? "string" == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), 
            buf;
        }, SafeBuffer.allocUnsafe = function(size) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            return Buffer(size);
        }, SafeBuffer.allocUnsafeSlow = function(size) {
            if ("number" != typeof size) throw new TypeError("Argument must be a number");
            return buffer.SlowBuffer(size);
        };
    }, {
        buffer: 24
    } ],
    75: [ function(require, module, exports) {
        (function(Buffer) {
            !function(sax) {
                sax.parser = function(strict, opt) {
                    return new SAXParser(strict, opt);
                }, sax.SAXParser = SAXParser, sax.SAXStream = SAXStream, sax.createStream = function(strict, opt) {
                    return new SAXStream(strict, opt);
                }, sax.MAX_BUFFER_LENGTH = 65536;
                var Stream, buffers = [ "comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script" ];
                function SAXParser(strict, opt) {
                    if (!(this instanceof SAXParser)) return new SAXParser(strict, opt);
                    !function(parser) {
                        for (var i = 0, l = buffers.length; i < l; i++) parser[buffers[i]] = "";
                    }(this), this.q = this.c = "", this.bufferCheckPosition = sax.MAX_BUFFER_LENGTH, 
                    this.opt = opt || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, 
                    this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], 
                    this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, 
                    this.strict = !!strict, this.noscript = !(!strict && !this.opt.noscript), this.state = S.BEGIN, 
                    this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES), 
                    this.attribList = [], this.opt.xmlns && (this.ns = Object.create(rootNS)), this.trackPosition = !1 !== this.opt.position, 
                    this.trackPosition && (this.position = this.line = this.column = 0), emit(this, "onready");
                }
                sax.EVENTS = [ "text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace" ], 
                Object.create || (Object.create = function(o) {
                    function F() {}
                    return F.prototype = o, new F();
                }), Object.keys || (Object.keys = function(o) {
                    var a = [];
                    for (var i in o) o.hasOwnProperty(i) && a.push(i);
                    return a;
                }), SAXParser.prototype = {
                    end: function() {
                        end(this);
                    },
                    write: function(chunk) {
                        if (this.error) throw this.error;
                        if (this.closed) return error(this, "Cannot write after close. Assign an onready handler.");
                        if (null === chunk) return end(this);
                        "object" == typeof chunk && (chunk = chunk.toString());
                        var i = 0, c = "";
                        for (;c = charAt(chunk, i++), this.c = c; ) switch (this.trackPosition && (this.position++, 
                        "\n" === c ? (this.line++, this.column = 0) : this.column++), this.state) {
                          case S.BEGIN:
                            if (this.state = S.BEGIN_WHITESPACE, "\ufeff" === c) continue;
                            beginWhiteSpace(this, c);
                            continue;

                          case S.BEGIN_WHITESPACE:
                            beginWhiteSpace(this, c);
                            continue;

                          case S.TEXT:
                            if (this.sawRoot && !this.closedRoot) {
                                for (var starti = i - 1; c && "<" !== c && "&" !== c; ) (c = charAt(chunk, i++)) && this.trackPosition && (this.position++, 
                                "\n" === c ? (this.line++, this.column = 0) : this.column++);
                                this.textNode += chunk.substring(starti, i - 1);
                            }
                            "<" !== c || this.sawRoot && this.closedRoot && !this.strict ? (isWhitespace(c) || this.sawRoot && !this.closedRoot || strictFail(this, "Text data outside of root node."), 
                            "&" === c ? this.state = S.TEXT_ENTITY : this.textNode += c) : (this.state = S.OPEN_WAKA, 
                            this.startTagPosition = this.position);
                            continue;

                          case S.SCRIPT:
                            "<" === c ? this.state = S.SCRIPT_ENDING : this.script += c;
                            continue;

                          case S.SCRIPT_ENDING:
                            "/" === c ? this.state = S.CLOSE_TAG : (this.script += "<" + c, this.state = S.SCRIPT);
                            continue;

                          case S.OPEN_WAKA:
                            if ("!" === c) this.state = S.SGML_DECL, this.sgmlDecl = ""; else if (isWhitespace(c)) ; else if (isMatch(nameStart, c)) this.state = S.OPEN_TAG, 
                            this.tagName = c; else if ("/" === c) this.state = S.CLOSE_TAG, this.tagName = ""; else if ("?" === c) this.state = S.PROC_INST, 
                            this.procInstName = this.procInstBody = ""; else {
                                if (strictFail(this, "Unencoded <"), this.startTagPosition + 1 < this.position) {
                                    var pad = this.position - this.startTagPosition;
                                    c = new Array(pad).join(" ") + c;
                                }
                                this.textNode += "<" + c, this.state = S.TEXT;
                            }
                            continue;

                          case S.SGML_DECL:
                            (this.sgmlDecl + c).toUpperCase() === CDATA ? (emitNode(this, "onopencdata"), this.state = S.CDATA, 
                            this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + c === "--" ? (this.state = S.COMMENT, 
                            this.comment = "", this.sgmlDecl = "") : (this.sgmlDecl + c).toUpperCase() === DOCTYPE ? (this.state = S.DOCTYPE, 
                            (this.doctype || this.sawRoot) && strictFail(this, "Inappropriately located doctype declaration"), 
                            this.doctype = "", this.sgmlDecl = "") : ">" === c ? (emitNode(this, "onsgmldeclaration", this.sgmlDecl), 
                            this.sgmlDecl = "", this.state = S.TEXT) : (isQuote(c) && (this.state = S.SGML_DECL_QUOTED), 
                            this.sgmlDecl += c);
                            continue;

                          case S.SGML_DECL_QUOTED:
                            c === this.q && (this.state = S.SGML_DECL, this.q = ""), this.sgmlDecl += c;
                            continue;

                          case S.DOCTYPE:
                            ">" === c ? (this.state = S.TEXT, emitNode(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += c, 
                            "[" === c ? this.state = S.DOCTYPE_DTD : isQuote(c) && (this.state = S.DOCTYPE_QUOTED, 
                            this.q = c));
                            continue;

                          case S.DOCTYPE_QUOTED:
                            this.doctype += c, c === this.q && (this.q = "", this.state = S.DOCTYPE);
                            continue;

                          case S.DOCTYPE_DTD:
                            this.doctype += c, "]" === c ? this.state = S.DOCTYPE : isQuote(c) && (this.state = S.DOCTYPE_DTD_QUOTED, 
                            this.q = c);
                            continue;

                          case S.DOCTYPE_DTD_QUOTED:
                            this.doctype += c, c === this.q && (this.state = S.DOCTYPE_DTD, this.q = "");
                            continue;

                          case S.COMMENT:
                            "-" === c ? this.state = S.COMMENT_ENDING : this.comment += c;
                            continue;

                          case S.COMMENT_ENDING:
                            "-" === c ? (this.state = S.COMMENT_ENDED, this.comment = textopts(this.opt, this.comment), 
                            this.comment && emitNode(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + c, 
                            this.state = S.COMMENT);
                            continue;

                          case S.COMMENT_ENDED:
                            ">" !== c ? (strictFail(this, "Malformed comment"), this.comment += "--" + c, this.state = S.COMMENT) : this.state = S.TEXT;
                            continue;

                          case S.CDATA:
                            "]" === c ? this.state = S.CDATA_ENDING : this.cdata += c;
                            continue;

                          case S.CDATA_ENDING:
                            "]" === c ? this.state = S.CDATA_ENDING_2 : (this.cdata += "]" + c, this.state = S.CDATA);
                            continue;

                          case S.CDATA_ENDING_2:
                            ">" === c ? (this.cdata && emitNode(this, "oncdata", this.cdata), emitNode(this, "onclosecdata"), 
                            this.cdata = "", this.state = S.TEXT) : "]" === c ? this.cdata += "]" : (this.cdata += "]]" + c, 
                            this.state = S.CDATA);
                            continue;

                          case S.PROC_INST:
                            "?" === c ? this.state = S.PROC_INST_ENDING : isWhitespace(c) ? this.state = S.PROC_INST_BODY : this.procInstName += c;
                            continue;

                          case S.PROC_INST_BODY:
                            if (!this.procInstBody && isWhitespace(c)) continue;
                            "?" === c ? this.state = S.PROC_INST_ENDING : this.procInstBody += c;
                            continue;

                          case S.PROC_INST_ENDING:
                            ">" === c ? (emitNode(this, "onprocessinginstruction", {
                                name: this.procInstName,
                                body: this.procInstBody
                            }), this.procInstName = this.procInstBody = "", this.state = S.TEXT) : (this.procInstBody += "?" + c, 
                            this.state = S.PROC_INST_BODY);
                            continue;

                          case S.OPEN_TAG:
                            isMatch(nameBody, c) ? this.tagName += c : (newTag(this), ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : (isWhitespace(c) || strictFail(this, "Invalid character in tag name"), 
                            this.state = S.ATTRIB));
                            continue;

                          case S.OPEN_TAG_SLASH:
                            ">" === c ? (openTag(this, !0), closeTag(this)) : (strictFail(this, "Forward-slash in opening tag not followed by >"), 
                            this.state = S.ATTRIB);
                            continue;

                          case S.ATTRIB:
                            if (isWhitespace(c)) continue;
                            ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (this.attribName = c, 
                            this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                            continue;

                          case S.ATTRIB_NAME:
                            "=" === c ? this.state = S.ATTRIB_VALUE : ">" === c ? (strictFail(this, "Attribute without value"), 
                            this.attribValue = this.attribName, attrib(this), openTag(this)) : isWhitespace(c) ? this.state = S.ATTRIB_NAME_SAW_WHITE : isMatch(nameBody, c) ? this.attribName += c : strictFail(this, "Invalid attribute name");
                            continue;

                          case S.ATTRIB_NAME_SAW_WHITE:
                            if ("=" === c) this.state = S.ATTRIB_VALUE; else {
                                if (isWhitespace(c)) continue;
                                strictFail(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", 
                                this.attribValue = "", emitNode(this, "onattribute", {
                                    name: this.attribName,
                                    value: ""
                                }), this.attribName = "", ">" === c ? openTag(this) : isMatch(nameStart, c) ? (this.attribName = c, 
                                this.state = S.ATTRIB_NAME) : (strictFail(this, "Invalid attribute name"), this.state = S.ATTRIB);
                            }
                            continue;

                          case S.ATTRIB_VALUE:
                            if (isWhitespace(c)) continue;
                            isQuote(c) ? (this.q = c, this.state = S.ATTRIB_VALUE_QUOTED) : (strictFail(this, "Unquoted attribute value"), 
                            this.state = S.ATTRIB_VALUE_UNQUOTED, this.attribValue = c);
                            continue;

                          case S.ATTRIB_VALUE_QUOTED:
                            if (c !== this.q) {
                                "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_Q : this.attribValue += c;
                                continue;
                            }
                            attrib(this), this.q = "", this.state = S.ATTRIB_VALUE_CLOSED;
                            continue;

                          case S.ATTRIB_VALUE_CLOSED:
                            isWhitespace(c) ? this.state = S.ATTRIB : ">" === c ? openTag(this) : "/" === c ? this.state = S.OPEN_TAG_SLASH : isMatch(nameStart, c) ? (strictFail(this, "No whitespace between attributes"), 
                            this.attribName = c, this.attribValue = "", this.state = S.ATTRIB_NAME) : strictFail(this, "Invalid attribute name");
                            continue;

                          case S.ATTRIB_VALUE_UNQUOTED:
                            if (!isAttribEnd(c)) {
                                "&" === c ? this.state = S.ATTRIB_VALUE_ENTITY_U : this.attribValue += c;
                                continue;
                            }
                            attrib(this), ">" === c ? openTag(this) : this.state = S.ATTRIB;
                            continue;

                          case S.CLOSE_TAG:
                            if (this.tagName) ">" === c ? closeTag(this) : isMatch(nameBody, c) ? this.tagName += c : this.script ? (this.script += "</" + this.tagName, 
                            this.tagName = "", this.state = S.SCRIPT) : (isWhitespace(c) || strictFail(this, "Invalid tagname in closing tag"), 
                            this.state = S.CLOSE_TAG_SAW_WHITE); else {
                                if (isWhitespace(c)) continue;
                                notMatch(nameStart, c) ? this.script ? (this.script += "</" + c, this.state = S.SCRIPT) : strictFail(this, "Invalid tagname in closing tag.") : this.tagName = c;
                            }
                            continue;

                          case S.CLOSE_TAG_SAW_WHITE:
                            if (isWhitespace(c)) continue;
                            ">" === c ? closeTag(this) : strictFail(this, "Invalid characters in closing tag");
                            continue;

                          case S.TEXT_ENTITY:
                          case S.ATTRIB_VALUE_ENTITY_Q:
                          case S.ATTRIB_VALUE_ENTITY_U:
                            var returnState, buffer;
                            switch (this.state) {
                              case S.TEXT_ENTITY:
                                returnState = S.TEXT, buffer = "textNode";
                                break;

                              case S.ATTRIB_VALUE_ENTITY_Q:
                                returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue";
                                break;

                              case S.ATTRIB_VALUE_ENTITY_U:
                                returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue";
                            }
                            ";" === c ? (this[buffer] += parseEntity(this), this.entity = "", this.state = returnState) : isMatch(this.entity.length ? entityBody : entityStart, c) ? this.entity += c : (strictFail(this, "Invalid character in entity name"), 
                            this[buffer] += "&" + this.entity + c, this.entity = "", this.state = returnState);
                            continue;

                          default:
                            throw new Error(this, "Unknown state: " + this.state);
                        }
                        this.position >= this.bufferCheckPosition && function(parser) {
                            for (var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10), maxActual = 0, i = 0, l = buffers.length; i < l; i++) {
                                var len = parser[buffers[i]].length;
                                if (maxAllowed < len) switch (buffers[i]) {
                                  case "textNode":
                                    closeText(parser);
                                    break;

                                  case "cdata":
                                    emitNode(parser, "oncdata", parser.cdata), parser.cdata = "";
                                    break;

                                  case "script":
                                    emitNode(parser, "onscript", parser.script), parser.script = "";
                                    break;

                                  default:
                                    error(parser, "Max buffer length exceeded: " + buffers[i]);
                                }
                                maxActual = Math.max(maxActual, len);
                            }
                            var m = sax.MAX_BUFFER_LENGTH - maxActual;
                            parser.bufferCheckPosition = m + parser.position;
                        }(this);
                        return this;
                    },
                    resume: function() {
                        return this.error = null, this;
                    },
                    close: function() {
                        return this.write(null);
                    },
                    flush: function() {
                        var parser;
                        closeText(parser = this), "" !== parser.cdata && (emitNode(parser, "oncdata", parser.cdata), 
                        parser.cdata = ""), "" !== parser.script && (emitNode(parser, "onscript", parser.script), 
                        parser.script = "");
                    }
                };
                try {
                    Stream = require("stream").Stream;
                } catch (ex) {
                    Stream = function() {};
                }
                var streamWraps = sax.EVENTS.filter(function(ev) {
                    return "error" !== ev && "end" !== ev;
                });
                function SAXStream(strict, opt) {
                    if (!(this instanceof SAXStream)) return new SAXStream(strict, opt);
                    Stream.apply(this), this._parser = new SAXParser(strict, opt), this.writable = !0, 
                    this.readable = !0;
                    var me = this;
                    this._parser.onend = function() {
                        me.emit("end");
                    }, this._parser.onerror = function(er) {
                        me.emit("error", er), me._parser.error = null;
                    }, this._decoder = null, streamWraps.forEach(function(ev) {
                        Object.defineProperty(me, "on" + ev, {
                            get: function() {
                                return me._parser["on" + ev];
                            },
                            set: function(h) {
                                if (!h) return me.removeAllListeners(ev), me._parser["on" + ev] = h;
                                me.on(ev, h);
                            },
                            enumerable: !0,
                            configurable: !1
                        });
                    });
                }
                (SAXStream.prototype = Object.create(Stream.prototype, {
                    constructor: {
                        value: SAXStream
                    }
                })).write = function(data) {
                    if ("function" == typeof Buffer && "function" == typeof Buffer.isBuffer && Buffer.isBuffer(data)) {
                        if (!this._decoder) {
                            var SD = require("string_decoder").StringDecoder;
                            this._decoder = new SD("utf8");
                        }
                        data = this._decoder.write(data);
                    }
                    return this._parser.write(data.toString()), this.emit("data", data), !0;
                }, SAXStream.prototype.end = function(chunk) {
                    return chunk && chunk.length && this.write(chunk), this._parser.end(), !0;
                }, SAXStream.prototype.on = function(ev, handler) {
                    var me = this;
                    return me._parser["on" + ev] || -1 === streamWraps.indexOf(ev) || (me._parser["on" + ev] = function() {
                        var args = 1 === arguments.length ? [ arguments[0] ] : Array.apply(null, arguments);
                        args.splice(0, 0, ev), me.emit.apply(me, args);
                    }), Stream.prototype.on.call(me, ev, handler);
                };
                var CDATA = "[CDATA[", DOCTYPE = "DOCTYPE", XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace", XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/", rootNS = {
                    xml: XML_NAMESPACE,
                    xmlns: XMLNS_NAMESPACE
                }, nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
                function isWhitespace(c) {
                    return " " === c || "\n" === c || "\r" === c || "\t" === c;
                }
                function isQuote(c) {
                    return '"' === c || "'" === c;
                }
                function isAttribEnd(c) {
                    return ">" === c || isWhitespace(c);
                }
                function isMatch(regex, c) {
                    return regex.test(c);
                }
                function notMatch(regex, c) {
                    return !isMatch(regex, c);
                }
                var stringFromCharCode, floor, fromCodePoint, S = 0;
                for (var s in sax.STATE = {
                    BEGIN: S++,
                    BEGIN_WHITESPACE: S++,
                    TEXT: S++,
                    TEXT_ENTITY: S++,
                    OPEN_WAKA: S++,
                    SGML_DECL: S++,
                    SGML_DECL_QUOTED: S++,
                    DOCTYPE: S++,
                    DOCTYPE_QUOTED: S++,
                    DOCTYPE_DTD: S++,
                    DOCTYPE_DTD_QUOTED: S++,
                    COMMENT_STARTING: S++,
                    COMMENT: S++,
                    COMMENT_ENDING: S++,
                    COMMENT_ENDED: S++,
                    CDATA: S++,
                    CDATA_ENDING: S++,
                    CDATA_ENDING_2: S++,
                    PROC_INST: S++,
                    PROC_INST_BODY: S++,
                    PROC_INST_ENDING: S++,
                    OPEN_TAG: S++,
                    OPEN_TAG_SLASH: S++,
                    ATTRIB: S++,
                    ATTRIB_NAME: S++,
                    ATTRIB_NAME_SAW_WHITE: S++,
                    ATTRIB_VALUE: S++,
                    ATTRIB_VALUE_QUOTED: S++,
                    ATTRIB_VALUE_CLOSED: S++,
                    ATTRIB_VALUE_UNQUOTED: S++,
                    ATTRIB_VALUE_ENTITY_Q: S++,
                    ATTRIB_VALUE_ENTITY_U: S++,
                    CLOSE_TAG: S++,
                    CLOSE_TAG_SAW_WHITE: S++,
                    SCRIPT: S++,
                    SCRIPT_ENDING: S++
                }, sax.XML_ENTITIES = {
                    amp: "&",
                    gt: ">",
                    lt: "<",
                    quot: '"',
                    apos: "'"
                }, sax.ENTITIES = {
                    amp: "&",
                    gt: ">",
                    lt: "<",
                    quot: '"',
                    apos: "'",
                    AElig: 198,
                    Aacute: 193,
                    Acirc: 194,
                    Agrave: 192,
                    Aring: 197,
                    Atilde: 195,
                    Auml: 196,
                    Ccedil: 199,
                    ETH: 208,
                    Eacute: 201,
                    Ecirc: 202,
                    Egrave: 200,
                    Euml: 203,
                    Iacute: 205,
                    Icirc: 206,
                    Igrave: 204,
                    Iuml: 207,
                    Ntilde: 209,
                    Oacute: 211,
                    Ocirc: 212,
                    Ograve: 210,
                    Oslash: 216,
                    Otilde: 213,
                    Ouml: 214,
                    THORN: 222,
                    Uacute: 218,
                    Ucirc: 219,
                    Ugrave: 217,
                    Uuml: 220,
                    Yacute: 221,
                    aacute: 225,
                    acirc: 226,
                    aelig: 230,
                    agrave: 224,
                    aring: 229,
                    atilde: 227,
                    auml: 228,
                    ccedil: 231,
                    eacute: 233,
                    ecirc: 234,
                    egrave: 232,
                    eth: 240,
                    euml: 235,
                    iacute: 237,
                    icirc: 238,
                    igrave: 236,
                    iuml: 239,
                    ntilde: 241,
                    oacute: 243,
                    ocirc: 244,
                    ograve: 242,
                    oslash: 248,
                    otilde: 245,
                    ouml: 246,
                    szlig: 223,
                    thorn: 254,
                    uacute: 250,
                    ucirc: 251,
                    ugrave: 249,
                    uuml: 252,
                    yacute: 253,
                    yuml: 255,
                    copy: 169,
                    reg: 174,
                    nbsp: 160,
                    iexcl: 161,
                    cent: 162,
                    pound: 163,
                    curren: 164,
                    yen: 165,
                    brvbar: 166,
                    sect: 167,
                    uml: 168,
                    ordf: 170,
                    laquo: 171,
                    not: 172,
                    shy: 173,
                    macr: 175,
                    deg: 176,
                    plusmn: 177,
                    sup1: 185,
                    sup2: 178,
                    sup3: 179,
                    acute: 180,
                    micro: 181,
                    para: 182,
                    middot: 183,
                    cedil: 184,
                    ordm: 186,
                    raquo: 187,
                    frac14: 188,
                    frac12: 189,
                    frac34: 190,
                    iquest: 191,
                    times: 215,
                    divide: 247,
                    OElig: 338,
                    oelig: 339,
                    Scaron: 352,
                    scaron: 353,
                    Yuml: 376,
                    fnof: 402,
                    circ: 710,
                    tilde: 732,
                    Alpha: 913,
                    Beta: 914,
                    Gamma: 915,
                    Delta: 916,
                    Epsilon: 917,
                    Zeta: 918,
                    Eta: 919,
                    Theta: 920,
                    Iota: 921,
                    Kappa: 922,
                    Lambda: 923,
                    Mu: 924,
                    Nu: 925,
                    Xi: 926,
                    Omicron: 927,
                    Pi: 928,
                    Rho: 929,
                    Sigma: 931,
                    Tau: 932,
                    Upsilon: 933,
                    Phi: 934,
                    Chi: 935,
                    Psi: 936,
                    Omega: 937,
                    alpha: 945,
                    beta: 946,
                    gamma: 947,
                    delta: 948,
                    epsilon: 949,
                    zeta: 950,
                    eta: 951,
                    theta: 952,
                    iota: 953,
                    kappa: 954,
                    lambda: 955,
                    mu: 956,
                    nu: 957,
                    xi: 958,
                    omicron: 959,
                    pi: 960,
                    rho: 961,
                    sigmaf: 962,
                    sigma: 963,
                    tau: 964,
                    upsilon: 965,
                    phi: 966,
                    chi: 967,
                    psi: 968,
                    omega: 969,
                    thetasym: 977,
                    upsih: 978,
                    piv: 982,
                    ensp: 8194,
                    emsp: 8195,
                    thinsp: 8201,
                    zwnj: 8204,
                    zwj: 8205,
                    lrm: 8206,
                    rlm: 8207,
                    ndash: 8211,
                    mdash: 8212,
                    lsquo: 8216,
                    rsquo: 8217,
                    sbquo: 8218,
                    ldquo: 8220,
                    rdquo: 8221,
                    bdquo: 8222,
                    dagger: 8224,
                    Dagger: 8225,
                    bull: 8226,
                    hellip: 8230,
                    permil: 8240,
                    prime: 8242,
                    Prime: 8243,
                    lsaquo: 8249,
                    rsaquo: 8250,
                    oline: 8254,
                    frasl: 8260,
                    euro: 8364,
                    image: 8465,
                    weierp: 8472,
                    real: 8476,
                    trade: 8482,
                    alefsym: 8501,
                    larr: 8592,
                    uarr: 8593,
                    rarr: 8594,
                    darr: 8595,
                    harr: 8596,
                    crarr: 8629,
                    lArr: 8656,
                    uArr: 8657,
                    rArr: 8658,
                    dArr: 8659,
                    hArr: 8660,
                    forall: 8704,
                    part: 8706,
                    exist: 8707,
                    empty: 8709,
                    nabla: 8711,
                    isin: 8712,
                    notin: 8713,
                    ni: 8715,
                    prod: 8719,
                    sum: 8721,
                    minus: 8722,
                    lowast: 8727,
                    radic: 8730,
                    prop: 8733,
                    infin: 8734,
                    ang: 8736,
                    and: 8743,
                    or: 8744,
                    cap: 8745,
                    cup: 8746,
                    int: 8747,
                    there4: 8756,
                    sim: 8764,
                    cong: 8773,
                    asymp: 8776,
                    ne: 8800,
                    equiv: 8801,
                    le: 8804,
                    ge: 8805,
                    sub: 8834,
                    sup: 8835,
                    nsub: 8836,
                    sube: 8838,
                    supe: 8839,
                    oplus: 8853,
                    otimes: 8855,
                    perp: 8869,
                    sdot: 8901,
                    lceil: 8968,
                    rceil: 8969,
                    lfloor: 8970,
                    rfloor: 8971,
                    lang: 9001,
                    rang: 9002,
                    loz: 9674,
                    spades: 9824,
                    clubs: 9827,
                    hearts: 9829,
                    diams: 9830
                }, Object.keys(sax.ENTITIES).forEach(function(key) {
                    var e = sax.ENTITIES[key], s = "number" == typeof e ? String.fromCharCode(e) : e;
                    sax.ENTITIES[key] = s;
                }), sax.STATE) sax.STATE[sax.STATE[s]] = s;
                function emit(parser, event, data) {
                    parser[event] && parser[event](data);
                }
                function emitNode(parser, nodeType, data) {
                    parser.textNode && closeText(parser), emit(parser, nodeType, data);
                }
                function closeText(parser) {
                    parser.textNode = textopts(parser.opt, parser.textNode), parser.textNode && emit(parser, "ontext", parser.textNode), 
                    parser.textNode = "";
                }
                function textopts(opt, text) {
                    return opt.trim && (text = text.trim()), opt.normalize && (text = text.replace(/\s+/g, " ")), 
                    text;
                }
                function error(parser, er) {
                    return closeText(parser), parser.trackPosition && (er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c), 
                    er = new Error(er), parser.error = er, emit(parser, "onerror", er), parser;
                }
                function end(parser) {
                    return parser.sawRoot && !parser.closedRoot && strictFail(parser, "Unclosed root tag"), 
                    parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT && error(parser, "Unexpected end"), 
                    closeText(parser), parser.c = "", parser.closed = !0, emit(parser, "onend"), SAXParser.call(parser, parser.strict, parser.opt), 
                    parser;
                }
                function strictFail(parser, message) {
                    if ("object" != typeof parser || !(parser instanceof SAXParser)) throw new Error("bad call to strictFail");
                    parser.strict && error(parser, message);
                }
                function newTag(parser) {
                    parser.strict || (parser.tagName = parser.tagName[parser.looseCase]());
                    var parent = parser.tags[parser.tags.length - 1] || parser, tag = parser.tag = {
                        name: parser.tagName,
                        attributes: {}
                    };
                    parser.opt.xmlns && (tag.ns = parent.ns), parser.attribList.length = 0, emitNode(parser, "onopentagstart", tag);
                }
                function qname(name, attribute) {
                    var qualName = name.indexOf(":") < 0 ? [ "", name ] : name.split(":"), prefix = qualName[0], local = qualName[1];
                    return attribute && "xmlns" === name && (prefix = "xmlns", local = ""), {
                        prefix: prefix,
                        local: local
                    };
                }
                function attrib(parser) {
                    if (parser.strict || (parser.attribName = parser.attribName[parser.looseCase]()), 
                    -1 !== parser.attribList.indexOf(parser.attribName) || parser.tag.attributes.hasOwnProperty(parser.attribName)) parser.attribName = parser.attribValue = ""; else {
                        if (parser.opt.xmlns) {
                            var qn = qname(parser.attribName, !0), prefix = qn.prefix, local = qn.local;
                            if ("xmlns" === prefix) if ("xml" === local && parser.attribValue !== XML_NAMESPACE) strictFail(parser, "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue); else if ("xmlns" === local && parser.attribValue !== XMLNS_NAMESPACE) strictFail(parser, "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue); else {
                                var tag = parser.tag, parent = parser.tags[parser.tags.length - 1] || parser;
                                tag.ns === parent.ns && (tag.ns = Object.create(parent.ns)), tag.ns[local] = parser.attribValue;
                            }
                            parser.attribList.push([ parser.attribName, parser.attribValue ]);
                        } else parser.tag.attributes[parser.attribName] = parser.attribValue, emitNode(parser, "onattribute", {
                            name: parser.attribName,
                            value: parser.attribValue
                        });
                        parser.attribName = parser.attribValue = "";
                    }
                }
                function openTag(parser, selfClosing) {
                    if (parser.opt.xmlns) {
                        var tag = parser.tag, qn = qname(parser.tagName);
                        tag.prefix = qn.prefix, tag.local = qn.local, tag.uri = tag.ns[qn.prefix] || "", 
                        tag.prefix && !tag.uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName)), 
                        tag.uri = qn.prefix);
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        tag.ns && parent.ns !== tag.ns && Object.keys(tag.ns).forEach(function(p) {
                            emitNode(parser, "onopennamespace", {
                                prefix: p,
                                uri: tag.ns[p]
                            });
                        });
                        for (var i = 0, l = parser.attribList.length; i < l; i++) {
                            var nv = parser.attribList[i], name = nv[0], value = nv[1], qualName = qname(name, !0), prefix = qualName.prefix, local = qualName.local, uri = "" === prefix ? "" : tag.ns[prefix] || "", a = {
                                name: name,
                                value: value,
                                prefix: prefix,
                                local: local,
                                uri: uri
                            };
                            prefix && "xmlns" !== prefix && !uri && (strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix)), 
                            a.uri = prefix), parser.tag.attributes[name] = a, emitNode(parser, "onattribute", a);
                        }
                        parser.attribList.length = 0;
                    }
                    parser.tag.isSelfClosing = !!selfClosing, parser.sawRoot = !0, parser.tags.push(parser.tag), 
                    emitNode(parser, "onopentag", parser.tag), selfClosing || (parser.noscript || "script" !== parser.tagName.toLowerCase() ? parser.state = S.TEXT : parser.state = S.SCRIPT, 
                    parser.tag = null, parser.tagName = ""), parser.attribName = parser.attribValue = "", 
                    parser.attribList.length = 0;
                }
                function closeTag(parser) {
                    if (!parser.tagName) return strictFail(parser, "Weird empty close tag."), parser.textNode += "</>", 
                    void (parser.state = S.TEXT);
                    if (parser.script) {
                        if ("script" !== parser.tagName) return parser.script += "</" + parser.tagName + ">", 
                        parser.tagName = "", void (parser.state = S.SCRIPT);
                        emitNode(parser, "onscript", parser.script), parser.script = "";
                    }
                    var t = parser.tags.length, tagName = parser.tagName;
                    parser.strict || (tagName = tagName[parser.looseCase]());
                    for (var closeTo = tagName; t--; ) {
                        if (parser.tags[t].name === closeTo) break;
                        strictFail(parser, "Unexpected close tag");
                    }
                    if (t < 0) return strictFail(parser, "Unmatched closing tag: " + parser.tagName), 
                    parser.textNode += "</" + parser.tagName + ">", void (parser.state = S.TEXT);
                    parser.tagName = tagName;
                    for (var s = parser.tags.length; s-- > t; ) {
                        var tag = parser.tag = parser.tags.pop();
                        parser.tagName = parser.tag.name, emitNode(parser, "onclosetag", parser.tagName);
                        var x = {};
                        for (var i in tag.ns) x[i] = tag.ns[i];
                        var parent = parser.tags[parser.tags.length - 1] || parser;
                        parser.opt.xmlns && tag.ns !== parent.ns && Object.keys(tag.ns).forEach(function(p) {
                            var n = tag.ns[p];
                            emitNode(parser, "onclosenamespace", {
                                prefix: p,
                                uri: n
                            });
                        });
                    }
                    0 === t && (parser.closedRoot = !0), parser.tagName = parser.attribValue = parser.attribName = "", 
                    parser.attribList.length = 0, parser.state = S.TEXT;
                }
                function parseEntity(parser) {
                    var num, entity = parser.entity, entityLC = entity.toLowerCase(), numStr = "";
                    return parser.ENTITIES[entity] ? parser.ENTITIES[entity] : parser.ENTITIES[entityLC] ? parser.ENTITIES[entityLC] : ("#" === (entity = entityLC).charAt(0) && ("x" === entity.charAt(1) ? (entity = entity.slice(2), 
                    numStr = (num = parseInt(entity, 16)).toString(16)) : (entity = entity.slice(1), 
                    numStr = (num = parseInt(entity, 10)).toString(10))), entity = entity.replace(/^0+/, ""), 
                    isNaN(num) || numStr.toLowerCase() !== entity ? (strictFail(parser, "Invalid character entity"), 
                    "&" + parser.entity + ";") : String.fromCodePoint(num));
                }
                function beginWhiteSpace(parser, c) {
                    "<" === c ? (parser.state = S.OPEN_WAKA, parser.startTagPosition = parser.position) : isWhitespace(c) || (strictFail(parser, "Non-whitespace before first tag."), 
                    parser.textNode = c, parser.state = S.TEXT);
                }
                function charAt(chunk, i) {
                    var result = "";
                    return i < chunk.length && (result = chunk.charAt(i)), result;
                }
                S = sax.STATE, String.fromCodePoint || (stringFromCharCode = String.fromCharCode, 
                floor = Math.floor, fromCodePoint = function() {
                    var highSurrogate, lowSurrogate, codeUnits = [], index = -1, length = arguments.length;
                    if (!length) return "";
                    for (var result = ""; ++index < length; ) {
                        var codePoint = Number(arguments[index]);
                        if (!isFinite(codePoint) || codePoint < 0 || 1114111 < codePoint || floor(codePoint) !== codePoint) throw RangeError("Invalid code point: " + codePoint);
                        codePoint <= 65535 ? codeUnits.push(codePoint) : (highSurrogate = 55296 + ((codePoint -= 65536) >> 10), 
                        lowSurrogate = codePoint % 1024 + 56320, codeUnits.push(highSurrogate, lowSurrogate)), 
                        (index + 1 === length || 16384 < codeUnits.length) && (result += stringFromCharCode.apply(null, codeUnits), 
                        codeUnits.length = 0);
                    }
                    return result;
                }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
                    value: fromCodePoint,
                    configurable: !0,
                    writable: !0
                }) : String.fromCodePoint = fromCodePoint);
            }(void 0 === exports ? this.sax = {} : exports);
        }).call(this, require("buffer").Buffer);
    }, {
        buffer: 24,
        stream: 76,
        string_decoder: 77
    } ],
    76: [ function(require, module, exports) {
        module.exports = Stream;
        var EE = require("events").EventEmitter;
        function Stream() {
            EE.call(this);
        }
        require("inherits")(Stream, EE), Stream.Readable = require("readable-stream/readable.js"), 
        Stream.Writable = require("readable-stream/writable.js"), Stream.Duplex = require("readable-stream/duplex.js"), 
        Stream.Transform = require("readable-stream/transform.js"), Stream.PassThrough = require("readable-stream/passthrough.js"), 
        (Stream.Stream = Stream).prototype.pipe = function(dest, options) {
            var source = this;
            function ondata(chunk) {
                dest.writable && !1 === dest.write(chunk) && source.pause && source.pause();
            }
            function ondrain() {
                source.readable && source.resume && source.resume();
            }
            source.on("data", ondata), dest.on("drain", ondrain), dest._isStdio || options && !1 === options.end || (source.on("end", onend), 
            source.on("close", onclose));
            var didOnEnd = !1;
            function onend() {
                didOnEnd || (didOnEnd = !0, dest.end());
            }
            function onclose() {
                didOnEnd || (didOnEnd = !0, "function" == typeof dest.destroy && dest.destroy());
            }
            function onerror(er) {
                if (cleanup(), 0 === EE.listenerCount(this, "error")) throw er;
            }
            function cleanup() {
                source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), 
                source.removeListener("close", onclose), source.removeListener("error", onerror), 
                dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), 
                dest.removeListener("close", cleanup);
            }
            return source.on("error", onerror), dest.on("error", onerror), source.on("end", cleanup), 
            source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), 
            dest;
        };
    }, {
        events: 26,
        inherits: 46,
        "readable-stream/duplex.js": 61,
        "readable-stream/passthrough.js": 70,
        "readable-stream/readable.js": 71,
        "readable-stream/transform.js": 72,
        "readable-stream/writable.js": 73
    } ],
    77: [ function(require, module, exports) {
        "use strict";
        var Buffer = require("safe-buffer").Buffer, isEncoding = Buffer.isEncoding || function(encoding) {
            switch ((encoding = "" + encoding) && encoding.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return !0;

              default:
                return !1;
            }
        };
        function StringDecoder(encoding) {
            var nb;
            switch (this.encoding = function(enc) {
                var nenc = function(enc) {
                    if (!enc) return "utf8";
                    for (var retried; ;) switch (enc) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";

                      case "latin1":
                      case "binary":
                        return "latin1";

                      case "base64":
                      case "ascii":
                      case "hex":
                        return enc;

                      default:
                        if (retried) return;
                        enc = ("" + enc).toLowerCase(), retried = !0;
                    }
                }(enc);
                if ("string" != typeof nenc && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
                return nenc || enc;
            }(encoding), this.encoding) {
              case "utf16le":
                this.text = utf16Text, this.end = utf16End, nb = 4;
                break;

              case "utf8":
                this.fillLast = utf8FillLast, nb = 4;
                break;

              case "base64":
                this.text = base64Text, this.end = base64End, nb = 3;
                break;

              default:
                return this.write = simpleWrite, void (this.end = simpleEnd);
            }
            this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer.allocUnsafe(nb);
        }
        function utf8CheckByte(byte) {
            return byte <= 127 ? 0 : byte >> 5 == 6 ? 2 : byte >> 4 == 14 ? 3 : byte >> 3 == 30 ? 4 : byte >> 6 == 2 ? -1 : -2;
        }
        function utf8FillLast(buf) {
            var p = this.lastTotal - this.lastNeed, r = function(self, buf, p) {
                if (128 != (192 & buf[0])) return self.lastNeed = 0, "�";
                if (1 < self.lastNeed && 1 < buf.length) {
                    if (128 != (192 & buf[1])) return self.lastNeed = 1, "�";
                    if (2 < self.lastNeed && 2 < buf.length && 128 != (192 & buf[2])) return self.lastNeed = 2, 
                    "�";
                }
            }(this, buf);
            return void 0 !== r ? r : this.lastNeed <= buf.length ? (buf.copy(this.lastChar, p, 0, this.lastNeed), 
            this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (buf.copy(this.lastChar, p, 0, buf.length), 
            void (this.lastNeed -= buf.length));
        }
        function utf16Text(buf, i) {
            if ((buf.length - i) % 2 == 0) {
                var r = buf.toString("utf16le", i);
                if (r) {
                    var c = r.charCodeAt(r.length - 1);
                    if (55296 <= c && c <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], 
                    this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
                }
                return r;
            }
            return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], 
            buf.toString("utf16le", i, buf.length - 1);
        }
        function utf16End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            if (this.lastNeed) {
                var end = this.lastTotal - this.lastNeed;
                return r + this.lastChar.toString("utf16le", 0, end);
            }
            return r;
        }
        function base64Text(buf, i) {
            var n = (buf.length - i) % 3;
            return 0 === n ? buf.toString("base64", i) : (this.lastNeed = 3 - n, this.lastTotal = 3, 
            1 === n ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], 
            this.lastChar[1] = buf[buf.length - 1]), buf.toString("base64", i, buf.length - n));
        }
        function base64End(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            return this.lastNeed ? r + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : r;
        }
        function simpleWrite(buf) {
            return buf.toString(this.encoding);
        }
        function simpleEnd(buf) {
            return buf && buf.length ? this.write(buf) : "";
        }
        (exports.StringDecoder = StringDecoder).prototype.write = function(buf) {
            if (0 === buf.length) return "";
            var r, i;
            if (this.lastNeed) {
                if (void 0 === (r = this.fillLast(buf))) return "";
                i = this.lastNeed, this.lastNeed = 0;
            } else i = 0;
            return i < buf.length ? r ? r + this.text(buf, i) : this.text(buf, i) : r || "";
        }, StringDecoder.prototype.end = function(buf) {
            var r = buf && buf.length ? this.write(buf) : "";
            return this.lastNeed ? r + "�" : r;
        }, StringDecoder.prototype.text = function(buf, i) {
            var total = function(self, buf, i) {
                var j = buf.length - 1;
                if (j < i) return 0;
                var nb = utf8CheckByte(buf[j]);
                if (0 <= nb) return 0 < nb && (self.lastNeed = nb - 1), nb;
                if (--j < i || -2 === nb) return 0;
                if (0 <= (nb = utf8CheckByte(buf[j]))) return 0 < nb && (self.lastNeed = nb - 2), 
                nb;
                if (--j < i || -2 === nb) return 0;
                if (0 <= (nb = utf8CheckByte(buf[j]))) return 0 < nb && (2 === nb ? nb = 0 : self.lastNeed = nb - 3), 
                nb;
                return 0;
            }(this, buf, i);
            if (!this.lastNeed) return buf.toString("utf8", i);
            this.lastTotal = total;
            var end = buf.length - (total - this.lastNeed);
            return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i, end);
        }, StringDecoder.prototype.fillLast = function(buf) {
            if (this.lastNeed <= buf.length) return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), 
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
        };
    }, {
        "safe-buffer": 74
    } ],
    78: [ function(require, module, exports) {
        (function(setImmediate, clearImmediate) {
            var nextTick = require("process/browser.js").nextTick, apply = Function.prototype.apply, slice = Array.prototype.slice, immediateIds = {}, nextImmediateId = 0;
            function Timeout(id, clearFn) {
                this._id = id, this._clearFn = clearFn;
            }
            exports.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
            }, exports.setInterval = function() {
                return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
            }, exports.clearTimeout = exports.clearInterval = function(timeout) {
                timeout.close();
            }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
                this._clearFn.call(window, this._id);
            }, exports.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
            }, exports.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
            }, exports._unrefActive = exports.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                0 <= msecs && (item._idleTimeoutId = setTimeout(function() {
                    item._onTimeout && item._onTimeout();
                }, msecs));
            }, exports.setImmediate = "function" == typeof setImmediate ? setImmediate : function(fn) {
                var id = nextImmediateId++, args = !(arguments.length < 2) && slice.call(arguments, 1);
                return immediateIds[id] = !0, nextTick(function() {
                    immediateIds[id] && (args ? fn.apply(null, args) : fn.call(null), exports.clearImmediate(id));
                }), id;
            }, exports.clearImmediate = "function" == typeof clearImmediate ? clearImmediate : function(id) {
                delete immediateIds[id];
            };
        }).call(this, require("timers").setImmediate, require("timers").clearImmediate);
    }, {
        "process/browser.js": 56,
        timers: 78
    } ],
    79: [ function(require, module, exports) {
        var Buffer = require("buffer").Buffer;
        module.exports = function(buf) {
            if (buf instanceof Uint8Array) {
                if (0 === buf.byteOffset && buf.byteLength === buf.buffer.byteLength) return buf.buffer;
                if ("function" == typeof buf.buffer.slice) return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
            }
            if (Buffer.isBuffer(buf)) {
                for (var arrayCopy = new Uint8Array(buf.length), len = buf.length, i = 0; i < len; i++) arrayCopy[i] = buf[i];
                return arrayCopy.buffer;
            }
            throw new Error("Argument must be a Buffer");
        };
    }, {
        buffer: 24
    } ],
    80: [ function(require, module, exports) {
        (function(global) {
            function config(name) {
                try {
                    if (!global.localStorage) return !1;
                } catch (_) {
                    return !1;
                }
                var val = global.localStorage[name];
                return null != val && "true" === String(val).toLowerCase();
            }
            module.exports = function(fn, msg) {
                if (config("noDeprecation")) return fn;
                var warned = !1;
                return function() {
                    if (!warned) {
                        if (config("throwDeprecation")) throw new Error(msg);
                        config("traceDeprecation") ? console.trace(msg) : console.warn(msg), warned = !0;
                    }
                    return fn.apply(this, arguments);
                };
            };
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {} ],
    81: [ function(require, module, exports) {
        arguments[4][19][0].apply(exports, arguments);
    }, {
        dup: 19
    } ],
    82: [ function(require, module, exports) {
        arguments[4][20][0].apply(exports, arguments);
    }, {
        "./support/isBuffer": 81,
        _process: 56,
        dup: 20,
        inherits: 46
    } ],
    83: [ function(require, module, exports) {
        (function() {
            "use strict";
            exports.stripBOM = function(str) {
                return "\ufeff" === str[0] ? str.substring(1) : str;
            };
        }).call(this);
    }, {} ],
    84: [ function(require, module, exports) {
        (function() {
            "use strict";
            var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA, hasProp = {}.hasOwnProperty;
            builder = require("xmlbuilder"), defaults = require("./defaults").defaults, requiresCDATA = function(entry) {
                return "string" == typeof entry && (0 <= entry.indexOf("&") || 0 <= entry.indexOf(">") || 0 <= entry.indexOf("<"));
            }, wrapCDATA = function(entry) {
                return "<![CDATA[" + escapeCDATA(entry) + "]]>";
            }, escapeCDATA = function(entry) {
                return entry.replace("]]>", "]]]]><![CDATA[>");
            }, exports.Builder = function() {
                function Builder(opts) {
                    var key, ref, value;
                    for (key in this.options = {}, ref = defaults[.2]) hasProp.call(ref, key) && (value = ref[key], 
                    this.options[key] = value);
                    for (key in opts) hasProp.call(opts, key) && (value = opts[key], this.options[key] = value);
                }
                return Builder.prototype.buildObject = function(rootObj) {
                    var attrkey, charkey, render, rootElement, rootName, _this;
                    return attrkey = this.options.attrkey, charkey = this.options.charkey, 1 === Object.keys(rootObj).length && this.options.rootName === defaults[.2].rootName ? rootObj = rootObj[rootName = Object.keys(rootObj)[0]] : rootName = this.options.rootName, 
                    _this = this, render = function(element, obj) {
                        var attr, child, entry, index, key, value;
                        if ("object" != typeof obj) _this.options.cdata && requiresCDATA(obj) ? element.raw(wrapCDATA(obj)) : element.txt(obj); else if (Array.isArray(obj)) {
                            for (index in obj) if (hasProp.call(obj, index)) for (key in child = obj[index]) entry = child[key], 
                            element = render(element.ele(key), entry).up();
                        } else for (key in obj) if (hasProp.call(obj, key)) if (child = obj[key], key === attrkey) {
                            if ("object" == typeof child) for (attr in child) value = child[attr], element = element.att(attr, value);
                        } else if (key === charkey) element = _this.options.cdata && requiresCDATA(child) ? element.raw(wrapCDATA(child)) : element.txt(child); else if (Array.isArray(child)) for (index in child) hasProp.call(child, index) && (element = "string" == typeof (entry = child[index]) ? _this.options.cdata && requiresCDATA(entry) ? element.ele(key).raw(wrapCDATA(entry)).up() : element.ele(key, entry).up() : render(element.ele(key), entry).up()); else "object" == typeof child ? element = render(element.ele(key), child).up() : "string" == typeof child && _this.options.cdata && requiresCDATA(child) ? element = element.ele(key).raw(wrapCDATA(child)).up() : (null == child && (child = ""), 
                        element = element.ele(key, child.toString()).up());
                        return element;
                    }, rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
                        headless: this.options.headless,
                        allowSurrogateChars: this.options.allowSurrogateChars
                    }), render(rootElement, rootObj).end(this.options.renderOpts);
                }, Builder;
            }();
        }).call(this);
    }, {
        "./defaults": 85,
        xmlbuilder: 110
    } ],
    85: [ function(require, module, exports) {
        (function() {
            exports.defaults = {
                .1: {
                    explicitCharkey: !1,
                    trim: !0,
                    normalize: !0,
                    normalizeTags: !1,
                    attrkey: "@",
                    charkey: "#",
                    explicitArray: !1,
                    ignoreAttrs: !1,
                    mergeAttrs: !1,
                    explicitRoot: !1,
                    validator: null,
                    xmlns: !1,
                    explicitChildren: !1,
                    childkey: "@@",
                    charsAsChildren: !1,
                    includeWhiteChars: !1,
                    async: !1,
                    strict: !0,
                    attrNameProcessors: null,
                    attrValueProcessors: null,
                    tagNameProcessors: null,
                    valueProcessors: null,
                    emptyTag: ""
                },
                .2: {
                    explicitCharkey: !1,
                    trim: !1,
                    normalize: !1,
                    normalizeTags: !1,
                    attrkey: "$",
                    charkey: "_",
                    explicitArray: !0,
                    ignoreAttrs: !1,
                    mergeAttrs: !1,
                    explicitRoot: !0,
                    validator: null,
                    xmlns: !1,
                    explicitChildren: !1,
                    preserveChildrenOrder: !1,
                    childkey: "$$",
                    charsAsChildren: !1,
                    includeWhiteChars: !1,
                    async: !1,
                    strict: !0,
                    attrNameProcessors: null,
                    attrValueProcessors: null,
                    tagNameProcessors: null,
                    valueProcessors: null,
                    rootName: "root",
                    xmldec: {
                        version: "1.0",
                        encoding: "UTF-8",
                        standalone: !0
                    },
                    doctype: null,
                    renderOpts: {
                        pretty: !0,
                        indent: "  ",
                        newline: "\n"
                    },
                    headless: !1,
                    chunkSize: 1e4,
                    emptyTag: "",
                    cdata: !1
                }
            };
        }).call(this);
    }, {} ],
    86: [ function(require, module, exports) {
        (function() {
            "use strict";
            var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate, bind = function(fn, me) {
                return function() {
                    return fn.apply(me, arguments);
                };
            }, hasProp = {}.hasOwnProperty;
            sax = require("sax"), events = require("events"), bom = require("./bom"), processors = require("./processors"), 
            setImmediate = require("timers").setImmediate, defaults = require("./defaults").defaults, 
            isEmpty = function(thing) {
                return "object" == typeof thing && null != thing && 0 === Object.keys(thing).length;
            }, processItem = function(processors, item, key) {
                var i, len;
                for (i = 0, len = processors.length; i < len; i++) item = (0, processors[i])(item, key);
                return item;
            }, exports.Parser = function(superClass) {
                function Parser(opts) {
                    var key, ref, value;
                    if (this.parseString = bind(this.parseString, this), this.reset = bind(this.reset, this), 
                    this.assignOrPush = bind(this.assignOrPush, this), this.processAsync = bind(this.processAsync, this), 
                    !(this instanceof exports.Parser)) return new exports.Parser(opts);
                    for (key in this.options = {}, ref = defaults[.2]) hasProp.call(ref, key) && (value = ref[key], 
                    this.options[key] = value);
                    for (key in opts) hasProp.call(opts, key) && (value = opts[key], this.options[key] = value);
                    this.options.xmlns && (this.options.xmlnskey = this.options.attrkey + "ns"), this.options.normalizeTags && (this.options.tagNameProcessors || (this.options.tagNameProcessors = []), 
                    this.options.tagNameProcessors.unshift(processors.normalize)), this.reset();
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(Parser, events.EventEmitter), Parser.prototype.processAsync = function() {
                    var chunk, err;
                    try {
                        return this.remaining.length <= this.options.chunkSize ? (chunk = this.remaining, 
                        this.remaining = "", this.saxParser = this.saxParser.write(chunk), this.saxParser.close()) : (chunk = this.remaining.substr(0, this.options.chunkSize), 
                        this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length), 
                        this.saxParser = this.saxParser.write(chunk), setImmediate(this.processAsync));
                    } catch (error1) {
                        if (err = error1, !this.saxParser.errThrown) return this.saxParser.errThrown = !0, 
                        this.emit(err);
                    }
                }, Parser.prototype.assignOrPush = function(obj, key, newValue) {
                    return key in obj ? (obj[key] instanceof Array || (obj[key] = [ obj[key] ]), obj[key].push(newValue)) : this.options.explicitArray ? obj[key] = [ newValue ] : obj[key] = newValue;
                }, Parser.prototype.reset = function() {
                    var attrkey, charkey, ontext, stack, _this;
                    return this.removeAllListeners(), this.saxParser = sax.parser(this.options.strict, {
                        trim: !1,
                        normalize: !1,
                        xmlns: this.options.xmlns
                    }), this.saxParser.errThrown = !1, this.saxParser.onerror = (_this = this, function(error) {
                        if (_this.saxParser.resume(), !_this.saxParser.errThrown) return _this.saxParser.errThrown = !0, 
                        _this.emit("error", error);
                    }), this.saxParser.onend = function(_this) {
                        return function() {
                            if (!_this.saxParser.ended) return _this.saxParser.ended = !0, _this.emit("end", _this.resultObject);
                        };
                    }(this), this.saxParser.ended = !1, this.EXPLICIT_CHARKEY = this.options.explicitCharkey, 
                    this.resultObject = null, stack = [], attrkey = this.options.attrkey, charkey = this.options.charkey, 
                    this.saxParser.onopentag = function(_this) {
                        return function(node) {
                            var key, newValue, obj, processedKey, ref;
                            if ((obj = {})[charkey] = "", !_this.options.ignoreAttrs) for (key in ref = node.attributes) hasProp.call(ref, key) && (attrkey in obj || _this.options.mergeAttrs || (obj[attrkey] = {}), 
                            newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key], 
                            processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key, 
                            _this.options.mergeAttrs ? _this.assignOrPush(obj, processedKey, newValue) : obj[attrkey][processedKey] = newValue);
                            return obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name, 
                            _this.options.xmlns && (obj[_this.options.xmlnskey] = {
                                uri: node.uri,
                                local: node.local
                            }), stack.push(obj);
                        };
                    }(this), this.saxParser.onclosetag = function(_this) {
                        return function() {
                            var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
                            if (obj = stack.pop(), nodeName = obj["#name"], _this.options.explicitChildren && _this.options.preserveChildrenOrder || delete obj["#name"], 
                            !0 === obj.cdata && (cdata = obj.cdata, delete obj.cdata), s = stack[stack.length - 1], 
                            obj[charkey].match(/^\s*$/) && !cdata ? (emptyStr = obj[charkey], delete obj[charkey]) : (_this.options.trim && (obj[charkey] = obj[charkey].trim()), 
                            _this.options.normalize && (obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim()), 
                            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey], 
                            1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey])), 
                            isEmpty(obj) && (obj = "" !== _this.options.emptyTag ? _this.options.emptyTag : emptyStr), 
                            null != _this.options.validator && (xpath = "/" + function() {
                                var i, len, results;
                                for (results = [], i = 0, len = stack.length; i < len; i++) node = stack[i], results.push(node["#name"]);
                                return results;
                            }().concat(nodeName).join("/"), function() {
                                var err;
                                try {
                                    obj = _this.options.validator(xpath, s && s[nodeName], obj);
                                } catch (error1) {
                                    return err = error1, _this.emit("error", err);
                                }
                            }()), _this.options.explicitChildren && !_this.options.mergeAttrs && "object" == typeof obj) if (_this.options.preserveChildrenOrder) {
                                if (s) {
                                    for (key in s[_this.options.childkey] = s[_this.options.childkey] || [], objClone = {}, 
                                    obj) hasProp.call(obj, key) && (objClone[key] = obj[key]);
                                    s[_this.options.childkey].push(objClone), delete obj["#name"], 1 === Object.keys(obj).length && charkey in obj && !_this.EXPLICIT_CHARKEY && (obj = obj[charkey]);
                                }
                            } else node = {}, _this.options.attrkey in obj && (node[_this.options.attrkey] = obj[_this.options.attrkey], 
                            delete obj[_this.options.attrkey]), !_this.options.charsAsChildren && _this.options.charkey in obj && (node[_this.options.charkey] = obj[_this.options.charkey], 
                            delete obj[_this.options.charkey]), 0 < Object.getOwnPropertyNames(obj).length && (node[_this.options.childkey] = obj), 
                            obj = node;
                            return 0 < stack.length ? _this.assignOrPush(s, nodeName, obj) : (_this.options.explicitRoot && (old = obj, 
                            (obj = {})[nodeName] = old), _this.resultObject = obj, _this.saxParser.ended = !0, 
                            _this.emit("end", _this.resultObject));
                        };
                    }(this), ontext = function(_this) {
                        return function(text) {
                            var charChild, s;
                            if (s = stack[stack.length - 1]) return s[charkey] += text, _this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || "" !== text.replace(/\\n/g, "").trim()) && (s[_this.options.childkey] = s[_this.options.childkey] || [], 
                            (charChild = {
                                "#name": "__text__"
                            })[charkey] = text, _this.options.normalize && (charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim()), 
                            s[_this.options.childkey].push(charChild)), s;
                        };
                    }(this), this.saxParser.ontext = ontext, this.saxParser.oncdata = function(text) {
                        var s;
                        if (s = ontext(text)) return s.cdata = !0;
                    };
                }, Parser.prototype.parseString = function(str, cb) {
                    var err;
                    null != cb && "function" == typeof cb && (this.on("end", function(result) {
                        return this.reset(), cb(null, result);
                    }), this.on("error", function(err) {
                        return this.reset(), cb(err);
                    }));
                    try {
                        return "" === (str = str.toString()).trim() ? (this.emit("end", null), !0) : (str = bom.stripBOM(str), 
                        this.options.async ? (this.remaining = str, setImmediate(this.processAsync), this.saxParser) : this.saxParser.write(str).close());
                    } catch (error1) {
                        if (err = error1, !this.saxParser.errThrown && !this.saxParser.ended) return this.emit("error", err), 
                        this.saxParser.errThrown = !0;
                        if (this.saxParser.ended) throw err;
                    }
                }, Parser;
            }(), exports.parseString = function(str, a, b) {
                var cb, options;
                return null != b ? ("function" == typeof b && (cb = b), "object" == typeof a && (options = a)) : ("function" == typeof a && (cb = a), 
                options = {}), new exports.Parser(options).parseString(str, cb);
            };
        }).call(this);
    }, {
        "./bom": 83,
        "./defaults": 85,
        "./processors": 87,
        events: 26,
        sax: 75,
        timers: 78
    } ],
    87: [ function(require, module, exports) {
        (function() {
            "use strict";
            var prefixMatch;
            prefixMatch = new RegExp(/(?!xmlns)^.*:/), exports.normalize = function(str) {
                return str.toLowerCase();
            }, exports.firstCharLowerCase = function(str) {
                return str.charAt(0).toLowerCase() + str.slice(1);
            }, exports.stripPrefix = function(str) {
                return str.replace(prefixMatch, "");
            }, exports.parseNumbers = function(str) {
                return isNaN(str) || (str = str % 1 == 0 ? parseInt(str, 10) : parseFloat(str)), 
                str;
            }, exports.parseBooleans = function(str) {
                return /^(?:true|false)$/i.test(str) && (str = "true" === str.toLowerCase()), str;
            };
        }).call(this);
    }, {} ],
    88: [ function(require, module, exports) {
        (function() {
            "use strict";
            var builder, defaults, parser, processors, hasProp = {}.hasOwnProperty;
            defaults = require("./defaults"), builder = require("./builder"), parser = require("./parser"), 
            processors = require("./processors"), exports.defaults = defaults.defaults, exports.processors = processors, 
            exports.ValidationError = function(superClass) {
                function ValidationError(message) {
                    this.message = message;
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(ValidationError, Error), ValidationError;
            }(), exports.Builder = builder.Builder, exports.Parser = parser.Parser, exports.parseString = parser.parseString;
        }).call(this);
    }, {
        "./builder": 84,
        "./defaults": 85,
        "./parser": 86,
        "./processors": 87
    } ],
    89: [ function(require, module, exports) {
        (function() {
            var assign, isArray, isEmpty, isFunction, isObject, isPlainObject, slice = [].slice, hasProp = {}.hasOwnProperty;
            assign = function() {
                var i, key, len, source, sources, target;
                if (target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [], 
                isFunction(Object.assign)) Object.assign.apply(null, arguments); else for (i = 0, 
                len = sources.length; i < len; i++) if (null != (source = sources[i])) for (key in source) hasProp.call(source, key) && (target[key] = source[key]);
                return target;
            }, isFunction = function(val) {
                return !!val && "[object Function]" === Object.prototype.toString.call(val);
            }, isObject = function(val) {
                var ref;
                return !!val && ("function" == (ref = typeof val) || "object" === ref);
            }, isArray = function(val) {
                return isFunction(Array.isArray) ? Array.isArray(val) : "[object Array]" === Object.prototype.toString.call(val);
            }, isEmpty = function(val) {
                var key;
                if (isArray(val)) return !val.length;
                for (key in val) if (hasProp.call(val, key)) return !1;
                return !0;
            }, isPlainObject = function(val) {
                var ctor, proto;
                return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && "function" == typeof ctor && ctor instanceof ctor && Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object);
            }, module.exports.assign = assign, module.exports.isFunction = isFunction, module.exports.isObject = isObject, 
            module.exports.isArray = isArray, module.exports.isEmpty = isEmpty, module.exports.isPlainObject = isPlainObject;
        }).call(this);
    }, {} ],
    90: [ function(require, module, exports) {
        (function() {
            module.exports = function() {
                function XMLAttribute(parent, name, value) {
                    if (this.options = parent.options, this.stringify = parent.stringify, null == name) throw new Error("Missing attribute name of element " + parent.name);
                    if (null == value) throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
                    this.name = this.stringify.attName(name), this.value = this.stringify.attValue(value);
                }
                return XMLAttribute.prototype.clone = function() {
                    return Object.create(this);
                }, XMLAttribute.prototype.toString = function(options) {
                    return this.options.writer.set(options).attribute(this);
                }, XMLAttribute;
            }();
        }).call(this);
    }, {} ],
    91: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLCData(parent, text) {
                    if (XMLCData.__super__.constructor.call(this, parent), null == text) throw new Error("Missing CDATA text");
                    this.text = this.stringify.cdata(text);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLCData, XMLNode), XMLCData.prototype.clone = function() {
                    return Object.create(this);
                }, XMLCData.prototype.toString = function(options) {
                    return this.options.writer.set(options).cdata(this);
                }, XMLCData;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    92: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLComment(parent, text) {
                    if (XMLComment.__super__.constructor.call(this, parent), null == text) throw new Error("Missing comment text");
                    this.text = this.stringify.comment(text);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLComment, XMLNode), XMLComment.prototype.clone = function() {
                    return Object.create(this);
                }, XMLComment.prototype.toString = function(options) {
                    return this.options.writer.set(options).comment(this);
                }, XMLComment;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    93: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    if (XMLDTDAttList.__super__.constructor.call(this, parent), null == elementName) throw new Error("Missing DTD element name");
                    if (null == attributeName) throw new Error("Missing DTD attribute name");
                    if (!attributeType) throw new Error("Missing DTD attribute type");
                    if (!defaultValueType) throw new Error("Missing DTD attribute default");
                    if (0 !== defaultValueType.indexOf("#") && (defaultValueType = "#" + defaultValueType), 
                    !defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
                    if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) throw new Error("Default value only applies to #FIXED or #DEFAULT");
                    this.elementName = this.stringify.eleName(elementName), this.attributeName = this.stringify.attName(attributeName), 
                    this.attributeType = this.stringify.dtdAttType(attributeType), this.defaultValue = this.stringify.dtdAttDefault(defaultValue), 
                    this.defaultValueType = defaultValueType;
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDTDAttList, XMLNode), XMLDTDAttList.prototype.toString = function(options) {
                    return this.options.writer.set(options).dtdAttList(this);
                }, XMLDTDAttList;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    94: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLDTDElement(parent, name, value) {
                    if (XMLDTDElement.__super__.constructor.call(this, parent), null == name) throw new Error("Missing DTD element name");
                    value || (value = "(#PCDATA)"), Array.isArray(value) && (value = "(" + value.join(",") + ")"), 
                    this.name = this.stringify.eleName(name), this.value = this.stringify.dtdElementValue(value);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDTDElement, XMLNode), XMLDTDElement.prototype.toString = function(options) {
                    return this.options.writer.set(options).dtdElement(this);
                }, XMLDTDElement;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    95: [ function(require, module, exports) {
        (function() {
            var XMLNode, isObject, hasProp = {}.hasOwnProperty;
            isObject = require("./Utility").isObject, XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLDTDEntity(parent, pe, name, value) {
                    if (XMLDTDEntity.__super__.constructor.call(this, parent), null == name) throw new Error("Missing entity name");
                    if (null == value) throw new Error("Missing entity value");
                    if (this.pe = !!pe, this.name = this.stringify.eleName(name), isObject(value)) {
                        if (!value.pubID && !value.sysID) throw new Error("Public and/or system identifiers are required for an external entity");
                        if (value.pubID && !value.sysID) throw new Error("System identifier is required for a public external entity");
                        if (null != value.pubID && (this.pubID = this.stringify.dtdPubID(value.pubID)), 
                        null != value.sysID && (this.sysID = this.stringify.dtdSysID(value.sysID)), null != value.nData && (this.nData = this.stringify.dtdNData(value.nData)), 
                        this.pe && this.nData) throw new Error("Notation declaration is not allowed in a parameter entity");
                    } else this.value = this.stringify.dtdEntityValue(value);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDTDEntity, XMLNode), XMLDTDEntity.prototype.toString = function(options) {
                    return this.options.writer.set(options).dtdEntity(this);
                }, XMLDTDEntity;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLNode": 102
    } ],
    96: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLDTDNotation(parent, name, value) {
                    if (XMLDTDNotation.__super__.constructor.call(this, parent), null == name) throw new Error("Missing notation name");
                    if (!value.pubID && !value.sysID) throw new Error("Public or system identifiers are required for an external entity");
                    this.name = this.stringify.eleName(name), null != value.pubID && (this.pubID = this.stringify.dtdPubID(value.pubID)), 
                    null != value.sysID && (this.sysID = this.stringify.dtdSysID(value.sysID));
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDTDNotation, XMLNode), XMLDTDNotation.prototype.toString = function(options) {
                    return this.options.writer.set(options).dtdNotation(this);
                }, XMLDTDNotation;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    97: [ function(require, module, exports) {
        (function() {
            var XMLNode, isObject, hasProp = {}.hasOwnProperty;
            isObject = require("./Utility").isObject, XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLDeclaration(parent, version, encoding, standalone) {
                    var ref;
                    XMLDeclaration.__super__.constructor.call(this, parent), isObject(version) && (version = (ref = version).version, 
                    encoding = ref.encoding, standalone = ref.standalone), version || (version = "1.0"), 
                    this.version = this.stringify.xmlVersion(version), null != encoding && (this.encoding = this.stringify.xmlEncoding(encoding)), 
                    null != standalone && (this.standalone = this.stringify.xmlStandalone(standalone));
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDeclaration, XMLNode), XMLDeclaration.prototype.toString = function(options) {
                    return this.options.writer.set(options).declaration(this);
                }, XMLDeclaration;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLNode": 102
    } ],
    98: [ function(require, module, exports) {
        (function() {
            var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLNode, isObject, hasProp = {}.hasOwnProperty;
            isObject = require("./Utility").isObject, XMLNode = require("./XMLNode"), XMLDTDAttList = require("./XMLDTDAttList"), 
            XMLDTDEntity = require("./XMLDTDEntity"), XMLDTDElement = require("./XMLDTDElement"), 
            XMLDTDNotation = require("./XMLDTDNotation"), module.exports = function(superClass) {
                function XMLDocType(parent, pubID, sysID) {
                    var ref, ref1;
                    XMLDocType.__super__.constructor.call(this, parent), this.documentObject = parent, 
                    isObject(pubID) && (pubID = (ref = pubID).pubID, sysID = ref.sysID), null == sysID && (sysID = (ref1 = [ pubID, sysID ])[0], 
                    pubID = ref1[1]), null != pubID && (this.pubID = this.stringify.dtdPubID(pubID)), 
                    null != sysID && (this.sysID = this.stringify.dtdSysID(sysID));
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDocType, XMLNode), XMLDocType.prototype.element = function(name, value) {
                    var child;
                    return child = new XMLDTDElement(this, name, value), this.children.push(child), 
                    this;
                }, XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    var child;
                    return child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), 
                    this.children.push(child), this;
                }, XMLDocType.prototype.entity = function(name, value) {
                    var child;
                    return child = new XMLDTDEntity(this, !1, name, value), this.children.push(child), 
                    this;
                }, XMLDocType.prototype.pEntity = function(name, value) {
                    var child;
                    return child = new XMLDTDEntity(this, !0, name, value), this.children.push(child), 
                    this;
                }, XMLDocType.prototype.notation = function(name, value) {
                    var child;
                    return child = new XMLDTDNotation(this, name, value), this.children.push(child), 
                    this;
                }, XMLDocType.prototype.toString = function(options) {
                    return this.options.writer.set(options).docType(this);
                }, XMLDocType.prototype.ele = function(name, value) {
                    return this.element(name, value);
                }, XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
                }, XMLDocType.prototype.ent = function(name, value) {
                    return this.entity(name, value);
                }, XMLDocType.prototype.pent = function(name, value) {
                    return this.pEntity(name, value);
                }, XMLDocType.prototype.not = function(name, value) {
                    return this.notation(name, value);
                }, XMLDocType.prototype.up = function() {
                    return this.root() || this.documentObject;
                }, XMLDocType;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLDTDAttList": 93,
        "./XMLDTDElement": 94,
        "./XMLDTDEntity": 95,
        "./XMLDTDNotation": 96,
        "./XMLNode": 102
    } ],
    99: [ function(require, module, exports) {
        (function() {
            var XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, hasProp = {}.hasOwnProperty;
            isPlainObject = require("./Utility").isPlainObject, XMLNode = require("./XMLNode"), 
            XMLStringifier = require("./XMLStringifier"), XMLStringWriter = require("./XMLStringWriter"), 
            module.exports = function(superClass) {
                function XMLDocument(options) {
                    XMLDocument.__super__.constructor.call(this, null), options || (options = {}), options.writer || (options.writer = new XMLStringWriter()), 
                    this.options = options, this.stringify = new XMLStringifier(options), this.isDocument = !0;
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLDocument, XMLNode), XMLDocument.prototype.end = function(writer) {
                    var writerOptions;
                    return writer ? isPlainObject(writer) && (writerOptions = writer, writer = this.options.writer.set(writerOptions)) : writer = this.options.writer, 
                    writer.document(this);
                }, XMLDocument.prototype.toString = function(options) {
                    return this.options.writer.set(options).document(this);
                }, XMLDocument;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLNode": 102,
        "./XMLStringWriter": 106,
        "./XMLStringifier": 107
    } ],
    100: [ function(require, module, exports) {
        (function() {
            var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref, hasProp = {}.hasOwnProperty;
            ref = require("./Utility"), isObject = ref.isObject, isFunction = ref.isFunction, 
            isPlainObject = ref.isPlainObject, XMLElement = require("./XMLElement"), XMLCData = require("./XMLCData"), 
            XMLComment = require("./XMLComment"), XMLRaw = require("./XMLRaw"), XMLText = require("./XMLText"), 
            XMLProcessingInstruction = require("./XMLProcessingInstruction"), XMLDeclaration = require("./XMLDeclaration"), 
            XMLDocType = require("./XMLDocType"), XMLDTDAttList = require("./XMLDTDAttList"), 
            XMLDTDEntity = require("./XMLDTDEntity"), XMLDTDElement = require("./XMLDTDElement"), 
            XMLDTDNotation = require("./XMLDTDNotation"), XMLAttribute = require("./XMLAttribute"), 
            XMLStringifier = require("./XMLStringifier"), XMLStringWriter = require("./XMLStringWriter"), 
            module.exports = function() {
                function XMLDocumentCB(options, onData, onEnd) {
                    var writerOptions;
                    options || (options = {}), options.writer ? isPlainObject(options.writer) && (writerOptions = options.writer, 
                    options.writer = new XMLStringWriter(writerOptions)) : options.writer = new XMLStringWriter(options), 
                    this.options = options, this.writer = options.writer, this.stringify = new XMLStringifier(options), 
                    this.onDataCallback = onData || function() {}, this.onEndCallback = onEnd || function() {}, 
                    this.currentNode = null, this.currentLevel = -1, this.openTags = {}, this.documentStarted = !1, 
                    this.documentCompleted = !1, this.root = null;
                }
                return XMLDocumentCB.prototype.node = function(name, attributes, text) {
                    var ref1;
                    if (null == name) throw new Error("Missing node name");
                    if (this.root && -1 === this.currentLevel) throw new Error("Document can only have one root node");
                    return this.openCurrent(), name = name.valueOf(), null == attributes && (attributes = {}), 
                    attributes = attributes.valueOf(), isObject(attributes) || (text = (ref1 = [ attributes, text ])[0], 
                    attributes = ref1[1]), this.currentNode = new XMLElement(this, name, attributes), 
                    this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, 
                    null != text && this.text(text), this;
                }, XMLDocumentCB.prototype.element = function(name, attributes, text) {
                    return this.currentNode && this.currentNode instanceof XMLDocType ? this.dtdElement.apply(this, arguments) : this.node(name, attributes, text);
                }, XMLDocumentCB.prototype.attribute = function(name, value) {
                    var attName, attValue;
                    if (!this.currentNode || this.currentNode.children) throw new Error("att() can only be used immediately after an ele() call in callback mode");
                    if (null != name && (name = name.valueOf()), isObject(name)) for (attName in name) hasProp.call(name, attName) && (attValue = name[attName], 
                    this.attribute(attName, attValue)); else isFunction(value) && (value = value.apply()), 
                    this.options.skipNullAttributes && null == value || (this.currentNode.attributes[name] = new XMLAttribute(this, name, value));
                    return this;
                }, XMLDocumentCB.prototype.text = function(value) {
                    var node;
                    return this.openCurrent(), node = new XMLText(this, value), this.onData(this.writer.text(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.cdata = function(value) {
                    var node;
                    return this.openCurrent(), node = new XMLCData(this, value), this.onData(this.writer.cdata(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.comment = function(value) {
                    var node;
                    return this.openCurrent(), node = new XMLComment(this, value), this.onData(this.writer.comment(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.raw = function(value) {
                    var node;
                    return this.openCurrent(), node = new XMLRaw(this, value), this.onData(this.writer.raw(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.instruction = function(target, value) {
                    var i, insTarget, insValue, len, node;
                    if (this.openCurrent(), null != target && (target = target.valueOf()), null != value && (value = value.valueOf()), 
                    Array.isArray(target)) for (i = 0, len = target.length; i < len; i++) insTarget = target[i], 
                    this.instruction(insTarget); else if (isObject(target)) for (insTarget in target) hasProp.call(target, insTarget) && (insValue = target[insTarget], 
                    this.instruction(insTarget, insValue)); else isFunction(value) && (value = value.apply()), 
                    node = new XMLProcessingInstruction(this, target, value), this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
                    return this;
                }, XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
                    var node;
                    if (this.openCurrent(), this.documentStarted) throw new Error("declaration() must be the first node");
                    return node = new XMLDeclaration(this, version, encoding, standalone), this.onData(this.writer.declaration(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
                    if (this.openCurrent(), null == root) throw new Error("Missing root node name");
                    if (this.root) throw new Error("dtd() must come before the root node");
                    return this.currentNode = new XMLDocType(this, pubID, sysID), this.currentNode.rootNodeName = root, 
                    this.currentNode.children = !1, this.currentLevel++, this.openTags[this.currentLevel] = this.currentNode, 
                    this;
                }, XMLDocumentCB.prototype.dtdElement = function(name, value) {
                    var node;
                    return this.openCurrent(), node = new XMLDTDElement(this, name, value), this.onData(this.writer.dtdElement(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
                    var node;
                    return this.openCurrent(), node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue), 
                    this.onData(this.writer.dtdAttList(node, this.currentLevel + 1)), this;
                }, XMLDocumentCB.prototype.entity = function(name, value) {
                    var node;
                    return this.openCurrent(), node = new XMLDTDEntity(this, !1, name, value), this.onData(this.writer.dtdEntity(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.pEntity = function(name, value) {
                    var node;
                    return this.openCurrent(), node = new XMLDTDEntity(this, !0, name, value), this.onData(this.writer.dtdEntity(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.notation = function(name, value) {
                    var node;
                    return this.openCurrent(), node = new XMLDTDNotation(this, name, value), this.onData(this.writer.dtdNotation(node, this.currentLevel + 1)), 
                    this;
                }, XMLDocumentCB.prototype.up = function() {
                    if (this.currentLevel < 0) throw new Error("The document node has no parent");
                    return this.currentNode ? (this.currentNode.children ? this.closeNode(this.currentNode) : this.openNode(this.currentNode), 
                    this.currentNode = null) : this.closeNode(this.openTags[this.currentLevel]), delete this.openTags[this.currentLevel], 
                    this.currentLevel--, this;
                }, XMLDocumentCB.prototype.end = function() {
                    for (;0 <= this.currentLevel; ) this.up();
                    return this.onEnd();
                }, XMLDocumentCB.prototype.openCurrent = function() {
                    if (this.currentNode) return this.currentNode.children = !0, this.openNode(this.currentNode);
                }, XMLDocumentCB.prototype.openNode = function(node) {
                    if (!node.isOpen) return !this.root && 0 === this.currentLevel && node instanceof XMLElement && (this.root = node), 
                    this.onData(this.writer.openNode(node, this.currentLevel)), node.isOpen = !0;
                }, XMLDocumentCB.prototype.closeNode = function(node) {
                    if (!node.isClosed) return this.onData(this.writer.closeNode(node, this.currentLevel)), 
                    node.isClosed = !0;
                }, XMLDocumentCB.prototype.onData = function(chunk) {
                    return this.documentStarted = !0, this.onDataCallback(chunk);
                }, XMLDocumentCB.prototype.onEnd = function() {
                    return this.documentCompleted = !0, this.onEndCallback();
                }, XMLDocumentCB.prototype.ele = function() {
                    return this.element.apply(this, arguments);
                }, XMLDocumentCB.prototype.nod = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                }, XMLDocumentCB.prototype.txt = function(value) {
                    return this.text(value);
                }, XMLDocumentCB.prototype.dat = function(value) {
                    return this.cdata(value);
                }, XMLDocumentCB.prototype.com = function(value) {
                    return this.comment(value);
                }, XMLDocumentCB.prototype.ins = function(target, value) {
                    return this.instruction(target, value);
                }, XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
                    return this.declaration(version, encoding, standalone);
                }, XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
                    return this.doctype(root, pubID, sysID);
                }, XMLDocumentCB.prototype.e = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                }, XMLDocumentCB.prototype.n = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                }, XMLDocumentCB.prototype.t = function(value) {
                    return this.text(value);
                }, XMLDocumentCB.prototype.d = function(value) {
                    return this.cdata(value);
                }, XMLDocumentCB.prototype.c = function(value) {
                    return this.comment(value);
                }, XMLDocumentCB.prototype.r = function(value) {
                    return this.raw(value);
                }, XMLDocumentCB.prototype.i = function(target, value) {
                    return this.instruction(target, value);
                }, XMLDocumentCB.prototype.att = function() {
                    return this.currentNode && this.currentNode instanceof XMLDocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
                }, XMLDocumentCB.prototype.a = function() {
                    return this.currentNode && this.currentNode instanceof XMLDocType ? this.attList.apply(this, arguments) : this.attribute.apply(this, arguments);
                }, XMLDocumentCB.prototype.ent = function(name, value) {
                    return this.entity(name, value);
                }, XMLDocumentCB.prototype.pent = function(name, value) {
                    return this.pEntity(name, value);
                }, XMLDocumentCB.prototype.not = function(name, value) {
                    return this.notation(name, value);
                }, XMLDocumentCB;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLAttribute": 90,
        "./XMLCData": 91,
        "./XMLComment": 92,
        "./XMLDTDAttList": 93,
        "./XMLDTDElement": 94,
        "./XMLDTDEntity": 95,
        "./XMLDTDNotation": 96,
        "./XMLDeclaration": 97,
        "./XMLDocType": 98,
        "./XMLElement": 101,
        "./XMLProcessingInstruction": 103,
        "./XMLRaw": 104,
        "./XMLStringWriter": 106,
        "./XMLStringifier": 107,
        "./XMLText": 108
    } ],
    101: [ function(require, module, exports) {
        (function() {
            var XMLAttribute, XMLNode, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
            ref = require("./Utility"), isObject = ref.isObject, isFunction = ref.isFunction, 
            XMLNode = require("./XMLNode"), XMLAttribute = require("./XMLAttribute"), module.exports = function(superClass) {
                function XMLElement(parent, name, attributes) {
                    if (XMLElement.__super__.constructor.call(this, parent), null == name) throw new Error("Missing element name");
                    this.name = this.stringify.eleName(name), this.attributes = {}, null != attributes && this.attribute(attributes), 
                    parent.isDocument && (this.isRoot = !0, (this.documentObject = parent).rootObject = this);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLElement, XMLNode), XMLElement.prototype.clone = function() {
                    var att, attName, clonedSelf, ref1;
                    for (attName in (clonedSelf = Object.create(this)).isRoot && (clonedSelf.documentObject = null), 
                    clonedSelf.attributes = {}, ref1 = this.attributes) hasProp.call(ref1, attName) && (att = ref1[attName], 
                    clonedSelf.attributes[attName] = att.clone());
                    return clonedSelf.children = [], this.children.forEach(function(child) {
                        var clonedChild;
                        return ((clonedChild = child.clone()).parent = clonedSelf).children.push(clonedChild);
                    }), clonedSelf;
                }, XMLElement.prototype.attribute = function(name, value) {
                    var attName, attValue;
                    if (null != name && (name = name.valueOf()), isObject(name)) for (attName in name) hasProp.call(name, attName) && (attValue = name[attName], 
                    this.attribute(attName, attValue)); else isFunction(value) && (value = value.apply()), 
                    this.options.skipNullAttributes && null == value || (this.attributes[name] = new XMLAttribute(this, name, value));
                    return this;
                }, XMLElement.prototype.removeAttribute = function(name) {
                    var attName, i, len;
                    if (null == name) throw new Error("Missing attribute name");
                    if (name = name.valueOf(), Array.isArray(name)) for (i = 0, len = name.length; i < len; i++) attName = name[i], 
                    delete this.attributes[attName]; else delete this.attributes[name];
                    return this;
                }, XMLElement.prototype.toString = function(options) {
                    return this.options.writer.set(options).element(this);
                }, XMLElement.prototype.att = function(name, value) {
                    return this.attribute(name, value);
                }, XMLElement.prototype.a = function(name, value) {
                    return this.attribute(name, value);
                }, XMLElement;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLAttribute": 90,
        "./XMLNode": 102
    } ],
    102: [ function(require, module, exports) {
        (function() {
            var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref, hasProp = {}.hasOwnProperty;
            ref = require("./Utility"), isObject = ref.isObject, isFunction = ref.isFunction, 
            isEmpty = ref.isEmpty, XMLProcessingInstruction = XMLText = XMLRaw = XMLDocType = XMLDeclaration = XMLComment = XMLCData = XMLElement = null, 
            module.exports = function() {
                function XMLNode(parent) {
                    this.parent = parent, this.parent && (this.options = this.parent.options, this.stringify = this.parent.stringify), 
                    this.children = [], XMLElement || (XMLElement = require("./XMLElement"), XMLCData = require("./XMLCData"), 
                    XMLComment = require("./XMLComment"), XMLDeclaration = require("./XMLDeclaration"), 
                    XMLDocType = require("./XMLDocType"), XMLRaw = require("./XMLRaw"), XMLText = require("./XMLText"), 
                    XMLProcessingInstruction = require("./XMLProcessingInstruction"));
                }
                return XMLNode.prototype.element = function(name, attributes, text) {
                    var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
                    if ((lastChild = null) == attributes && (attributes = {}), attributes = attributes.valueOf(), 
                    isObject(attributes) || (text = (ref1 = [ attributes, text ])[0], attributes = ref1[1]), 
                    null != name && (name = name.valueOf()), Array.isArray(name)) for (j = 0, len = name.length; j < len; j++) item = name[j], 
                    lastChild = this.element(item); else if (isFunction(name)) lastChild = this.element(name.apply()); else if (isObject(name)) {
                        for (key in name) if (hasProp.call(name, key)) if (val = name[key], isFunction(val) && (val = val.apply()), 
                        isObject(val) && isEmpty(val) && (val = null), !this.options.ignoreDecorators && this.stringify.convertAttKey && 0 === key.indexOf(this.stringify.convertAttKey)) lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val); else if (!this.options.separateArrayItems && Array.isArray(val)) for (k = 0, 
                        len1 = val.length; k < len1; k++) item = val[k], (childNode = {})[key] = item, lastChild = this.element(childNode); else isObject(val) ? (lastChild = this.element(key)).element(val) : lastChild = this.element(key, val);
                    } else lastChild = !this.options.ignoreDecorators && this.stringify.convertTextKey && 0 === name.indexOf(this.stringify.convertTextKey) ? this.text(text) : !this.options.ignoreDecorators && this.stringify.convertCDataKey && 0 === name.indexOf(this.stringify.convertCDataKey) ? this.cdata(text) : !this.options.ignoreDecorators && this.stringify.convertCommentKey && 0 === name.indexOf(this.stringify.convertCommentKey) ? this.comment(text) : !this.options.ignoreDecorators && this.stringify.convertRawKey && 0 === name.indexOf(this.stringify.convertRawKey) ? this.raw(text) : !this.options.ignoreDecorators && this.stringify.convertPIKey && 0 === name.indexOf(this.stringify.convertPIKey) ? this.instruction(name.substr(this.stringify.convertPIKey.length), text) : this.node(name, attributes, text);
                    if (null == lastChild) throw new Error("Could not create any elements with: " + name);
                    return lastChild;
                }, XMLNode.prototype.insertBefore = function(name, attributes, text) {
                    var child, i, removed;
                    if (this.isRoot) throw new Error("Cannot insert elements at root level");
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
                    child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), 
                    child;
                }, XMLNode.prototype.insertAfter = function(name, attributes, text) {
                    var child, i, removed;
                    if (this.isRoot) throw new Error("Cannot insert elements at root level");
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
                    child = this.parent.element(name, attributes, text), Array.prototype.push.apply(this.parent.children, removed), 
                    child;
                }, XMLNode.prototype.remove = function() {
                    var i;
                    if (this.isRoot) throw new Error("Cannot remove the root element");
                    return i = this.parent.children.indexOf(this), [].splice.apply(this.parent.children, [ i, i - i + 1 ].concat([])), 
                    this.parent;
                }, XMLNode.prototype.node = function(name, attributes, text) {
                    var child, ref1;
                    return null != name && (name = name.valueOf()), attributes || (attributes = {}), 
                    attributes = attributes.valueOf(), isObject(attributes) || (text = (ref1 = [ attributes, text ])[0], 
                    attributes = ref1[1]), child = new XMLElement(this, name, attributes), null != text && child.text(text), 
                    this.children.push(child), child;
                }, XMLNode.prototype.text = function(value) {
                    var child;
                    return child = new XMLText(this, value), this.children.push(child), this;
                }, XMLNode.prototype.cdata = function(value) {
                    var child;
                    return child = new XMLCData(this, value), this.children.push(child), this;
                }, XMLNode.prototype.comment = function(value) {
                    var child;
                    return child = new XMLComment(this, value), this.children.push(child), this;
                }, XMLNode.prototype.commentBefore = function(value) {
                    var i, removed;
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
                    this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), 
                    this;
                }, XMLNode.prototype.commentAfter = function(value) {
                    var i, removed;
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
                    this.parent.comment(value), Array.prototype.push.apply(this.parent.children, removed), 
                    this;
                }, XMLNode.prototype.raw = function(value) {
                    var child;
                    return child = new XMLRaw(this, value), this.children.push(child), this;
                }, XMLNode.prototype.instruction = function(target, value) {
                    var insTarget, insValue, instruction, j, len;
                    if (null != target && (target = target.valueOf()), null != value && (value = value.valueOf()), 
                    Array.isArray(target)) for (j = 0, len = target.length; j < len; j++) insTarget = target[j], 
                    this.instruction(insTarget); else if (isObject(target)) for (insTarget in target) hasProp.call(target, insTarget) && (insValue = target[insTarget], 
                    this.instruction(insTarget, insValue)); else isFunction(value) && (value = value.apply()), 
                    instruction = new XMLProcessingInstruction(this, target, value), this.children.push(instruction);
                    return this;
                }, XMLNode.prototype.instructionBefore = function(target, value) {
                    var i, removed;
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i), 
                    this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), 
                    this;
                }, XMLNode.prototype.instructionAfter = function(target, value) {
                    var i, removed;
                    return i = this.parent.children.indexOf(this), removed = this.parent.children.splice(i + 1), 
                    this.parent.instruction(target, value), Array.prototype.push.apply(this.parent.children, removed), 
                    this;
                }, XMLNode.prototype.declaration = function(version, encoding, standalone) {
                    var doc, xmldec;
                    return doc = this.document(), xmldec = new XMLDeclaration(doc, version, encoding, standalone), 
                    doc.children[0] instanceof XMLDeclaration ? doc.children[0] = xmldec : doc.children.unshift(xmldec), 
                    doc.root() || doc;
                }, XMLNode.prototype.doctype = function(pubID, sysID) {
                    var doc, doctype, i, j, k, len, len1, ref1, ref2;
                    for (doc = this.document(), doctype = new XMLDocType(doc, pubID, sysID), i = j = 0, 
                    len = (ref1 = doc.children).length; j < len; i = ++j) if (ref1[i] instanceof XMLDocType) return doc.children[i] = doctype;
                    for (i = k = 0, len1 = (ref2 = doc.children).length; k < len1; i = ++k) if (ref2[i].isRoot) return doc.children.splice(i, 0, doctype), 
                    doctype;
                    return doc.children.push(doctype), doctype;
                }, XMLNode.prototype.up = function() {
                    if (this.isRoot) throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
                    return this.parent;
                }, XMLNode.prototype.root = function() {
                    var node;
                    for (node = this; node; ) {
                        if (node.isDocument) return node.rootObject;
                        if (node.isRoot) return node;
                        node = node.parent;
                    }
                }, XMLNode.prototype.document = function() {
                    var node;
                    for (node = this; node; ) {
                        if (node.isDocument) return node;
                        node = node.parent;
                    }
                }, XMLNode.prototype.end = function(options) {
                    return this.document().end(options);
                }, XMLNode.prototype.prev = function() {
                    var i;
                    if ((i = this.parent.children.indexOf(this)) < 1) throw new Error("Already at the first node");
                    return this.parent.children[i - 1];
                }, XMLNode.prototype.next = function() {
                    var i;
                    if (-1 === (i = this.parent.children.indexOf(this)) || i === this.parent.children.length - 1) throw new Error("Already at the last node");
                    return this.parent.children[i + 1];
                }, XMLNode.prototype.importDocument = function(doc) {
                    var clonedRoot;
                    return (clonedRoot = doc.root().clone()).parent = this, clonedRoot.isRoot = !1, 
                    this.children.push(clonedRoot), this;
                }, XMLNode.prototype.ele = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                }, XMLNode.prototype.nod = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                }, XMLNode.prototype.txt = function(value) {
                    return this.text(value);
                }, XMLNode.prototype.dat = function(value) {
                    return this.cdata(value);
                }, XMLNode.prototype.com = function(value) {
                    return this.comment(value);
                }, XMLNode.prototype.ins = function(target, value) {
                    return this.instruction(target, value);
                }, XMLNode.prototype.doc = function() {
                    return this.document();
                }, XMLNode.prototype.dec = function(version, encoding, standalone) {
                    return this.declaration(version, encoding, standalone);
                }, XMLNode.prototype.dtd = function(pubID, sysID) {
                    return this.doctype(pubID, sysID);
                }, XMLNode.prototype.e = function(name, attributes, text) {
                    return this.element(name, attributes, text);
                }, XMLNode.prototype.n = function(name, attributes, text) {
                    return this.node(name, attributes, text);
                }, XMLNode.prototype.t = function(value) {
                    return this.text(value);
                }, XMLNode.prototype.d = function(value) {
                    return this.cdata(value);
                }, XMLNode.prototype.c = function(value) {
                    return this.comment(value);
                }, XMLNode.prototype.r = function(value) {
                    return this.raw(value);
                }, XMLNode.prototype.i = function(target, value) {
                    return this.instruction(target, value);
                }, XMLNode.prototype.u = function() {
                    return this.up();
                }, XMLNode.prototype.importXMLBuilder = function(doc) {
                    return this.importDocument(doc);
                }, XMLNode;
            }();
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLCData": 91,
        "./XMLComment": 92,
        "./XMLDeclaration": 97,
        "./XMLDocType": 98,
        "./XMLElement": 101,
        "./XMLProcessingInstruction": 103,
        "./XMLRaw": 104,
        "./XMLText": 108
    } ],
    103: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLProcessingInstruction(parent, target, value) {
                    if (XMLProcessingInstruction.__super__.constructor.call(this, parent), null == target) throw new Error("Missing instruction target");
                    this.target = this.stringify.insTarget(target), value && (this.value = this.stringify.insValue(value));
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLProcessingInstruction, XMLNode), XMLProcessingInstruction.prototype.clone = function() {
                    return Object.create(this);
                }, XMLProcessingInstruction.prototype.toString = function(options) {
                    return this.options.writer.set(options).processingInstruction(this);
                }, XMLProcessingInstruction;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    104: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLRaw(parent, text) {
                    if (XMLRaw.__super__.constructor.call(this, parent), null == text) throw new Error("Missing raw text");
                    this.value = this.stringify.raw(text);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLRaw, XMLNode), XMLRaw.prototype.clone = function() {
                    return Object.create(this);
                }, XMLRaw.prototype.toString = function(options) {
                    return this.options.writer.set(options).raw(this);
                }, XMLRaw;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    105: [ function(require, module, exports) {
        (function() {
            var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, hasProp = {}.hasOwnProperty;
            XMLDeclaration = require("./XMLDeclaration"), XMLDocType = require("./XMLDocType"), 
            XMLCData = require("./XMLCData"), XMLComment = require("./XMLComment"), XMLElement = require("./XMLElement"), 
            XMLRaw = require("./XMLRaw"), XMLText = require("./XMLText"), XMLProcessingInstruction = require("./XMLProcessingInstruction"), 
            XMLDTDAttList = require("./XMLDTDAttList"), XMLDTDElement = require("./XMLDTDElement"), 
            XMLDTDEntity = require("./XMLDTDEntity"), XMLDTDNotation = require("./XMLDTDNotation"), 
            XMLWriterBase = require("./XMLWriterBase"), module.exports = function(superClass) {
                function XMLStreamWriter(stream, options) {
                    XMLStreamWriter.__super__.constructor.call(this, options), this.stream = stream;
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLStreamWriter, XMLWriterBase), XMLStreamWriter.prototype.document = function(doc) {
                    var child, i, j, len, len1, ref, ref1, results;
                    for (i = 0, len = (ref = doc.children).length; i < len; i++) (child = ref[i]).isLastRootNode = !1;
                    for (doc.children[doc.children.length - 1].isLastRootNode = !0, results = [], j = 0, 
                    len1 = (ref1 = doc.children).length; j < len1; j++) switch (child = ref1[j], !1) {
                      case !(child instanceof XMLDeclaration):
                        results.push(this.declaration(child));
                        break;

                      case !(child instanceof XMLDocType):
                        results.push(this.docType(child));
                        break;

                      case !(child instanceof XMLComment):
                        results.push(this.comment(child));
                        break;

                      case !(child instanceof XMLProcessingInstruction):
                        results.push(this.processingInstruction(child));
                        break;

                      default:
                        results.push(this.element(child));
                    }
                    return results;
                }, XMLStreamWriter.prototype.attribute = function(att) {
                    return this.stream.write(" " + att.name + '="' + att.value + '"');
                }, XMLStreamWriter.prototype.cdata = function(node, level) {
                    return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
                }, XMLStreamWriter.prototype.comment = function(node, level) {
                    return this.stream.write(this.space(level) + "\x3c!-- " + node.text + " --\x3e" + this.endline(node));
                }, XMLStreamWriter.prototype.declaration = function(node, level) {
                    return this.stream.write(this.space(level)), this.stream.write('<?xml version="' + node.version + '"'), 
                    null != node.encoding && this.stream.write(' encoding="' + node.encoding + '"'), 
                    null != node.standalone && this.stream.write(' standalone="' + node.standalone + '"'), 
                    this.stream.write(this.spacebeforeslash + "?>"), this.stream.write(this.endline(node));
                }, XMLStreamWriter.prototype.docType = function(node, level) {
                    var child, i, len, ref;
                    if (level || (level = 0), this.stream.write(this.space(level)), this.stream.write("<!DOCTYPE " + node.root().name), 
                    node.pubID && node.sysID ? this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"') : node.sysID && this.stream.write(' SYSTEM "' + node.sysID + '"'), 
                    0 < node.children.length) {
                        for (this.stream.write(" ["), this.stream.write(this.endline(node)), i = 0, len = (ref = node.children).length; i < len; i++) switch (child = ref[i], 
                        !1) {
                          case !(child instanceof XMLDTDAttList):
                            this.dtdAttList(child, level + 1);
                            break;

                          case !(child instanceof XMLDTDElement):
                            this.dtdElement(child, level + 1);
                            break;

                          case !(child instanceof XMLDTDEntity):
                            this.dtdEntity(child, level + 1);
                            break;

                          case !(child instanceof XMLDTDNotation):
                            this.dtdNotation(child, level + 1);
                            break;

                          case !(child instanceof XMLCData):
                            this.cdata(child, level + 1);
                            break;

                          case !(child instanceof XMLComment):
                            this.comment(child, level + 1);
                            break;

                          case !(child instanceof XMLProcessingInstruction):
                            this.processingInstruction(child, level + 1);
                            break;

                          default:
                            throw new Error("Unknown DTD node type: " + child.constructor.name);
                        }
                        this.stream.write("]");
                    }
                    return this.stream.write(this.spacebeforeslash + ">"), this.stream.write(this.endline(node));
                }, XMLStreamWriter.prototype.element = function(node, level) {
                    var att, child, i, len, name, ref, ref1, space;
                    for (name in level || (level = 0), space = this.space(level), this.stream.write(space + "<" + node.name), 
                    ref = node.attributes) hasProp.call(ref, name) && (att = ref[name], this.attribute(att));
                    if (0 === node.children.length || node.children.every(function(e) {
                        return "" === e.value;
                    })) this.allowEmpty ? this.stream.write("></" + node.name + ">") : this.stream.write(this.spacebeforeslash + "/>"); else if (this.pretty && 1 === node.children.length && null != node.children[0].value) this.stream.write(">"), 
                    this.stream.write(node.children[0].value), this.stream.write("</" + node.name + ">"); else {
                        for (this.stream.write(">" + this.newline), i = 0, len = (ref1 = node.children).length; i < len; i++) switch (child = ref1[i], 
                        !1) {
                          case !(child instanceof XMLCData):
                            this.cdata(child, level + 1);
                            break;

                          case !(child instanceof XMLComment):
                            this.comment(child, level + 1);
                            break;

                          case !(child instanceof XMLElement):
                            this.element(child, level + 1);
                            break;

                          case !(child instanceof XMLRaw):
                            this.raw(child, level + 1);
                            break;

                          case !(child instanceof XMLText):
                            this.text(child, level + 1);
                            break;

                          case !(child instanceof XMLProcessingInstruction):
                            this.processingInstruction(child, level + 1);
                            break;

                          default:
                            throw new Error("Unknown XML node type: " + child.constructor.name);
                        }
                        this.stream.write(space + "</" + node.name + ">");
                    }
                    return this.stream.write(this.endline(node));
                }, XMLStreamWriter.prototype.processingInstruction = function(node, level) {
                    return this.stream.write(this.space(level) + "<?" + node.target), node.value && this.stream.write(" " + node.value), 
                    this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
                }, XMLStreamWriter.prototype.raw = function(node, level) {
                    return this.stream.write(this.space(level) + node.value + this.endline(node));
                }, XMLStreamWriter.prototype.text = function(node, level) {
                    return this.stream.write(this.space(level) + node.value + this.endline(node));
                }, XMLStreamWriter.prototype.dtdAttList = function(node, level) {
                    return this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType), 
                    "#DEFAULT" !== node.defaultValueType && this.stream.write(" " + node.defaultValueType), 
                    node.defaultValue && this.stream.write(' "' + node.defaultValue + '"'), this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
                }, XMLStreamWriter.prototype.dtdElement = function(node, level) {
                    return this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value), 
                    this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
                }, XMLStreamWriter.prototype.dtdEntity = function(node, level) {
                    return this.stream.write(this.space(level) + "<!ENTITY"), node.pe && this.stream.write(" %"), 
                    this.stream.write(" " + node.name), node.value ? this.stream.write(' "' + node.value + '"') : (node.pubID && node.sysID ? this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"') : node.sysID && this.stream.write(' SYSTEM "' + node.sysID + '"'), 
                    node.nData && this.stream.write(" NDATA " + node.nData)), this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
                }, XMLStreamWriter.prototype.dtdNotation = function(node, level) {
                    return this.stream.write(this.space(level) + "<!NOTATION " + node.name), node.pubID && node.sysID ? this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"') : node.pubID ? this.stream.write(' PUBLIC "' + node.pubID + '"') : node.sysID && this.stream.write(' SYSTEM "' + node.sysID + '"'), 
                    this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
                }, XMLStreamWriter.prototype.endline = function(node) {
                    return node.isLastRootNode ? "" : this.newline;
                }, XMLStreamWriter;
            }();
        }).call(this);
    }, {
        "./XMLCData": 91,
        "./XMLComment": 92,
        "./XMLDTDAttList": 93,
        "./XMLDTDElement": 94,
        "./XMLDTDEntity": 95,
        "./XMLDTDNotation": 96,
        "./XMLDeclaration": 97,
        "./XMLDocType": 98,
        "./XMLElement": 101,
        "./XMLProcessingInstruction": 103,
        "./XMLRaw": 104,
        "./XMLText": 108,
        "./XMLWriterBase": 109
    } ],
    106: [ function(require, module, exports) {
        (function() {
            var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLText, XMLWriterBase, hasProp = {}.hasOwnProperty;
            XMLDeclaration = require("./XMLDeclaration"), XMLDocType = require("./XMLDocType"), 
            XMLCData = require("./XMLCData"), XMLComment = require("./XMLComment"), XMLElement = require("./XMLElement"), 
            XMLRaw = require("./XMLRaw"), XMLText = require("./XMLText"), XMLProcessingInstruction = require("./XMLProcessingInstruction"), 
            XMLDTDAttList = require("./XMLDTDAttList"), XMLDTDElement = require("./XMLDTDElement"), 
            XMLDTDEntity = require("./XMLDTDEntity"), XMLDTDNotation = require("./XMLDTDNotation"), 
            XMLWriterBase = require("./XMLWriterBase"), module.exports = function(superClass) {
                function XMLStringWriter(options) {
                    XMLStringWriter.__super__.constructor.call(this, options);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLStringWriter, XMLWriterBase), XMLStringWriter.prototype.document = function(doc) {
                    var child, i, len, r, ref;
                    for (this.textispresent = !1, r = "", i = 0, len = (ref = doc.children).length; i < len; i++) child = ref[i], 
                    r += function() {
                        switch (!1) {
                          case !(child instanceof XMLDeclaration):
                            return this.declaration(child);

                          case !(child instanceof XMLDocType):
                            return this.docType(child);

                          case !(child instanceof XMLComment):
                            return this.comment(child);

                          case !(child instanceof XMLProcessingInstruction):
                            return this.processingInstruction(child);

                          default:
                            return this.element(child, 0);
                        }
                    }.call(this);
                    return this.pretty && r.slice(-this.newline.length) === this.newline && (r = r.slice(0, -this.newline.length)), 
                    r;
                }, XMLStringWriter.prototype.attribute = function(att) {
                    return " " + att.name + '="' + att.value + '"';
                }, XMLStringWriter.prototype.cdata = function(node, level) {
                    return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
                }, XMLStringWriter.prototype.comment = function(node, level) {
                    return this.space(level) + "\x3c!-- " + node.text + " --\x3e" + this.newline;
                }, XMLStringWriter.prototype.declaration = function(node, level) {
                    var r;
                    return r = this.space(level), r += '<?xml version="' + node.version + '"', null != node.encoding && (r += ' encoding="' + node.encoding + '"'), 
                    null != node.standalone && (r += ' standalone="' + node.standalone + '"'), r += this.spacebeforeslash + "?>", 
                    r += this.newline;
                }, XMLStringWriter.prototype.docType = function(node, level) {
                    var child, i, len, r, ref;
                    if (level || (level = 0), r = this.space(level), r += "<!DOCTYPE " + node.root().name, 
                    node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
                    0 < node.children.length) {
                        for (r += " [", r += this.newline, i = 0, len = (ref = node.children).length; i < len; i++) child = ref[i], 
                        r += function() {
                            switch (!1) {
                              case !(child instanceof XMLDTDAttList):
                                return this.dtdAttList(child, level + 1);

                              case !(child instanceof XMLDTDElement):
                                return this.dtdElement(child, level + 1);

                              case !(child instanceof XMLDTDEntity):
                                return this.dtdEntity(child, level + 1);

                              case !(child instanceof XMLDTDNotation):
                                return this.dtdNotation(child, level + 1);

                              case !(child instanceof XMLCData):
                                return this.cdata(child, level + 1);

                              case !(child instanceof XMLComment):
                                return this.comment(child, level + 1);

                              case !(child instanceof XMLProcessingInstruction):
                                return this.processingInstruction(child, level + 1);

                              default:
                                throw new Error("Unknown DTD node type: " + child.constructor.name);
                            }
                        }.call(this);
                        r += "]";
                    }
                    return r += this.spacebeforeslash + ">", r += this.newline;
                }, XMLStringWriter.prototype.element = function(node, level) {
                    var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
                    for (name in level || (level = 0), textispresentwasset = !1, this.textispresent ? (this.newline = "", 
                    this.pretty = !1) : (this.newline = this.newlinedefault, this.pretty = this.prettydefault), 
                    r = "", r += (space = this.space(level)) + "<" + node.name, ref = node.attributes) hasProp.call(ref, name) && (att = ref[name], 
                    r += this.attribute(att));
                    if (0 === node.children.length || node.children.every(function(e) {
                        return "" === e.value;
                    })) this.allowEmpty ? r += "></" + node.name + ">" + this.newline : r += this.spacebeforeslash + "/>" + this.newline; else if (this.pretty && 1 === node.children.length && null != node.children[0].value) r += ">", 
                    r += node.children[0].value, r += "</" + node.name + ">" + this.newline; else {
                        if (this.dontprettytextnodes) for (i = 0, len = (ref1 = node.children).length; i < len; i++) if (null != (child = ref1[i]).value) {
                            this.textispresent++, textispresentwasset = !0;
                            break;
                        }
                        for (this.textispresent && (this.newline = "", this.pretty = !1, space = this.space(level)), 
                        r += ">" + this.newline, j = 0, len1 = (ref2 = node.children).length; j < len1; j++) child = ref2[j], 
                        r += function() {
                            switch (!1) {
                              case !(child instanceof XMLCData):
                                return this.cdata(child, level + 1);

                              case !(child instanceof XMLComment):
                                return this.comment(child, level + 1);

                              case !(child instanceof XMLElement):
                                return this.element(child, level + 1);

                              case !(child instanceof XMLRaw):
                                return this.raw(child, level + 1);

                              case !(child instanceof XMLText):
                                return this.text(child, level + 1);

                              case !(child instanceof XMLProcessingInstruction):
                                return this.processingInstruction(child, level + 1);

                              default:
                                throw new Error("Unknown XML node type: " + child.constructor.name);
                            }
                        }.call(this);
                        textispresentwasset && this.textispresent--, this.textispresent || (this.newline = this.newlinedefault, 
                        this.pretty = this.prettydefault), r += space + "</" + node.name + ">" + this.newline;
                    }
                    return r;
                }, XMLStringWriter.prototype.processingInstruction = function(node, level) {
                    var r;
                    return r = this.space(level) + "<?" + node.target, node.value && (r += " " + node.value), 
                    r += this.spacebeforeslash + "?>" + this.newline;
                }, XMLStringWriter.prototype.raw = function(node, level) {
                    return this.space(level) + node.value + this.newline;
                }, XMLStringWriter.prototype.text = function(node, level) {
                    return this.space(level) + node.value + this.newline;
                }, XMLStringWriter.prototype.dtdAttList = function(node, level) {
                    var r;
                    return r = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType, 
                    "#DEFAULT" !== node.defaultValueType && (r += " " + node.defaultValueType), node.defaultValue && (r += ' "' + node.defaultValue + '"'), 
                    r += this.spacebeforeslash + ">" + this.newline;
                }, XMLStringWriter.prototype.dtdElement = function(node, level) {
                    return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
                }, XMLStringWriter.prototype.dtdEntity = function(node, level) {
                    var r;
                    return r = this.space(level) + "<!ENTITY", node.pe && (r += " %"), r += " " + node.name, 
                    node.value ? r += ' "' + node.value + '"' : (node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
                    node.nData && (r += " NDATA " + node.nData)), r += this.spacebeforeslash + ">" + this.newline;
                }, XMLStringWriter.prototype.dtdNotation = function(node, level) {
                    var r;
                    return r = this.space(level) + "<!NOTATION " + node.name, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.pubID ? r += ' PUBLIC "' + node.pubID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
                    r += this.spacebeforeslash + ">" + this.newline;
                }, XMLStringWriter.prototype.openNode = function(node, level) {
                    var att, name, r, ref;
                    if (level || (level = 0), node instanceof XMLElement) {
                        for (name in r = this.space(level) + "<" + node.name, ref = node.attributes) hasProp.call(ref, name) && (att = ref[name], 
                        r += this.attribute(att));
                        return r += (node.children ? ">" : "/>") + this.newline;
                    }
                    return r = this.space(level) + "<!DOCTYPE " + node.rootNodeName, node.pubID && node.sysID ? r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"' : node.sysID && (r += ' SYSTEM "' + node.sysID + '"'), 
                    r += (node.children ? " [" : ">") + this.newline;
                }, XMLStringWriter.prototype.closeNode = function(node, level) {
                    switch (level || (level = 0), !1) {
                      case !(node instanceof XMLElement):
                        return this.space(level) + "</" + node.name + ">" + this.newline;

                      case !(node instanceof XMLDocType):
                        return this.space(level) + "]>" + this.newline;
                    }
                }, XMLStringWriter;
            }();
        }).call(this);
    }, {
        "./XMLCData": 91,
        "./XMLComment": 92,
        "./XMLDTDAttList": 93,
        "./XMLDTDElement": 94,
        "./XMLDTDEntity": 95,
        "./XMLDTDNotation": 96,
        "./XMLDeclaration": 97,
        "./XMLDocType": 98,
        "./XMLElement": 101,
        "./XMLProcessingInstruction": 103,
        "./XMLRaw": 104,
        "./XMLText": 108,
        "./XMLWriterBase": 109
    } ],
    107: [ function(require, module, exports) {
        (function() {
            var hasProp = {}.hasOwnProperty;
            module.exports = function() {
                function XMLStringifier(options) {
                    var fn, me, key, ref, value;
                    for (key in this.assertLegalChar = (fn = this.assertLegalChar, me = this, function() {
                        return fn.apply(me, arguments);
                    }), options || (options = {}), this.noDoubleEncoding = options.noDoubleEncoding, 
                    ref = options.stringify || {}) hasProp.call(ref, key) && (value = ref[key], this[key] = value);
                }
                return XMLStringifier.prototype.eleName = function(val) {
                    return val = "" + val || "", this.assertLegalChar(val);
                }, XMLStringifier.prototype.eleText = function(val) {
                    return val = "" + val || "", this.assertLegalChar(this.elEscape(val));
                }, XMLStringifier.prototype.cdata = function(val) {
                    return val = (val = "" + val || "").replace("]]>", "]]]]><![CDATA[>"), this.assertLegalChar(val);
                }, XMLStringifier.prototype.comment = function(val) {
                    if ((val = "" + val || "").match(/--/)) throw new Error("Comment text cannot contain double-hypen: " + val);
                    return this.assertLegalChar(val);
                }, XMLStringifier.prototype.raw = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.attName = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.attValue = function(val) {
                    return val = "" + val || "", this.attEscape(val);
                }, XMLStringifier.prototype.insTarget = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.insValue = function(val) {
                    if ((val = "" + val || "").match(/\?>/)) throw new Error("Invalid processing instruction value: " + val);
                    return val;
                }, XMLStringifier.prototype.xmlVersion = function(val) {
                    if (!(val = "" + val || "").match(/1\.[0-9]+/)) throw new Error("Invalid version number: " + val);
                    return val;
                }, XMLStringifier.prototype.xmlEncoding = function(val) {
                    if (!(val = "" + val || "").match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) throw new Error("Invalid encoding: " + val);
                    return val;
                }, XMLStringifier.prototype.xmlStandalone = function(val) {
                    return val ? "yes" : "no";
                }, XMLStringifier.prototype.dtdPubID = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.dtdSysID = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.dtdElementValue = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.dtdAttType = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.dtdAttDefault = function(val) {
                    return null != val ? "" + val || "" : val;
                }, XMLStringifier.prototype.dtdEntityValue = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.dtdNData = function(val) {
                    return "" + val || "";
                }, XMLStringifier.prototype.convertAttKey = "@", XMLStringifier.prototype.convertPIKey = "?", 
                XMLStringifier.prototype.convertTextKey = "#text", XMLStringifier.prototype.convertCDataKey = "#cdata", 
                XMLStringifier.prototype.convertCommentKey = "#comment", XMLStringifier.prototype.convertRawKey = "#raw", 
                XMLStringifier.prototype.assertLegalChar = function(str) {
                    var res;
                    if (res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/)) throw new Error("Invalid character in string: " + str + " at index " + res.index);
                    return str;
                }, XMLStringifier.prototype.elEscape = function(str) {
                    var ampregex;
                    return ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
                }, XMLStringifier.prototype.attEscape = function(str) {
                    var ampregex;
                    return ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g, str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
                }, XMLStringifier;
            }();
        }).call(this);
    }, {} ],
    108: [ function(require, module, exports) {
        (function() {
            var XMLNode, hasProp = {}.hasOwnProperty;
            XMLNode = require("./XMLNode"), module.exports = function(superClass) {
                function XMLText(parent, text) {
                    if (XMLText.__super__.constructor.call(this, parent), null == text) throw new Error("Missing element text");
                    this.value = this.stringify.eleText(text);
                }
                return function(child, parent) {
                    for (var key in parent) hasProp.call(parent, key) && (child[key] = parent[key]);
                    function ctor() {
                        this.constructor = child;
                    }
                    ctor.prototype = parent.prototype, child.prototype = new ctor(), child.__super__ = parent.prototype;
                }(XMLText, XMLNode), XMLText.prototype.clone = function() {
                    return Object.create(this);
                }, XMLText.prototype.toString = function(options) {
                    return this.options.writer.set(options).text(this);
                }, XMLText;
            }();
        }).call(this);
    }, {
        "./XMLNode": 102
    } ],
    109: [ function(require, module, exports) {
        (function() {
            var hasProp = {}.hasOwnProperty;
            module.exports = function() {
                function XMLWriterBase(options) {
                    var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
                    for (key in options || (options = {}), this.pretty = options.pretty || !1, this.allowEmpty = null != (ref = options.allowEmpty) && ref, 
                    this.pretty ? (this.indent = null != (ref1 = options.indent) ? ref1 : "  ", this.newline = null != (ref2 = options.newline) ? ref2 : "\n", 
                    this.offset = null != (ref3 = options.offset) ? ref3 : 0, this.dontprettytextnodes = null != (ref4 = options.dontprettytextnodes) ? ref4 : 0) : (this.indent = "", 
                    this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = null != (ref5 = options.spacebeforeslash) ? ref5 : "", 
                    !0 === this.spacebeforeslash && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, 
                    this.prettydefault = this.pretty, ref6 = options.writer || {}) hasProp.call(ref6, key) && (value = ref6[key], 
                    this[key] = value);
                }
                return XMLWriterBase.prototype.set = function(options) {
                    var key, ref, value;
                    for (key in options || (options = {}), "pretty" in options && (this.pretty = options.pretty), 
                    "allowEmpty" in options && (this.allowEmpty = options.allowEmpty), this.pretty ? (this.indent = "indent" in options ? options.indent : "  ", 
                    this.newline = "newline" in options ? options.newline : "\n", this.offset = "offset" in options ? options.offset : 0, 
                    this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0) : (this.indent = "", 
                    this.newline = "", this.offset = 0, this.dontprettytextnodes = 0), this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "", 
                    !0 === this.spacebeforeslash && (this.spacebeforeslash = " "), this.newlinedefault = this.newline, 
                    this.prettydefault = this.pretty, ref = options.writer || {}) hasProp.call(ref, key) && (value = ref[key], 
                    this[key] = value);
                    return this;
                }, XMLWriterBase.prototype.space = function(level) {
                    var indent;
                    return this.pretty && 0 < (indent = (level || 0) + this.offset + 1) ? new Array(indent).join(this.indent) : "";
                }, XMLWriterBase;
            }();
        }).call(this);
    }, {} ],
    110: [ function(require, module, exports) {
        (function() {
            var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;
            ref = require("./Utility"), assign = ref.assign, isFunction = ref.isFunction, XMLDocument = require("./XMLDocument"), 
            XMLDocumentCB = require("./XMLDocumentCB"), XMLStringWriter = require("./XMLStringWriter"), 
            XMLStreamWriter = require("./XMLStreamWriter"), module.exports.create = function(name, xmldec, doctype, options) {
                var doc, root;
                if (null == name) throw new Error("Root element needs a name");
                return options = assign({}, xmldec, doctype, options), root = (doc = new XMLDocument(options)).element(name), 
                options.headless || (doc.declaration(options), null == options.pubID && null == options.sysID || doc.doctype(options)), 
                root;
            }, module.exports.begin = function(options, onData, onEnd) {
                var ref1;
                return isFunction(options) && (onData = (ref1 = [ options, onData ])[0], onEnd = ref1[1], 
                options = {}), onData ? new XMLDocumentCB(options, onData, onEnd) : new XMLDocument(options);
            }, module.exports.stringWriter = function(options) {
                return new XMLStringWriter(options);
            }, module.exports.streamWriter = function(stream, options) {
                return new XMLStreamWriter(stream, options);
            };
        }).call(this);
    }, {
        "./Utility": 89,
        "./XMLDocument": 99,
        "./XMLDocumentCB": 100,
        "./XMLStreamWriter": 105,
        "./XMLStringWriter": 106
    } ],
    111: [ function(require, module, exports) {
        module.exports = function() {
            for (var target = {}, i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) hasOwnProperty.call(source, key) && (target[key] = source[key]);
            }
            return target;
        };
        var hasOwnProperty = Object.prototype.hasOwnProperty;
    }, {} ],
    Helper: [ function(require, module, exports) {
        "use strict";
        Object.defineProperty(exports, "__esModule", {
            value: !0
        });
        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }();
        var Helper = function() {
            function Helper() {
                !function(instance, Constructor) {
                    if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                }(this, Helper);
            }
            return _createClass(Helper, null, [ {
                key: "hasClass",
                value: function(el, className) {
                    return el.classList ? el.classList.contains(className) : !!el.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
                }
            }, {
                key: "addClass",
                value: function(el, className) {
                    el.classList ? el.classList.add(className) : this.hasClass(el, className) || (el.className += " " + className);
                }
            }, {
                key: "removeClass",
                value: function(el, className) {
                    if (el.classList) el.classList.remove(className); else if (this.hasClass(el, className)) {
                        var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
                        el.className = el.className.replace(reg, " ");
                    }
                }
            }, {
                key: "toggleClass",
                value: function(el, className) {
                    this.hasClass(el, className) ? this.removeClass(el, className) : this.addClass(el, className);
                }
            }, {
                key: "randomNumberToken",
                value: function() {
                    return new Date().valueOf();
                }
            } ]), Helper;
        }();
        exports.default = Helper, module.exports = exports.default;
    }, {} ],
    Nav: [ function(require, module, exports) {
        "use strict";
        var Subnav = require("./modules/SubNav"), Helper = require("./modules/Helper");
        !function() {
            var i, navs = document.getElementsByTagName("nav");
            for (i = 0; i < navs.length; i++) Helper.hasClass(navs[i], "dropdown") ? new Subnav(navs[i], !1, {
                persistentLabel: !0
            }) : new Subnav(navs[i]);
        }();
    }, {
        "./modules/Helper": "Helper",
        "./modules/SubNav": 5
    } ],
    Waypoints: [ function(require, module, exports) {
        !function() {
            "use strict";
            var keyCounter = 0, allWaypoints = {};
            function Waypoint(options) {
                if (!options) throw new Error("No options passed to Waypoint constructor");
                if (!options.element) throw new Error("No element option passed to Waypoint constructor");
                if (!options.handler) throw new Error("No handler option passed to Waypoint constructor");
                this.key = "waypoint-" + keyCounter, this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options), 
                this.element = this.options.element, this.adapter = new Waypoint.Adapter(this.element), 
                this.callback = options.handler, this.axis = this.options.horizontal ? "horizontal" : "vertical", 
                this.enabled = this.options.enabled, this.triggerPoint = null, this.group = Waypoint.Group.findOrCreate({
                    name: this.options.group,
                    axis: this.axis
                }), this.context = Waypoint.Context.findOrCreateByElement(this.options.context), 
                Waypoint.offsetAliases[this.options.offset] && (this.options.offset = Waypoint.offsetAliases[this.options.offset]), 
                this.group.add(this), this.context.add(this), allWaypoints[this.key] = this, keyCounter += 1;
            }
            Waypoint.prototype.queueTrigger = function(direction) {
                this.group.queueTrigger(this, direction);
            }, Waypoint.prototype.trigger = function(args) {
                this.enabled && this.callback && this.callback.apply(this, args);
            }, Waypoint.prototype.destroy = function() {
                this.context.remove(this), this.group.remove(this), delete allWaypoints[this.key];
            }, Waypoint.prototype.disable = function() {
                return this.enabled = !1, this;
            }, Waypoint.prototype.enable = function() {
                return this.context.refresh(), this.enabled = !0, this;
            }, Waypoint.prototype.next = function() {
                return this.group.next(this);
            }, Waypoint.prototype.previous = function() {
                return this.group.previous(this);
            }, Waypoint.invokeAll = function(method) {
                var allWaypointsArray = [];
                for (var waypointKey in allWaypoints) allWaypointsArray.push(allWaypoints[waypointKey]);
                for (var i = 0, end = allWaypointsArray.length; i < end; i++) allWaypointsArray[i][method]();
            }, Waypoint.destroyAll = function() {
                Waypoint.invokeAll("destroy");
            }, Waypoint.disableAll = function() {
                Waypoint.invokeAll("disable");
            }, Waypoint.enableAll = function() {
                for (var waypointKey in Waypoint.Context.refreshAll(), allWaypoints) allWaypoints[waypointKey].enabled = !0;
                return this;
            }, Waypoint.refreshAll = function() {
                Waypoint.Context.refreshAll();
            }, Waypoint.viewportHeight = function() {
                return window.innerHeight || document.documentElement.clientHeight;
            }, Waypoint.viewportWidth = function() {
                return document.documentElement.clientWidth;
            }, Waypoint.adapters = [], Waypoint.defaults = {
                context: window,
                continuous: !0,
                enabled: !0,
                group: "default",
                horizontal: !1,
                offset: 0
            }, Waypoint.offsetAliases = {
                "bottom-in-view": function() {
                    return this.context.innerHeight() - this.adapter.outerHeight();
                },
                "right-in-view": function() {
                    return this.context.innerWidth() - this.adapter.outerWidth();
                }
            }, window.Waypoint = Waypoint;
        }();
    }, {} ]
}, {}, [ 9, 4, 10, 5, "Helper" ]);